\hypertarget{group__CORE__PLASMA__Complex32__t}{}\section{Kernel Interface -\/ Single Complex}
\label{group__CORE__PLASMA__Complex32__t}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gacb63b22910fcb96ad757bad04d80bef4_gacb63b22910fcb96ad757bad04d80bef4}{C\+O\+R\+E\+\_\+cbrdalg1} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int n, int nb, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V\+Q, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U\+Q, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V\+P, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U\+P, int Vblksiz, int wantz, int i, int sweepid, int m, int grsiz, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$work)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga4946ac6b253acee9fc398bab035c7b92_ga4946ac6b253acee9fc398bab035c7b92}{C\+O\+R\+E\+\_\+cgbelr} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga4415cbf61356f4e5a3291688d94e7913_ga4415cbf61356f4e5a3291688d94e7913}{C\+O\+R\+E\+\_\+cgblrx} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga8d540e27bad6f137a7fe34d87a443098_ga8d540e27bad6f137a7fe34d87a443098}{C\+O\+R\+E\+\_\+cgbrce} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gaeac8b9c395c5b6c4e00ceb7b5160ea08_gaeac8b9c395c5b6c4e00ceb7b5160ea08}{C\+O\+R\+E\+\_\+cgbtype1cb} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, int N\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V\+Q, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U\+Q, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V\+P, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U\+P, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gab49cc5835213ad5ef256ea8087c9f589_gab49cc5835213ad5ef256ea8087c9f589}{C\+O\+R\+E\+\_\+cgbtype2cb} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, int N\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V\+Q, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U\+Q, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V\+P, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U\+P, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga5d3e35aade213d33733843e608fdda37_ga5d3e35aade213d33733843e608fdda37}{C\+O\+R\+E\+\_\+cgbtype3cb} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, int N\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V\+Q, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U\+Q, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V\+P, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U\+P, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga09e552315ef6f7d23be4dbfdc405b132_ga09e552315ef6f7d23be4dbfdc405b132}{C\+O\+R\+E\+\_\+cgeadd} (P\+L\+A\+S\+M\+A\+\_\+enum trans, int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t beta, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga3882801d5cbff5f623def8ecd0632f4f_ga3882801d5cbff5f623def8ecd0632f4f}{C\+O\+R\+E\+\_\+cgelqt} (int M, int N, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga10bb88ae2040e01eb7a08a037c2cd51d_ga10bb88ae2040e01eb7a08a037c2cd51d}{C\+O\+R\+E\+\_\+cgemm} (P\+L\+A\+S\+M\+A\+\_\+enum trans\+A, int trans\+B, int M, int N, int K, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t beta, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C, int L\+D\+C)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gaecf8f929b57ddf41ba49204e81db3ea6_gaecf8f929b57ddf41ba49204e81db3ea6}{C\+O\+R\+E\+\_\+cgemv} (P\+L\+A\+S\+M\+A\+\_\+enum trans, int m, int n, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$x, int incx, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t beta, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$y, int incy)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga078a367f5193d1dbb57a56de28c92cf8_ga078a367f5193d1dbb57a56de28c92cf8}{C\+O\+R\+E\+\_\+cgeqp3\+\_\+init} (int n, int $\ast$jpvt)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gabd3f038fac37e3870e0492050d3d480c_gabd3f038fac37e3870e0492050d3d480c}{C\+O\+R\+E\+\_\+cgeqp3\+\_\+larfg} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} A, int ii, int jj, int i, int j, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$tau, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$beta)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga2cce56de512a1ccc0ff1910b51ac0f4a_ga2cce56de512a1ccc0ff1910b51ac0f4a}{C\+O\+R\+E\+\_\+cgeqp3\+\_\+norms} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} A, int ioff, int joff, float $\ast$norms1, float $\ast$norms2)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga83a00af6767c0c8a18023c49a43bcf2e_ga83a00af6767c0c8a18023c49a43bcf2e}{C\+O\+R\+E\+\_\+cgeqp3\+\_\+pivot} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$F, int ldf, int jj, int k, int $\ast$jpvt, float $\ast$norms1, float $\ast$norms2, int $\ast$info)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gaa07b6c2a4351ee3bd306eef649b941ec_gaa07b6c2a4351ee3bd306eef649b941ec}{C\+O\+R\+E\+\_\+cgeqp3\+\_\+update} (const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$Ajj, int lda1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$Ajk, int lda2, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$Fk, int ldf, int joff, int k, int koff, int nb, float $\ast$norms1, float $\ast$norms2, int $\ast$info)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gaf5772c310721f743a07d003e0b9b693e_gaf5772c310721f743a07d003e0b9b693e}{C\+O\+R\+E\+\_\+cgeqrt} (int M, int N, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga4231da0e918e1dff4a6d270768e4d4dd_ga4231da0e918e1dff4a6d270768e4d4dd}{C\+O\+R\+E\+\_\+cgessm} (int M, int N, int K, int I\+B, const int $\ast$I\+P\+I\+V, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$L, int L\+D\+L, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga30476f667dedd4e77048b05c5f99a194_ga30476f667dedd4e77048b05c5f99a194}{C\+O\+R\+E\+\_\+cgetf2\+\_\+nopiv} (int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga1422c76f05c86e514fe638818a170e5f_ga1422c76f05c86e514fe638818a170e5f}{C\+O\+R\+E\+\_\+cgetrf} (int m, int n, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda, int $\ast$I\+P\+I\+V, int $\ast$info)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gafc300bd10ce70d8d864ce0408cc9cd6b_gafc300bd10ce70d8d864ce0408cc9cd6b}{C\+O\+R\+E\+\_\+cgetrf\+\_\+incpiv} (int M, int N, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, int $\ast$I\+P\+I\+V, int $\ast$I\+N\+F\+O)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gabd3a609b34e1e5cab320c21cfe5af6ca_gabd3a609b34e1e5cab320c21cfe5af6ca}{C\+O\+R\+E\+\_\+cgetrf\+\_\+nopiv} (int M, int N, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gaafeafd6a5addac900db7b17527269a6f_gaafeafd6a5addac900db7b17527269a6f}{C\+O\+R\+E\+\_\+cgetrf\+\_\+reclap} (\hyperlink{structCORE__cgetrf__data__s}{C\+O\+R\+E\+\_\+cgetrf\+\_\+data\+\_\+t} $\ast$data, int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, int $\ast$I\+P\+I\+V, int $\ast$info)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gad10a4a025b034860079a83bc8bc38fc6_gad10a4a025b034860079a83bc8bc38fc6}{C\+O\+R\+E\+\_\+cgetrf\+\_\+rectil} (\hyperlink{structCORE__cgetrf__data__s}{C\+O\+R\+E\+\_\+cgetrf\+\_\+data\+\_\+t} $\ast$data, const \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} A, int $\ast$I\+P\+I\+V, int $\ast$info)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga8f8e15898639c37e4d8a610b10b09e83_ga8f8e15898639c37e4d8a610b10b09e83}{C\+O\+R\+E\+\_\+cgetrip} (int m, int n, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga55e6336dbd46f22a9ec012165ab55b70_ga55e6336dbd46f22a9ec012165ab55b70}{C\+O\+R\+E\+\_\+chbelr} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga83bf49223a637604d5b4b9ffc7120f13_ga83bf49223a637604d5b4b9ffc7120f13}{C\+O\+R\+E\+\_\+chblrx} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga85fc5cd8419341c876020854b1771e78_ga85fc5cd8419341c876020854b1771e78}{C\+O\+R\+E\+\_\+chbrce} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga2f61003fd93e0ff61b4b597024d416dd_ga2f61003fd93e0ff61b4b597024d416dd}{C\+O\+R\+E\+\_\+chbtype1cb} (int N, int N\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gae459501c5248141724d3e9b6228a9aa7_gae459501c5248141724d3e9b6228a9aa7}{C\+O\+R\+E\+\_\+chbtype2cb} (int N, int N\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gaaf01a014d45410ea53191965c7a4c3a2_gaaf01a014d45410ea53191965c7a4c3a2}{C\+O\+R\+E\+\_\+chbtype3cb} (int N, int N\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga1624c78b2bb1eea77e119ff81558ff58_ga1624c78b2bb1eea77e119ff81558ff58}{C\+O\+R\+E\+\_\+chegst} (int itype, P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B, int $\ast$I\+N\+F\+O)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga039e9f2a9f753f52023537c054acb94a_ga039e9f2a9f753f52023537c054acb94a}{C\+O\+R\+E\+\_\+chemm} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t beta, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C, int L\+D\+C)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gac07e5bbc36930e45e02c0d2754dff3be_gac07e5bbc36930e45e02c0d2754dff3be}{C\+O\+R\+E\+\_\+cher2k} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans, int N, int K, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B, float beta, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C, int L\+D\+C)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga0930505da4c6917a906a80ff5211b5bf_ga0930505da4c6917a906a80ff5211b5bf}{C\+O\+R\+E\+\_\+cherfb} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int n, int k, int ib, int nb, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int ldt, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C, int ldc, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int ldwork)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gad3085a22b09fa5edc9d7536a58f3d15d_gad3085a22b09fa5edc9d7536a58f3d15d}{C\+O\+R\+E\+\_\+cherk} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans, int N, int K, float alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, float beta, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C, int L\+D\+C)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga96f9b085ef950e7cfbaf7c67af7472e7_ga96f9b085ef950e7cfbaf7c67af7472e7}{C\+O\+R\+E\+\_\+clacpy} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga197b7315c867d0779712120031ef001e_ga197b7315c867d0779712120031ef001e}{C\+O\+R\+E\+\_\+clacpy\+\_\+pivot} (const \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} desc\+A, P\+L\+A\+S\+M\+A\+\_\+enum direct, int k1, int k2, const int $\ast$ipiv, int $\ast$rankin, int $\ast$rankout, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda, int init)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga5304daa31c9f8f01320e77825915b9c0_ga5304daa31c9f8f01320e77825915b9c0}{C\+O\+R\+E\+\_\+clange} (int norm, int M, int N, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, float $\ast$work, float $\ast$norm\+A)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga9134237dcc37399ecb3cb87501d702f4_ga9134237dcc37399ecb3cb87501d702f4}{C\+O\+R\+E\+\_\+clanhe} (int norm, P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, float $\ast$work, float $\ast$norm\+A)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga307d845e3a58beda1391f4d51c329288_ga307d845e3a58beda1391f4d51c329288}{C\+O\+R\+E\+\_\+clansy} (int norm, P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, float $\ast$work, float $\ast$norm\+A)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga8af274e76af862faf884629524a4daed_ga8af274e76af862faf884629524a4daed}{C\+O\+R\+E\+\_\+clantr} (P\+L\+A\+S\+M\+A\+\_\+enum norm, P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum diag, int M, int N, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, float $\ast$work, float $\ast$norm\+A)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga76bff5de536b4c4a64ac3c95d15ea98e_ga76bff5de536b4c4a64ac3c95d15ea98e}{C\+O\+R\+E\+\_\+clarfb\+\_\+gemm} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int direct, int storev, int M, int N, int K, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, int L\+D\+V, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C, int L\+D\+C, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga6ab3da186625191c12ddfd0e27aca922_ga6ab3da186625191c12ddfd0e27aca922}{C\+O\+R\+E\+\_\+clarfx2} (P\+L\+A\+S\+M\+A\+\_\+enum side, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t T\+A\+U, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C1, int L\+D\+C1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C2, int L\+D\+C2)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gafd84d279fa45c7435bef96cca4128ebf_gafd84d279fa45c7435bef96cca4128ebf}{C\+O\+R\+E\+\_\+clarfx2c} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t T\+A\+U, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C2, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C3)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga27560b614aacabb021f8c902e4194ca5_ga27560b614aacabb021f8c902e4194ca5}{C\+O\+R\+E\+\_\+clarfx2ce} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C2, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C3)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga8eb544f55fe27c43c7c485ccafc46cd5_ga8eb544f55fe27c43c7c485ccafc46cd5}{C\+O\+R\+E\+\_\+clarfy} (int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga3087ef6316f2f1b9c096fbf5d8c5b545_ga3087ef6316f2f1b9c096fbf5d8c5b545}{C\+O\+R\+E\+\_\+clascal} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int m, int n, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga1a4f4c74119e6dc9f291f8d7719e5295_ga1a4f4c74119e6dc9f291f8d7719e5295}{C\+O\+R\+E\+\_\+clascl} (P\+L\+A\+S\+M\+A\+\_\+enum type, int kl, int ku, float cfrom, float cto, int m, int n, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga2e708440b68df39ec3772768cd78d79e_ga2e708440b68df39ec3772768cd78d79e}{C\+O\+R\+E\+\_\+claset} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t beta, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gac08e91310fd70351d27546eb488fbd81_gac08e91310fd70351d27546eb488fbd81}{C\+O\+R\+E\+\_\+claset2} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gae932091627c46b688b67aebcfb537573_gae932091627c46b688b67aebcfb537573}{C\+O\+R\+E\+\_\+claswp} (int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, int I1, int I2, const int $\ast$I\+P\+I\+V, int I\+N\+C)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga18336def276ef2189f9e51afc1976624_ga18336def276ef2189f9e51afc1976624}{C\+O\+R\+E\+\_\+claswp\+\_\+ontile} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} desc\+A, int i1, int i2, const int $\ast$ipiv, int inc)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gaf715646956e16c2ad05d66b58fc8ffad_gaf715646956e16c2ad05d66b58fc8ffad}{C\+O\+R\+E\+\_\+cswptr\+\_\+ontile} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} desc\+A, int i1, int i2, const int $\ast$ipiv, int inc, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$Akk, int ldak)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga50a473e33ed85bf4b07d1b9a441a9731_ga50a473e33ed85bf4b07d1b9a441a9731}{C\+O\+R\+E\+\_\+claswpc\+\_\+ontile} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} desc\+A, int i1, int i2, const int $\ast$ipiv, int inc)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gafe9ffac6e225949a3a0d13f084db12cb_gafe9ffac6e225949a3a0d13f084db12cb}{C\+O\+R\+E\+\_\+clatro} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M, int N, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga524ade90166bbf2514e1259685dc603e_ga524ade90166bbf2514e1259685dc603e}{C\+O\+R\+E\+\_\+clauum} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga1cba20dafe66a5e6fd0ba87604120002_ga1cba20dafe66a5e6fd0ba87604120002}{C\+O\+R\+E\+\_\+cpamm} (int op, P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum storev, int M, int N, int K, int L, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int L\+D\+A1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int L\+D\+A2, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, int L\+D\+V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W, int L\+D\+W)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga450824a3da3b8be57d1f1640cd975328_ga450824a3da3b8be57d1f1640cd975328}{C\+O\+R\+E\+\_\+cparfb} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, P\+L\+A\+S\+M\+A\+\_\+enum direct, P\+L\+A\+S\+M\+A\+\_\+enum storev, int M1, int N1, int M2, int N2, int K, int L, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int L\+D\+A1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int L\+D\+A2, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, int L\+D\+V, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga3b6583c1a567beb3f5245b86a78c6075_ga3b6583c1a567beb3f5245b86a78c6075}{C\+O\+R\+E\+\_\+cpemv} (P\+L\+A\+S\+M\+A\+\_\+enum trans, int storev, int M, int N, int L, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t A\+L\+P\+H\+A, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$X, int I\+N\+C\+X, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t B\+E\+T\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$Y, int I\+N\+C\+Y, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga7a8e1da6cc07180d0ff5fd4d01782121_ga7a8e1da6cc07180d0ff5fd4d01782121}{C\+O\+R\+E\+\_\+cplghe} (float bump, int m, int n, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda, int g\+M, int m0, int n0, unsigned long long int seed)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gae322390ce2e35aadcda2acacecd7cc9b_gae322390ce2e35aadcda2acacecd7cc9b}{C\+O\+R\+E\+\_\+cplgsy} (P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t bump, int m, int n, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda, int g\+M, int m0, int n0, unsigned long long int seed)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga7ae8308bfdf4f12a4b07edacf0b9b4a7_ga7ae8308bfdf4f12a4b07edacf0b9b4a7}{C\+O\+R\+E\+\_\+cplrnt} (int m, int n, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda, int g\+M, int m0, int n0, unsigned long long int seed)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga7fe65a820c911adce00227a128567766_ga7fe65a820c911adce00227a128567766}{C\+O\+R\+E\+\_\+cpltmg} (P\+L\+A\+S\+M\+A\+\_\+enum mtxtype, int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, int g\+M, int g\+N, int m0, int n0, unsigned long long int seed)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga9a7cfbd866be2bca2d26375bc6766d8a_ga9a7cfbd866be2bca2d26375bc6766d8a}{C\+O\+R\+E\+\_\+cpltmg\+\_\+chebvand} (int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, int g\+N, int m0, int n0, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga90d60bf2517ad64e6d1bf64254ac929d_ga90d60bf2517ad64e6d1bf64254ac929d}{C\+O\+R\+E\+\_\+cpltmg\+\_\+circul} (int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, int g\+M, int m0, int n0, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gad81007d6e27dcb18279f6fd52b823157_gad81007d6e27dcb18279f6fd52b823157}{C\+O\+R\+E\+\_\+cpltmg\+\_\+condexq} (int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$Q, int L\+D\+Q)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gab1b369f8dae16a9ad1a6479f7566d0a6_gab1b369f8dae16a9ad1a6479f7566d0a6}{C\+O\+R\+E\+\_\+cpltmg\+\_\+fiedler} (int M, int N, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$X, int inc\+X, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$Y, int inc\+Y, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga29113f4eaa98eeaa73019e2bef97b589_ga29113f4eaa98eeaa73019e2bef97b589}{C\+O\+R\+E\+\_\+cpltmg\+\_\+hankel} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, int m0, int n0, int nb, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V1, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V2)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga9c06098441579548f5ca4c3a2a60f376_ga9c06098441579548f5ca4c3a2a60f376}{C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd1} (int g\+M, int m0, int M, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W, unsigned long long int seed)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga838d82deafcbbf70e56b5464ee0e7538_ga838d82deafcbbf70e56b5464ee0e7538}{C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd2} (int M, int N, int K, int m0, int n0, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga8f8839fe52398eb2b469caff40cdacd5_ga8f8839fe52398eb2b469caff40cdacd5}{C\+O\+R\+E\+\_\+cpotrf} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, int $\ast$info)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga5a4ce35ecc9ab293e9ac2e87e014600e_ga5a4ce35ecc9ab293e9ac2e87e014600e}{C\+O\+R\+E\+\_\+csetvar} (const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$alpha, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$x)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gab0a0a5546fe5684fd80361eda2783551_gab0a0a5546fe5684fd80361eda2783551}{C\+O\+R\+E\+\_\+cshiftw} (int s, int cl, int m, int n, int L, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gacbcf50ddacade063d4e4dd5051cfec30_gacbcf50ddacade063d4e4dd5051cfec30}{C\+O\+R\+E\+\_\+cssssm} (int M1, int N1, int M2, int N2, int K, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int L\+D\+A1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int L\+D\+A2, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$L1, int L\+D\+L1, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$L2, int L\+D\+L2, const int $\ast$I\+P\+I\+V)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gade63ed2cd31cb0e5c0623391bcd78020_gade63ed2cd31cb0e5c0623391bcd78020}{C\+O\+R\+E\+\_\+cstedc} (P\+L\+A\+S\+M\+A\+\_\+enum compz, int n, float $\ast$D, float $\ast$E, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$Z, int L\+D\+Z, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int L\+W\+O\+R\+K, float $\ast$R\+W\+O\+R\+K, int L\+R\+W\+O\+R\+K, int $\ast$I\+W\+O\+R\+K, int L\+I\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gacc1980ec0484bb5269932a4f1c2bf7d1_gacc1980ec0484bb5269932a4f1c2bf7d1}{C\+O\+R\+E\+\_\+csteqr} (P\+L\+A\+S\+M\+A\+\_\+enum compz, int n, float $\ast$D, float $\ast$E, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$Z, int L\+D\+Z, float $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga5a34d585eb419bdfbad7618373628dee_ga5a34d585eb419bdfbad7618373628dee}{C\+O\+R\+E\+\_\+cswap} (int m, int n, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$Q, int ldq, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$work, const int $\ast$perm, int start, int end)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gaf6ebd36cbbb1b5fa7edb0499df48742d_gaf6ebd36cbbb1b5fa7edb0499df48742d}{C\+O\+R\+E\+\_\+cswpab} (int i, int n1, int n2, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$work)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga9ee60d99c109d72f762ee69bff8f9612_ga9ee60d99c109d72f762ee69bff8f9612}{C\+O\+R\+E\+\_\+csymm} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t beta, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C, int L\+D\+C)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga9e353ab4959d266c3d7dec7e8fe39f6b_ga9e353ab4959d266c3d7dec7e8fe39f6b}{C\+O\+R\+E\+\_\+csyr2k} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans, int N, int K, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t beta, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C, int L\+D\+C)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gab533c4d2ce945cd525c45a1de9f54a10_gab533c4d2ce945cd525c45a1de9f54a10}{C\+O\+R\+E\+\_\+csyrk} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans, int N, int K, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t beta, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C, int L\+D\+C)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga59754c7bb4987c113f48539326740534_ga59754c7bb4987c113f48539326740534}{C\+O\+R\+E\+\_\+ctradd} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t beta, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gada4c6647fe7897a5592b3697784313ec_gada4c6647fe7897a5592b3697784313ec}{C\+O\+R\+E\+\_\+ctrasm} (P\+L\+A\+S\+M\+A\+\_\+enum storev, P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum diag, int M, int N, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda, float $\ast$work)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga7f5683151b1259a07e742af5dfbb98c9_ga7f5683151b1259a07e742af5dfbb98c9}{C\+O\+R\+E\+\_\+ctrdalg1} (int n, int nb, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, int Vblksiz, int wantz, int i, int sweepid, int m, int grsiz, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$work)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gad637a07cdabd30cac217af0f1278c8a0_gad637a07cdabd30cac217af0f1278c8a0}{C\+O\+R\+E\+\_\+ctrmm} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans\+A, P\+L\+A\+S\+M\+A\+\_\+enum diag, int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga6b165f9de02dbc2a5f6524ca7ad9650d_ga6b165f9de02dbc2a5f6524ca7ad9650d}{C\+O\+R\+E\+\_\+ctrsm} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans\+A, P\+L\+A\+S\+M\+A\+\_\+enum diag, int M, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t alpha, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$B, int L\+D\+B)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_ga60551b5cf1ef39496b9c9b5ed721f332_ga60551b5cf1ef39496b9c9b5ed721f332}{C\+O\+R\+E\+\_\+ctrtri} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum diag, int N, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, int $\ast$info)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gad4dfa89c572aa817837b91416c9381c0_gad4dfa89c572aa817837b91416c9381c0}{C\+O\+R\+E\+\_\+ctslqt} (int M, int N, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int L\+D\+A1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int L\+D\+A2, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga5d276b7c438fe41e6e0e244ddd7b3edc_ga5d276b7c438fe41e6e0e244ddd7b3edc}{C\+O\+R\+E\+\_\+ctsmlq} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M1, int N1, int M2, int N2, int K, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int L\+D\+A1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int L\+D\+A2, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, int L\+D\+V, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga28e9737a152c45e8f38de6f7f26c251e_ga28e9737a152c45e8f38de6f7f26c251e}{C\+O\+R\+E\+\_\+ctsmlq\+\_\+corner} (int m1, int n1, int m2, int n2, int m3, int n3, int k, int ib, int nb, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int lda1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int lda2, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A3, int lda3, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, int ldv, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int ldt, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int ldwork)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gae4f109ffb197e06b188dc3a7cc697261_gae4f109ffb197e06b188dc3a7cc697261}{C\+O\+R\+E\+\_\+ctsmlq\+\_\+hetra1} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int m1, int n1, int m2, int n2, int k, int ib, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int lda1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int lda2, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, int ldv, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int ldt, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int ldwork)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gaafe02678a5ac0b0359bb2a14ccb831a7_gaafe02678a5ac0b0359bb2a14ccb831a7}{C\+O\+R\+E\+\_\+ctsmqr} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M1, int N1, int M2, int N2, int K, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int L\+D\+A1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int L\+D\+A2, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, int L\+D\+V, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gaec4d357be756fd805fbbf60b79cbc735_gaec4d357be756fd805fbbf60b79cbc735}{C\+O\+R\+E\+\_\+ctsmqr\+\_\+corner} (int m1, int n1, int m2, int n2, int m3, int n3, int k, int ib, int nb, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int lda1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int lda2, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A3, int lda3, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, int ldv, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int ldt, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int ldwork)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gaf062e7ba21ee418d0d9779dbf01c6390_gaf062e7ba21ee418d0d9779dbf01c6390}{C\+O\+R\+E\+\_\+ctsmqr\+\_\+hetra1} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int m1, int n1, int m2, int n2, int k, int ib, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int lda1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int lda2, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, int ldv, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int ldt, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int ldwork)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gaa0f009ac37aee2a788692cc46225a64a_gaa0f009ac37aee2a788692cc46225a64a}{C\+O\+R\+E\+\_\+ctsqrt} (int M, int N, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int L\+D\+A1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int L\+D\+A2, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gaec00749a149362afedaa0bab2d69fdfc_gaec00749a149362afedaa0bab2d69fdfc}{C\+O\+R\+E\+\_\+ctstrf} (int M, int N, int I\+B, int N\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$U, int L\+D\+U, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$L, int L\+D\+L, int $\ast$I\+P\+I\+V, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K, int $\ast$I\+N\+F\+O)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga3732acb715983d998575f8b077b0b979_ga3732acb715983d998575f8b077b0b979}{C\+O\+R\+E\+\_\+cttlqt} (int M, int N, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int L\+D\+A1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int L\+D\+A2, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga1a3b2d9dd959660e4d649a35c8b51c5e_ga1a3b2d9dd959660e4d649a35c8b51c5e}{C\+O\+R\+E\+\_\+cttmlq} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M1, int N1, int M2, int N2, int K, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int L\+D\+A1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int L\+D\+A2, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, int L\+D\+V, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga942a54bd176e5520d2605e607a0dd496_ga942a54bd176e5520d2605e607a0dd496}{C\+O\+R\+E\+\_\+cttmqr} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M1, int N1, int M2, int N2, int K, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int L\+D\+A1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int L\+D\+A2, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$V, int L\+D\+V, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gacdf604a4fa8379f693539966b7c3c3c6_gacdf604a4fa8379f693539966b7c3c3c6}{C\+O\+R\+E\+\_\+cttqrt} (int M, int N, int I\+B, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A1, int L\+D\+A1, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A2, int L\+D\+A2, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T\+A\+U, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga146c90c6b590a52e1c5a945b16364b3e_ga146c90c6b590a52e1c5a945b16364b3e}{C\+O\+R\+E\+\_\+cunmlq} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M, int N, int K, int I\+B, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C, int L\+D\+C, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_gaa733869e9c9d2b29204aaf799dfab70b_gaa733869e9c9d2b29204aaf799dfab70b}{C\+O\+R\+E\+\_\+cunmqr} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M, int N, int K, int I\+B, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int L\+D\+A, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$T, int L\+D\+T, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$C, int L\+D\+C, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__PLASMA__Complex32__t_gadc7bf683e0afadd77075b49c827cc016_gadc7bf683e0afadd77075b49c827cc016}{C\+O\+R\+E\+\_\+scasum} (P\+L\+A\+S\+M\+A\+\_\+enum storev, P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$A, int lda, float $\ast$work)
\item 
int \hyperlink{group__CORE__PLASMA__Complex32__t_ga2fb0a8db5844612734c55602fe3f38b1_ga2fb0a8db5844612734c55602fe3f38b1}{C\+O\+R\+E\+\_\+slag2c} (int m, int n, const float $\ast$R, int ldr, P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$Z, int ldz)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This is the group of single complex kernels available in coreblas library. 

\subsection{Function Documentation}
\hypertarget{group__CORE__PLASMA__Complex32__t_gacb63b22910fcb96ad757bad04d80bef4_gacb63b22910fcb96ad757bad04d80bef4}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cbrdalg1@{C\+O\+R\+E\+\_\+cbrdalg1}}
\index{C\+O\+R\+E\+\_\+cbrdalg1@{C\+O\+R\+E\+\_\+cbrdalg1}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cbrdalg1}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cbrdalg1 (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{n, }
\item[{int}]{nb, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V\+Q, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U\+Q, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V\+P, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U\+P, }
\item[{int}]{Vblksiz, }
\item[{int}]{wantz, }
\item[{int}]{i, }
\item[{int}]{sweepid, }
\item[{int}]{m, }
\item[{int}]{grsiz, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{work}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gacb63b22910fcb96ad757bad04d80bef4_gacb63b22910fcb96ad757bad04d80bef4}
C\+O\+R\+E\+\_\+cbrdalg1 is a part of the bidiagonal reduction algorithm (bulgechasing). It correspond to a local driver of the kernels that should be executed on a single core.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em n} & The order of the matrix A. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The size of the Bandwidth of the matrix A, which correspond to the tile size. nb $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (lda,n) On entry, the (2nb+1)-\/by-\/n lower or upper band general matrix to be reduced to bidiagonal. On exit, if uplo = Plasma\+Upper, the diagonal and first superdiagonal of A are overwritten by the corresponding elements of the bidiagonal matrix B. if uplo = Plasma\+Lower the diagonal and first subdiagonal of A are overwritten by the corresponding elements of the elements of the bidiagonal matrix B.\\
\hline
\mbox{\tt in}  & {\em lda} & (input) I\+N\+T\+E\+G\+E\+R The leading dimension of the array A. L\+D\+A $>$= max(1,nb+1).\\
\hline
\mbox{\tt out}  & {\em V\+Q} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (n) if wantz=0 or ldv$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar elementary left reflectors are written in this array.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+Q} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (n) if wantz=0 or Vblksiz$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar factors of the left elementary reflectors are written in this array.\\
\hline
\mbox{\tt in}  & {\em V\+P} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (n) if wantz=0 or ldv$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar elementary right reflectors are written in this array.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U\+P} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (n) if wantz=0 or Vblksiz$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar factors of the right elementary reflectors are written in this array.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & Local parameter to Plasma. It correspond to the local bloccking of the apply\+Q2 used to apply the orthogonal matrix Q2.\\
\hline
\mbox{\tt in}  & {\em wantz} & integer tobe 0 or 1. if wantz=0 the V and T\+A\+U are not stored on only they are kept for next step then overwritten.\\
\hline
\mbox{\tt in}  & {\em i} & Integer that refer to the current sweep. (outer loop).\\
\hline
\mbox{\tt in}  & {\em sweepid} & Integer that refer to the sweep to chase.(inner loop).\\
\hline
\mbox{\tt in}  & {\em m} & Integer that refer to a sweep step, to ensure order dependencies.\\
\hline
\mbox{\tt in}  & {\em grsiz} & Integer that refer to the size of a group. group mean the number of kernel that should be executed sequentially on the same core. group size is a trade-\/off between locality (cache reuse) and parallelism. a small group size increase parallelism while a large group size increase cache reuse.\\
\hline
\mbox{\tt in}  & {\em work} & Workspace of size nb. Used by the core\+\_\+cgbtype\mbox{[}123\mbox{]}cb. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga4946ac6b253acee9fc398bab035c7b92_ga4946ac6b253acee9fc398bab035c7b92}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgbelr@{C\+O\+R\+E\+\_\+cgbelr}}
\index{C\+O\+R\+E\+\_\+cgbelr@{C\+O\+R\+E\+\_\+cgbelr}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgbelr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgbelr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga4946ac6b253acee9fc398bab035c7b92_ga4946ac6b253acee9fc398bab035c7b92}
C\+O\+R\+E\+\_\+cgbelr is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel eliminate a column by an element-\/wise annihiliation, and for each annihiliation, it apply a left update, followed by an right update on the diagonal 2x2 element, where it create a new nnz, eliminate it and update V and T\+A\+U, then it continue until finishing the the whole column. When this is done, it take advantage that data are on cache and will apply the right on the remaining part of this region that has not been updated by the right yet. Note that the column to be eliminated is located at st-\/1.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga4415cbf61356f4e5a3291688d94e7913_ga4415cbf61356f4e5a3291688d94e7913}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgblrx@{C\+O\+R\+E\+\_\+cgblrx}}
\index{C\+O\+R\+E\+\_\+cgblrx@{C\+O\+R\+E\+\_\+cgblrx}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgblrx}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgblrx (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga4415cbf61356f4e5a3291688d94e7913_ga4415cbf61356f4e5a3291688d94e7913}
C\+O\+R\+E\+\_\+cgblrx is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a left update, followed by an right and for each annihiliation, it apply a left update, followed by an right update on the diagonal 2x2 element, where it create a new nnz, eliminate it and update V and T\+A\+U, then it continue until finishing the the whole column. When this is done, it take advantage that data are on cache and will apply the right on the remaining part of this region that has not been updated by the right yet.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga8d540e27bad6f137a7fe34d87a443098_ga8d540e27bad6f137a7fe34d87a443098}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgbrce@{C\+O\+R\+E\+\_\+cgbrce}}
\index{C\+O\+R\+E\+\_\+cgbrce@{C\+O\+R\+E\+\_\+cgbrce}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgbrce}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgbrce (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga8d540e27bad6f137a7fe34d87a443098_ga8d540e27bad6f137a7fe34d87a443098}
C\+O\+R\+E\+\_\+cgbrce is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a right update, create a new nnz, then it eliminate it, and move to the next right update, create a new nnz, eliminate it and so on until finishing. When this is done, it take advantage that data are on cache and will apply the left on the remaining part of this region that has not been updated by the left yet.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaeac8b9c395c5b6c4e00ceb7b5160ea08_gaeac8b9c395c5b6c4e00ceb7b5160ea08}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgbtype1cb@{C\+O\+R\+E\+\_\+cgbtype1cb}}
\index{C\+O\+R\+E\+\_\+cgbtype1cb@{C\+O\+R\+E\+\_\+cgbtype1cb}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgbtype1cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cgbtype1cb (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V\+Q, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U\+Q, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V\+P, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U\+P, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaeac8b9c395c5b6c4e00ceb7b5160ea08_gaeac8b9c395c5b6c4e00ceb7b5160ea08}
C\+O\+R\+E\+\_\+cgbtype1cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel eliminate a column by an column-\/wise annihiliation, then it apply a left+right update on the hermitian triangle. Note that the column to be eliminated is located at st-\/1.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (3$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,3$\ast$\+N\+B+1)\\
\hline
\mbox{\tt out}  & {\em V\+P} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+P} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt out}  & {\em V\+Q} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+Q} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gab49cc5835213ad5ef256ea8087c9f589_gab49cc5835213ad5ef256ea8087c9f589}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgbtype2cb@{C\+O\+R\+E\+\_\+cgbtype2cb}}
\index{C\+O\+R\+E\+\_\+cgbtype2cb@{C\+O\+R\+E\+\_\+cgbtype2cb}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgbtype2cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cgbtype2cb (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V\+Q, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U\+Q, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V\+P, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U\+P, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gab49cc5835213ad5ef256ea8087c9f589_gab49cc5835213ad5ef256ea8087c9f589}
C\+O\+R\+E\+\_\+cgbtype2cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply the right update remaining from the type1 and this later will create a bulge so it eliminate the first column of the created bulge and do the corresponding Left update.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (3$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,3$\ast$\+N\+B+1)\\
\hline
\mbox{\tt in,out}  & {\em V\+P} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in,out}  & {\em T\+A\+U\+P} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in,out}  & {\em V\+Q} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in,out}  & {\em T\+A\+U\+Q} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga5d3e35aade213d33733843e608fdda37_ga5d3e35aade213d33733843e608fdda37}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgbtype3cb@{C\+O\+R\+E\+\_\+cgbtype3cb}}
\index{C\+O\+R\+E\+\_\+cgbtype3cb@{C\+O\+R\+E\+\_\+cgbtype3cb}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgbtype3cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cgbtype3cb (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V\+Q, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U\+Q, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V\+P, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U\+P, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga5d3e35aade213d33733843e608fdda37_ga5d3e35aade213d33733843e608fdda37}
C\+O\+R\+E\+\_\+cgbtype3cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a left+right update on the hermitian triangle. Note that this kernel is very similar to type1 but does not do an elimination.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (3$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,3$\ast$\+N\+B+1)\\
\hline
\mbox{\tt in}  & {\em V\+P} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U\+P} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em V\+Q} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U\+Q} & T\+O\+D\+O\+: Check and fix doc P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga09e552315ef6f7d23be4dbfdc405b132_ga09e552315ef6f7d23be4dbfdc405b132}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgeadd@{C\+O\+R\+E\+\_\+cgeadd}}
\index{C\+O\+R\+E\+\_\+cgeadd@{C\+O\+R\+E\+\_\+cgeadd}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgeadd}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgeadd (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{beta, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga09e552315ef6f7d23be4dbfdc405b132_ga09e552315ef6f7d23be4dbfdc405b132}
C\+O\+R\+E\+\_\+cgeadd adds two matrices together as in P\+B\+L\+A\+S pcgeadd. \begin{DoxyVerb} B <- alpha * op(A)  + beta * B,
\end{DoxyVerb}


where op(\+X) = X, X\textquotesingle{}, or conjf(X\textquotesingle{})


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is non-\/transposed, transposed, or conjfugate transposed = Plasma\+No\+Trans\+: op(\+A) = A = Plasma\+Trans\+: op(\+A) = A\textquotesingle{} = Plasma\+Conj\+Trans\+: op(\+A) = conjf(A\textquotesingle{})\\
\hline
\mbox{\tt in}  & {\em M} & Number of rows of the matrices op(\+A) and B.\\
\hline
\mbox{\tt in}  & {\em N} & Number of columns of the matrices op(\+A) and B.\\
\hline
\mbox{\tt in}  & {\em alpha} & Scalar factor of A.\\
\hline
\mbox{\tt in}  & {\em A} & Matrix of size L\+D\+A-\/by-\/\+N, if trans = Plasma\+No\+Trans, L\+D\+A-\/by-\/\+M otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & Leading dimension of the array A. L\+D\+A $>$= max(1,k), with k=M, if trans = Plasma\+No\+Trans, and k=N otherwise.\\
\hline
\mbox{\tt in}  & {\em beta} & Scalar factor of B.\\
\hline
\mbox{\tt in,out}  & {\em B} & Matrix of size L\+D\+B-\/by-\/\+N. On exit, B = alpha $\ast$ op(\+A) + beta $\ast$ B\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & Leading dimension of the array B. L\+D\+B $>$= max(1,\+M)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga3882801d5cbff5f623def8ecd0632f4f_ga3882801d5cbff5f623def8ecd0632f4f}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgelqt@{C\+O\+R\+E\+\_\+cgelqt}}
\index{C\+O\+R\+E\+\_\+cgelqt@{C\+O\+R\+E\+\_\+cgelqt}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgelqt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgelqt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga3882801d5cbff5f623def8ecd0632f4f_ga3882801d5cbff5f623def8ecd0632f4f}
C\+O\+R\+E\+\_\+cgelqt -\/ computes a L\+Q factorization of a complex M-\/by-\/\+N tile A\+: A = L $\ast$ Q.

The tile Q is represented as a product of elementary reflectors

Q = H(k)\textquotesingle{} . . . H(2)\textquotesingle{} H(1)\textquotesingle{}, where k = min(\+M,\+N).

Each H(i) has the form

H(i) = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a complex scalar, and v is a complex vector with v(1\+:i-\/1) = 0 and v(i) = 1; conjfg(v(i+1\+:n)) is stored on exit in A(i,i+1\+:n), and tau in T\+A\+U(i).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile A. On exit, the elements on and below the diagonal of the array contain the M-\/by-\/min(M,N) lower trapezoidal tile L (L is lower triangular if M $<$= N); the elements above the diagonal, with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga10bb88ae2040e01eb7a08a037c2cd51d_ga10bb88ae2040e01eb7a08a037c2cd51d}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgemm@{C\+O\+R\+E\+\_\+cgemm}}
\index{C\+O\+R\+E\+\_\+cgemm@{C\+O\+R\+E\+\_\+cgemm}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgemm}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cgemm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans\+A, }
\item[{int}]{trans\+B, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{beta, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C, }
\item[{int}]{L\+D\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga10bb88ae2040e01eb7a08a037c2cd51d_ga10bb88ae2040e01eb7a08a037c2cd51d}
C\+O\+R\+E\+\_\+cgemm -\/ Performs one of the matrix-\/matrix operations

\[ C = \alpha [op( A )\times op( B )] + \beta C \],

where op( X ) is one of

op( X ) = X or op( X ) = X\textquotesingle{} or op( X ) = conjfg( X\textquotesingle{} )

alpha and beta are scalars, and A, B and C are matrices, with op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em trans\+A} & Specifies whether the matrix A is transposed, not transposed or conjfugate transposed\+: = Plasma\+No\+Trans\+: A is not transposed; = Plasma\+Trans\+: A is transposed; = Plasma\+Conj\+Trans\+: A is conjfugate transposed.\\
\hline
\mbox{\tt in}  & {\em trans\+B} & Specifies whether the matrix B is transposed, not transposed or conjfugate transposed\+: = Plasma\+No\+Trans\+: B is not transposed; = Plasma\+Trans\+: B is transposed; = Plasma\+Conj\+Trans\+: B is conjfugate transposed.\\
\hline
\mbox{\tt in}  & {\em M} & M specifies the number of rows of the matrix op( A ) and of the matrix C. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the number of columns of the matrix op( B ) and of the matrix C. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of columns of the matrix op( A ) and the number of rows of the matrix op( B ). K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha\\
\hline
\mbox{\tt in}  & {\em A} & A is a L\+D\+A-\/by-\/ka matrix, where ka is K when trans\+A = Plasma\+No\+Trans, and is M otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em B} & B is a L\+D\+B-\/by-\/kb matrix, where kb is N when trans\+B = Plasma\+No\+Trans, and is K otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+N).\\
\hline
\mbox{\tt in}  & {\em beta} & beta specifies the scalar beta\\
\hline
\mbox{\tt in,out}  & {\em C} & C is a L\+D\+C-\/by-\/\+N matrix. On exit, the array is overwritten by the M by N matrix ( alpha$\ast$op( A )$\ast$op( B ) + beta$\ast$\+C )\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaecf8f929b57ddf41ba49204e81db3ea6_gaecf8f929b57ddf41ba49204e81db3ea6}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgemv@{C\+O\+R\+E\+\_\+cgemv}}
\index{C\+O\+R\+E\+\_\+cgemv@{C\+O\+R\+E\+\_\+cgemv}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgemv}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cgemv (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{x, }
\item[{int}]{incx, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{beta, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{y, }
\item[{int}]{incy}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaecf8f929b57ddf41ba49204e81db3ea6_gaecf8f929b57ddf41ba49204e81db3ea6}
C\+O\+R\+E\+\_\+cgemv performs one of the matrix-\/vector operations

y \+:= alpha$\ast$\+A$\ast$x + beta$\ast$y, or y \+:= alpha$\ast$\+A$\ast$$\ast$\+T$\ast$x + beta$\ast$y, or y \+:= alpha$\ast$\+A$\ast$$\ast$\+H$\ast$x + beta$\ast$y,

where alpha and beta are scalars, x and y are vectors, and A is an m by n matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans\+: y \+:= alpha$\ast$\+A$\ast$x + beta$\ast$y \item Plasma\+Trans\+: y \+:= alpha$\ast$\+A$\ast$$\ast$\+T$\ast$x + beta$\ast$y \item Plasma\+Conj\+Trans\+: y \+:= alpha$\ast$\+A$\ast$$\ast$\+H$\ast$x + beta$\ast$y\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em m} & Number of rows of matrix A.\\
\hline
\mbox{\tt in}  & {\em n} & Number of columns of matrix A.\\
\hline
\mbox{\tt in}  & {\em alpha} & Scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & On entry, m by n matrix A. Dimension (lda,n).\\
\hline
\mbox{\tt in}  & {\em lda} & Leading dimension of array A. lda $>$= max(1,m).\\
\hline
\mbox{\tt in}  & {\em x} & On entry, vector x. If trans == Plasma\+No\+Trans, the n vector x has dimension 1 + (n-\/1)$\ast$abs(incx). Else, the m vector x has dimension 1 + (m-\/1)$\ast$abs(incx).\\
\hline
\mbox{\tt in}  & {\em incx} & Increment between elements of x. incx must not be zero.\\
\hline
\mbox{\tt in}  & {\em beta} & Scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em y} & On entry, vector y. On exit, y is overwritten by updated vector y. If trans == Plasma\+No\+Trans, the m vector y has dimension 1 + (m-\/1)$\ast$abs(incy). Else, the n vector y has dimension 1 + (n-\/1)$\ast$abs(incy).\\
\hline
\mbox{\tt in}  & {\em incy} & Increment between elements of y. incy must not be zero. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga078a367f5193d1dbb57a56de28c92cf8_ga078a367f5193d1dbb57a56de28c92cf8}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgeqp3\+\_\+init@{C\+O\+R\+E\+\_\+cgeqp3\+\_\+init}}
\index{C\+O\+R\+E\+\_\+cgeqp3\+\_\+init@{C\+O\+R\+E\+\_\+cgeqp3\+\_\+init}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgeqp3\+\_\+init}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cgeqp3\+\_\+init (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{int $\ast$}]{jpvt}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga078a367f5193d1dbb57a56de28c92cf8_ga078a367f5193d1dbb57a56de28c92cf8}
C\+O\+R\+E\+\_\+cgeqp3\+\_\+init initializes jpvt to \mbox{[}1, ..., n\mbox{]}. Uses 1-\/based indexing for Fortran compatability.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & Size of vector.\\
\hline
\mbox{\tt in,out}  & {\em jpvt} & Vector of size n. On exit, jpvt\mbox{[}i\mbox{]} = i+1. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gabd3f038fac37e3870e0492050d3d480c_gabd3f038fac37e3870e0492050d3d480c}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgeqp3\+\_\+larfg@{C\+O\+R\+E\+\_\+cgeqp3\+\_\+larfg}}
\index{C\+O\+R\+E\+\_\+cgeqp3\+\_\+larfg@{C\+O\+R\+E\+\_\+cgeqp3\+\_\+larfg}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgeqp3\+\_\+larfg}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cgeqp3\+\_\+larfg (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{A, }
\item[{int}]{ii, }
\item[{int}]{jj, }
\item[{int}]{i, }
\item[{int}]{j, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{tau, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{beta}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gabd3f038fac37e3870e0492050d3d480c_gabd3f038fac37e3870e0492050d3d480c}
C\+O\+R\+E\+\_\+cgeqp3\+\_\+larfg generates a Householder elementary reflector H, such that \begin{DoxyVerb}H**H * x = [ beta ]  and  H**H * H = I.
           [ 0    ]
\end{DoxyVerb}


where alpha and beta are scalars, with beta real, and x is an n element vector. H is reperested in the form \begin{DoxyVerb}H = I - tau * [ 1 ] * [ 1 v**H ],
              [ v ]
\end{DoxyVerb}


where tau is a scalar and v is an (n-\/1) element vector. If x\mbox{[}1\+:\mbox{]} = 0 and x\mbox{[}0\mbox{]} is real, then tau = 0 and H = I. Otherwise, 1 $<$= real(tau) $<$= 2 and abs(tau-\/1) $<$= 1.

Here, x = A\mbox{[} ii$\ast$mb + i \+: m, jj$\ast$nb + j \mbox{]}. That is, x is j-\/th column of the jj-\/th block-\/column of A, starting in the i-\/th row of the ii-\/th block-\/row of A, and going to the last row. Note that x spans multiple tiles of A.

This D\+I\+F\+F\+E\+R\+S from L\+A\+P\+A\+C\+K in that the 1.\+0 is stored explicitly in the top element of x and beta is stored separately. (Whereas in L\+A\+P\+A\+C\+K, the 1.\+0 is implicit and beta is stored in the top element of x.)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em A} & Description of m by n matrix A. On entry, A\mbox{[} ii$\ast$mb + i \+: m, jj$\ast$nb + j \mbox{]} is the vector x. On exit, A\mbox{[} ii$\ast$mb + i \+: m, jj$\ast$nb + j \mbox{]} is overwritten with \mbox{[} 1, v \mbox{]}.\\
\hline
\mbox{\tt in}  & {\em ii} & Index of block row of A to start in.\\
\hline
\mbox{\tt in}  & {\em jj} & Index of block column of A.\\
\hline
\mbox{\tt in}  & {\em i} & Index of row within ii-\/th block row to start in.\\
\hline
\mbox{\tt in}  & {\em j} & Index of column within jj-\/th block column.\\
\hline
\mbox{\tt out}  & {\em tau} & The scalar tau.\\
\hline
\mbox{\tt out}  & {\em beta} & The scalar beta. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga2cce56de512a1ccc0ff1910b51ac0f4a_ga2cce56de512a1ccc0ff1910b51ac0f4a}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgeqp3\+\_\+norms@{C\+O\+R\+E\+\_\+cgeqp3\+\_\+norms}}
\index{C\+O\+R\+E\+\_\+cgeqp3\+\_\+norms@{C\+O\+R\+E\+\_\+cgeqp3\+\_\+norms}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgeqp3\+\_\+norms}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cgeqp3\+\_\+norms (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{A, }
\item[{int}]{ioff, }
\item[{int}]{joff, }
\item[{float $\ast$}]{norms1, }
\item[{float $\ast$}]{norms2}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga2cce56de512a1ccc0ff1910b51ac0f4a_ga2cce56de512a1ccc0ff1910b51ac0f4a}
C\+O\+R\+E\+\_\+cgeqp3\+\_\+norms computes the 2-\/norm of each column of A\mbox{[} ioff\+:m, joff\+:n \mbox{]} that is marked with norms2\mbox{[}j\mbox{]} == -\/1 on entry. Entries that are not marked are assumed to already contain the correct 2-\/norm, so that the same routine can be used for computing the initial norms and for updating bad norms. The result is stored duplicated in norms1 and norms2.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em A} & P\+L\+A\+S\+M\+A descriptor of the matrix A. On entry, the M-\/by-\/\+N matrix described by the descriptor.\\
\hline
\mbox{\tt in}  & {\em ioff} & Row offset.\\
\hline
\mbox{\tt in}  & {\em joff} & Column offset.\\
\hline
\mbox{\tt in,out}  & {\em norms1} & Vector of size A.\+n. On exit, norms1\mbox{[}j\mbox{]} is 2-\/norm of column j, for j $>$= joff.\\
\hline
\mbox{\tt in,out}  & {\em norms2} & Vector of size A.\+n. On entry, if norms2\mbox{[}j\mbox{]} == -\/1, re-\/compute norm of column j. On exit, norms2\mbox{[}j\mbox{]} is 2-\/norm of column j, for j $>$= joff. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga83a00af6767c0c8a18023c49a43bcf2e_ga83a00af6767c0c8a18023c49a43bcf2e}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgeqp3\+\_\+pivot@{C\+O\+R\+E\+\_\+cgeqp3\+\_\+pivot}}
\index{C\+O\+R\+E\+\_\+cgeqp3\+\_\+pivot@{C\+O\+R\+E\+\_\+cgeqp3\+\_\+pivot}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgeqp3\+\_\+pivot}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cgeqp3\+\_\+pivot (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{F, }
\item[{int}]{ldf, }
\item[{int}]{jj, }
\item[{int}]{k, }
\item[{int $\ast$}]{jpvt, }
\item[{float $\ast$}]{norms1, }
\item[{float $\ast$}]{norms2, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga83a00af6767c0c8a18023c49a43bcf2e_ga83a00af6767c0c8a18023c49a43bcf2e}
C\+O\+R\+E\+\_\+cgeqp3\+\_\+pivot finds next pivot, pvt, based on maximum column norm. It applies the swap to the matrices A, F, and vectors jpvt, norms1, norms2. If info != 0, it returns immediately, doing no work.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em A} & On entry, descriptor for m by n matrix A. On exit, column k of jj-\/th block column is swapped with column pvt.\\
\hline
\mbox{\tt in,out}  & {\em F} & On entry, n by nb matrix F. On exit, row k is swapped with row pvt -\/ jj$\ast$nb. Currently, F is stored column-\/wise, not tile-\/wise.\\
\hline
\mbox{\tt in}  & {\em ldf} & Leading dimension of F. ldf $>$= max(1,A.\+n).\\
\hline
\mbox{\tt in}  & {\em jj} & Index of current block column, 0 $<$= jj $<$ A.\+nt.\\
\hline
\mbox{\tt in}  & {\em k} & Index of current column within block column, 0 $<$= k $<$ A.\+nb.\\
\hline
\mbox{\tt in,out}  & {\em jpvt} & Permutation vector, dimension n. On exit, swaps entries jpvt\mbox{[}k+jj$\ast$nb\mbox{]} and jpvt\mbox{[}pvt\mbox{]}.\\
\hline
\mbox{\tt in,out}  & {\em norms1} & On entry, vector of partial column norms, dimension n. On exit, sets norms1\mbox{[}pvt\mbox{]} = norms1\mbox{[}k+jj$\ast$nb\mbox{]}.\\
\hline
\mbox{\tt in,out}  & {\em norms2} & On entry, vector of original column norms, dimension n. On exit, sets norms2\mbox{[}pvt\mbox{]} = norms2\mbox{[}k+jj$\ast$nb\mbox{]}.\\
\hline
\mbox{\tt in}  & {\em info} & Error code from cgeqp3\+\_\+update; zero if no error. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaa07b6c2a4351ee3bd306eef649b941ec_gaa07b6c2a4351ee3bd306eef649b941ec}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgeqp3\+\_\+update@{C\+O\+R\+E\+\_\+cgeqp3\+\_\+update}}
\index{C\+O\+R\+E\+\_\+cgeqp3\+\_\+update@{C\+O\+R\+E\+\_\+cgeqp3\+\_\+update}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgeqp3\+\_\+update}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cgeqp3\+\_\+update (
\begin{DoxyParamCaption}
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{Ajj, }
\item[{int}]{lda1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{Ajk, }
\item[{int}]{lda2, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{Fk, }
\item[{int}]{ldf, }
\item[{int}]{joff, }
\item[{int}]{k, }
\item[{int}]{koff, }
\item[{int}]{nb, }
\item[{float $\ast$}]{norms1, }
\item[{float $\ast$}]{norms2, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaa07b6c2a4351ee3bd306eef649b941ec_gaa07b6c2a4351ee3bd306eef649b941ec}
C\+O\+R\+E\+\_\+cgeqp3\+\_\+update updates row k of one tile of A and subtracts that row from the column norms.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em Ajj} & Diagonal tile (jj,jj) of A.\\
\hline
\mbox{\tt in}  & {\em lda1} & Leading dimension of Ajj.\\
\hline
\mbox{\tt in,out}  & {\em Ajk} & Tile (jj,kk) of A, kk $>$= jj. On exit, updates row joff+k (i.\+e., as if Q was applied to trailing matrix).\\
\hline
\mbox{\tt in}  & {\em lda2} & Leading dimension of Ajk.\\
\hline
\mbox{\tt in}  & {\em Fk} & Tile kk of F.\\
\hline
\mbox{\tt in}  & {\em ldf} & Leading dimension of Fk.\\
\hline
\mbox{\tt in}  & {\em joff} & Row offset.\\
\hline
\mbox{\tt in}  & {\em k} & Update row joff+k, based on having factored k columns. (That is, joff columns of this tile were factored in previous panels; k columns have been factored during this panel.)\\
\hline
\mbox{\tt in}  & {\em koff} & Column to start updating. For diagonal tile, koff=joff+k+1, else koff=0.\\
\hline
\mbox{\tt in}  & {\em nb} & Number of columns in kk-\/th block-\/column of A.\\
\hline
\mbox{\tt in,out}  & {\em norms1} & kk-\/th block of partial column norms vector, dimension nb. On exit, norms1\mbox{[}koff\+:nb\mbox{]} -\/= Ajk\mbox{[}k, koff\+:nb \mbox{]}.\\
\hline
\mbox{\tt in,out}  & {\em norms2} & kk-\/th block of original column norms vector, dimension nb. Unchanged on exit, except if cancellation is detected for some column j, sets norm2\mbox{[}j\mbox{]} = -\/1 and sets info = 1.\\
\hline
\mbox{\tt out}  & {\em info} & Set to true if numerical instability (cancellation) is detected in updating column norms. cgeqp3 handles this error. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaf5772c310721f743a07d003e0b9b693e_gaf5772c310721f743a07d003e0b9b693e}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgeqrt@{C\+O\+R\+E\+\_\+cgeqrt}}
\index{C\+O\+R\+E\+\_\+cgeqrt@{C\+O\+R\+E\+\_\+cgeqrt}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgeqrt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgeqrt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaf5772c310721f743a07d003e0b9b693e_gaf5772c310721f743a07d003e0b9b693e}
C\+O\+R\+E\+\_\+cgeqrt computes a Q\+R factorization of a complex M-\/by-\/\+N tile A\+: A = Q $\ast$ R.

The tile Q is represented as a product of elementary reflectors

Q = H(1) H(2) . . . H(k), where k = min(\+M,\+N).

Each H(i) has the form

H(i) = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a complex scalar, and v is a complex vector with v(1\+:i-\/1) = 0 and v(i) = 1; v(i+1\+:m) is stored on exit in A(i+1\+:m,i), and tau in T\+A\+U(i).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile A. On exit, the elements on and above the diagonal of the array contain the min(\+M,\+N)-\/by-\/\+N upper trapezoidal tile R (R is upper triangular if M $>$= N); the elements below the diagonal, with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga4231da0e918e1dff4a6d270768e4d4dd_ga4231da0e918e1dff4a6d270768e4d4dd}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgessm@{C\+O\+R\+E\+\_\+cgessm}}
\index{C\+O\+R\+E\+\_\+cgessm@{C\+O\+R\+E\+\_\+cgessm}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgessm}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgessm (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{const int $\ast$}]{I\+P\+I\+V, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{L, }
\item[{int}]{L\+D\+L, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga4231da0e918e1dff4a6d270768e4d4dd_ga4231da0e918e1dff4a6d270768e4d4dd}
C\+O\+R\+E\+\_\+cgessm applies the factors L computed by C\+O\+R\+E\+\_\+cgetrf\+\_\+incpiv to a complex M-\/by-\/\+N tile A.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of columns of the tile L. K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+P\+I\+V} & The pivot indices array of size K as returned by C\+O\+R\+E\+\_\+cgetrf\+\_\+incpiv.\\
\hline
\mbox{\tt in}  & {\em L} & The M-\/by-\/\+K lower triangular tile.\\
\hline
\mbox{\tt in}  & {\em L\+D\+L} & The leading dimension of the array L. L\+D\+L $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile A. On exit, updated by the application of L.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga30476f667dedd4e77048b05c5f99a194_ga30476f667dedd4e77048b05c5f99a194}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgetf2\+\_\+nopiv@{C\+O\+R\+E\+\_\+cgetf2\+\_\+nopiv}}
\index{C\+O\+R\+E\+\_\+cgetf2\+\_\+nopiv@{C\+O\+R\+E\+\_\+cgetf2\+\_\+nopiv}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgetf2\+\_\+nopiv}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgetf2\+\_\+nopiv (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga30476f667dedd4e77048b05c5f99a194_ga30476f667dedd4e77048b05c5f99a194}
C\+O\+R\+E\+\_\+cgetf2\+\_\+nopiv computes an L\+U factorization of a general diagonal dominant M-\/by-\/\+N matrix A witout no pivoting and no blocking. It is the internal function called by \hyperlink{group__CORE__PLASMA__Complex32__t_gabd3a609b34e1e5cab320c21cfe5af6ca_gabd3a609b34e1e5cab320c21cfe5af6ca}{C\+O\+R\+E\+\_\+cgetrf\+\_\+nopiv()}.

The factorization has the form A = L $\ast$ U where L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n).

This is the right-\/looking Level 3 B\+L\+A\+S version of the algorithm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N matrix to be factored. On exit, the factors L and U from the factorization A = P$\ast$\+L$\ast$\+U; the unit diagonal elements of L are not stored.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
{\em $>$0} & if I\+N\+F\+O = k, U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga1422c76f05c86e514fe638818a170e5f_ga1422c76f05c86e514fe638818a170e5f}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgetrf@{C\+O\+R\+E\+\_\+cgetrf}}
\index{C\+O\+R\+E\+\_\+cgetrf@{C\+O\+R\+E\+\_\+cgetrf}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgetrf}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgetrf (
\begin{DoxyParamCaption}
\item[{int}]{m, }
\item[{int}]{n, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda, }
\item[{int $\ast$}]{I\+P\+I\+V, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga1422c76f05c86e514fe638818a170e5f_ga1422c76f05c86e514fe638818a170e5f}
C\+O\+R\+E\+\_\+cgetrf -\/ Computes an L\+U factorization of a general M-\/by-\/\+N matrix A using the tile L\+U algorithm with partial tile pivoting with row interchanges.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & The number of rows of the matrix A. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the matrix A. n $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N matrix to be factored. On exit, the tile factors L and U from the factorization.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em I\+P\+I\+V} & The pivot indices that define the permutations.\\
\hline
\mbox{\tt out}  & {\em info} & 
\begin{DoxyItemize}
\item 0 on successful exit
\item $<$0 if -\/i, the i-\/th argument had an illegal value
\item $>$0 if i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gafc300bd10ce70d8d864ce0408cc9cd6b_gafc300bd10ce70d8d864ce0408cc9cd6b}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgetrf\+\_\+incpiv@{C\+O\+R\+E\+\_\+cgetrf\+\_\+incpiv}}
\index{C\+O\+R\+E\+\_\+cgetrf\+\_\+incpiv@{C\+O\+R\+E\+\_\+cgetrf\+\_\+incpiv}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgetrf\+\_\+incpiv}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgetrf\+\_\+incpiv (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int $\ast$}]{I\+P\+I\+V, }
\item[{int $\ast$}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gafc300bd10ce70d8d864ce0408cc9cd6b_gafc300bd10ce70d8d864ce0408cc9cd6b}
C\+O\+R\+E\+\_\+cgetrf\+\_\+incpiv computes an L\+U factorization of a general M-\/by-\/\+N tile A using partial pivoting with row interchanges.

The factorization has the form

A = P $\ast$ L $\ast$ U

where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n).

This is the right-\/looking Level 2.\+5 B\+L\+A\+S version of the algorithm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be factored. On exit, the factors L and U from the factorization A = P$\ast$\+L$\ast$\+U; the unit diagonal elements of L are not stored.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em I\+P\+I\+V} & The pivot indices; for 1 $<$= i $<$= min(\+M,\+N), row i of the tile was interchanged with row I\+P\+I\+V(i).\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & See returned value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
{\em $>$0} & if I\+N\+F\+O = k, U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gabd3a609b34e1e5cab320c21cfe5af6ca_gabd3a609b34e1e5cab320c21cfe5af6ca}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgetrf\+\_\+nopiv@{C\+O\+R\+E\+\_\+cgetrf\+\_\+nopiv}}
\index{C\+O\+R\+E\+\_\+cgetrf\+\_\+nopiv@{C\+O\+R\+E\+\_\+cgetrf\+\_\+nopiv}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgetrf\+\_\+nopiv}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgetrf\+\_\+nopiv (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gabd3a609b34e1e5cab320c21cfe5af6ca_gabd3a609b34e1e5cab320c21cfe5af6ca}
C\+O\+R\+E\+\_\+cgetrf\+\_\+nopiv computes an L\+U factorization of a general diagonal dominant M-\/by-\/\+N matrix A witout pivoting.

The factorization has the form A = L $\ast$ U where L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n).

This is the right-\/looking Level 3 B\+L\+A\+S version of the algorithm. W\+A\+R\+N\+I\+N\+G\+: Your matrix need to be diagonal dominant if you want to call this routine safely.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The block size to switch between blocked and unblocked code.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N matrix to be factored. On exit, the factors L and U from the factorization A = P$\ast$\+L$\ast$\+U; the unit diagonal elements of L are not stored.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
{\em $>$0} & if I\+N\+F\+O = k, U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaafeafd6a5addac900db7b17527269a6f_gaafeafd6a5addac900db7b17527269a6f}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgetrf\+\_\+reclap@{C\+O\+R\+E\+\_\+cgetrf\+\_\+reclap}}
\index{C\+O\+R\+E\+\_\+cgetrf\+\_\+reclap@{C\+O\+R\+E\+\_\+cgetrf\+\_\+reclap}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgetrf\+\_\+reclap}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgetrf\+\_\+reclap (
\begin{DoxyParamCaption}
\item[{{\bf C\+O\+R\+E\+\_\+cgetrf\+\_\+data\+\_\+t} $\ast$}]{data, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int $\ast$}]{I\+P\+I\+V, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaafeafd6a5addac900db7b17527269a6f_gaafeafd6a5addac900db7b17527269a6f}
C\+O\+R\+E\+\_\+cgetrf\+\_\+reclap computes a L\+U factorization of a general M-\/by-\/\+N matrix A stored in C\+C\+R\+B layout using partial pivoting with row interchanges.

The factorization has the form

A = P $\ast$ L $\ast$ U

where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n).

This is the recursive version of the algorithm applied on column major layout.

W\+A\+R\+N\+I\+N\+G\+S\+:
\begin{DoxyItemize}
\item The function C\+O\+R\+E\+\_\+cgetrf\+\_\+reclap\+\_\+init has to be called prior to any call to this function.
\item You cannot call this kernel on different matrices at the same time.
\item The matrix A cannot be more than one tile wide.
\item The number of threads calling this function has to be excatly the number defined by info\mbox{[}2\mbox{]} with each one of them a different index between 0 included and info\mbox{[}2\mbox{]} excluded.
\end{DoxyItemize}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em data} & Common data structure to all threads initialized by C\+O\+R\+E\+\_\+cgetrf\+\_\+reclap\+\_\+init() that contains information for thread synchronization and maximum reductions. All threads working on a given matrix A must provide the same data structure.\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N matrix to be factorized. On exit, the factors L and U from the factorization A = P$\ast$\+L$\ast$\+U; the unit diagonal elements of L are not stored.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em I\+P\+I\+V} & The pivot indices; for 1 $<$= i $<$= min(\+M,\+N), row i of the matrix was interchanged with row I\+P\+I\+V(i). 1 $<$= I\+P\+I\+V\mbox{[}i\mbox{]} $<$= M.\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of 3 integers
\begin{DoxyItemize}
\item info\mbox{[}0\mbox{]}, see returned value
\item info\mbox{[}1\mbox{]}, is the thread index 0 $<$= info\mbox{[}0\mbox{]} $<$ info\mbox{[}2\mbox{]}
\item info\mbox{[}2\mbox{]}, on entry is the number of threads trying to participate to the factorization, on exit is the real number of threads used to perform the factorization. Info\mbox{[}2\mbox{]} threads, and exactly info\mbox{[}2\mbox{]}, have to call this function to avoid dead lock.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em -\/k,the} & k-\/th argument had an illegal value \\
\hline
{\em k} & if U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gad10a4a025b034860079a83bc8bc38fc6_gad10a4a025b034860079a83bc8bc38fc6}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgetrf\+\_\+rectil@{C\+O\+R\+E\+\_\+cgetrf\+\_\+rectil}}
\index{C\+O\+R\+E\+\_\+cgetrf\+\_\+rectil@{C\+O\+R\+E\+\_\+cgetrf\+\_\+rectil}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgetrf\+\_\+rectil}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cgetrf\+\_\+rectil (
\begin{DoxyParamCaption}
\item[{{\bf C\+O\+R\+E\+\_\+cgetrf\+\_\+data\+\_\+t} $\ast$}]{data, }
\item[{const {\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{A, }
\item[{int $\ast$}]{I\+P\+I\+V, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gad10a4a025b034860079a83bc8bc38fc6_gad10a4a025b034860079a83bc8bc38fc6}
C\+O\+R\+E\+\_\+cgetrf\+\_\+rectil computes a L\+U factorization of a general M-\/by-\/\+N matrix A stored in C\+C\+R\+B layout using partial pivoting with row interchanges.

The factorization has the form

A = P $\ast$ L $\ast$ U

where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n).

This is the recursive version of the algorithm applied on tile layout.

W\+A\+R\+N\+I\+N\+G\+S\+:
\begin{DoxyItemize}
\item The function C\+O\+R\+E\+\_\+cgetrf\+\_\+rectil\+\_\+init has to be called prior to any call to this function.
\item You cannot call this kernel on different matrices at the same time.
\item The matrix A cannot be more than one tile wide.
\item The number of threads calling this function has to be excatly the number defined by info\mbox{[}2\mbox{]} with each one of them a different index between 0 included and info\mbox{[}2\mbox{]} excluded.
\end{DoxyItemize}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em data} & Common data structure to all threads initialized by C\+O\+R\+E\+\_\+cgetrf\+\_\+rectil\+\_\+init() that contains information for thread synchronization and maximum reductions. All threads working on a given matrix A must provide the same data structure.\\
\hline
\mbox{\tt in,out}  & {\em A} & P\+L\+A\+S\+M\+A descriptor of the matrix A to be factorized. On entry, the M-\/by-\/\+N matrix to be factorized. On exit, the factors L and U from the factorization A = P$\ast$\+L$\ast$\+U; the unit diagonal elements of L are not stored.\\
\hline
\mbox{\tt out}  & {\em I\+P\+I\+V} & The pivot indices; for 0 $<$= i $<$ min(\+M,\+N) stored in Fortran mode (starting at 1), row i of the matrix was interchanged with row I\+P\+I\+V(i). On exit, each value I\+P\+I\+V\mbox{[}i\mbox{]} for 0 $<$= i $<$ min(\+M,\+N) is increased by A.\+i, which means A.\+i $<$ I\+P\+I\+V\mbox{[}i\mbox{]} $<$= A.\+i+\+M.\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of 3 integers.
\begin{DoxyItemize}
\item info\mbox{[}0\mbox{]}, see returned value
\item info\mbox{[}1\mbox{]}, is the thread index 0 $<$= info\mbox{[}0\mbox{]} $<$ info\mbox{[}2\mbox{]}
\item info\mbox{[}2\mbox{]}, on entry is the number of threads trying to participate to the factorization, on exit is the real number of threads used to perform the factorization. Info\mbox{[}2\mbox{]} threads, and exactly info\mbox{[}2\mbox{]}, have to call this function to avoid dead lock.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em -\/k,the} & k-\/th argument had an illegal value \\
\hline
{\em k} & if U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga8f8e15898639c37e4d8a610b10b09e83_ga8f8e15898639c37e4d8a610b10b09e83}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cgetrip@{C\+O\+R\+E\+\_\+cgetrip}}
\index{C\+O\+R\+E\+\_\+cgetrip@{C\+O\+R\+E\+\_\+cgetrip}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cgetrip}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cgetrip (
\begin{DoxyParamCaption}
\item[{int}]{m, }
\item[{int}]{n, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga8f8e15898639c37e4d8a610b10b09e83_ga8f8e15898639c37e4d8a610b10b09e83}




C\+O\+R\+E\+\_\+cgetrip transposes a m-\/by-\/n matrix in place using an extra workspace of size m-\/by-\/n. Note \+: For square tile, workspace is not used.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & Number of lines of tile A\\
\hline
\mbox{\tt in}  & {\em n} & Number of columns of tile A\\
\hline
\mbox{\tt in,out}  & {\em A} & Tile of size m-\/by-\/n On exit, A = trans(\+A)\\
\hline
\mbox{\tt out}  & {\em W} & Workspace of size n-\/by-\/m if n != m, N\+U\+L\+L otherwise. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga55e6336dbd46f22a9ec012165ab55b70_ga55e6336dbd46f22a9ec012165ab55b70}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+chbelr@{C\+O\+R\+E\+\_\+chbelr}}
\index{C\+O\+R\+E\+\_\+chbelr@{C\+O\+R\+E\+\_\+chbelr}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+chbelr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+chbelr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga55e6336dbd46f22a9ec012165ab55b70_ga55e6336dbd46f22a9ec012165ab55b70}
C\+O\+R\+E\+\_\+chbelr is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel eliminate a column by an element-\/wise annihiliation, and for each annihiliation, it apply a left update, followed by an right update on the diagonal 2x2 element, then it continue until finishing the the whole column. When this is done, it take advantage that data are on cache and will apply the right on the remaining part of this region that has not been updated by the right yet. Note that the column to be eliminated is located at st-\/1.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga83bf49223a637604d5b4b9ffc7120f13_ga83bf49223a637604d5b4b9ffc7120f13}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+chblrx@{C\+O\+R\+E\+\_\+chblrx}}
\index{C\+O\+R\+E\+\_\+chblrx@{C\+O\+R\+E\+\_\+chblrx}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+chblrx}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+chblrx (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga83bf49223a637604d5b4b9ffc7120f13_ga83bf49223a637604d5b4b9ffc7120f13}
C\+O\+R\+E\+\_\+chblrx is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a left update, followed by an right update on the diagonal 2x2 element, then it continue until finishing the the whole column. When this is done, it take advantage that data are on cache and will apply the right on the remaining part of this region that has not been updated by the right yet.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga85fc5cd8419341c876020854b1771e78_ga85fc5cd8419341c876020854b1771e78}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+chbrce@{C\+O\+R\+E\+\_\+chbrce}}
\index{C\+O\+R\+E\+\_\+chbrce@{C\+O\+R\+E\+\_\+chbrce}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+chbrce}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+chbrce (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga85fc5cd8419341c876020854b1771e78_ga85fc5cd8419341c876020854b1771e78}
C\+O\+R\+E\+\_\+chbrce is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a right update, create a new nnz, then it eliminate it, and move to the next right update, create a new nnz, eliminate it and so on until finishing. When this is done, it take advantage that data are on cache and will apply the left on the remaining part of this region that has not been updated by the left yet.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga2f61003fd93e0ff61b4b597024d416dd_ga2f61003fd93e0ff61b4b597024d416dd}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+chbtype1cb@{C\+O\+R\+E\+\_\+chbtype1cb}}
\index{C\+O\+R\+E\+\_\+chbtype1cb@{C\+O\+R\+E\+\_\+chbtype1cb}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+chbtype1cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+chbtype1cb (
\begin{DoxyParamCaption}
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga2f61003fd93e0ff61b4b597024d416dd_ga2f61003fd93e0ff61b4b597024d416dd}
C\+O\+R\+E\+\_\+chbtype1cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel eliminate a column by an column-\/wise annihiliation, then it apply a left+right update on the hermitian triangle. Note that the column to be eliminated is located at st-\/1.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (2$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,2$\ast$\+N\+B+1)\\
\hline
\mbox{\tt out}  & {\em V} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gae459501c5248141724d3e9b6228a9aa7_gae459501c5248141724d3e9b6228a9aa7}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+chbtype2cb@{C\+O\+R\+E\+\_\+chbtype2cb}}
\index{C\+O\+R\+E\+\_\+chbtype2cb@{C\+O\+R\+E\+\_\+chbtype2cb}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+chbtype2cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+chbtype2cb (
\begin{DoxyParamCaption}
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gae459501c5248141724d3e9b6228a9aa7_gae459501c5248141724d3e9b6228a9aa7}
C\+O\+R\+E\+\_\+chbtype2cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply the right update remaining from the type1 and this later will create a bulge so it eliminate the first column of the created bulge and do the corresponding Left update.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (2$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,2$\ast$\+N\+B+1)\\
\hline
\mbox{\tt in,out}  & {\em V} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in,out}  & {\em T\+A\+U} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaaf01a014d45410ea53191965c7a4c3a2_gaaf01a014d45410ea53191965c7a4c3a2}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+chbtype3cb@{C\+O\+R\+E\+\_\+chbtype3cb}}
\index{C\+O\+R\+E\+\_\+chbtype3cb@{C\+O\+R\+E\+\_\+chbtype3cb}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+chbtype3cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+chbtype3cb (
\begin{DoxyParamCaption}
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaaf01a014d45410ea53191965c7a4c3a2_gaaf01a014d45410ea53191965c7a4c3a2}
C\+O\+R\+E\+\_\+chbtype3cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a left+right update on the hermitian triangle. Note that this kernel is very similar to type1 but does not do an elimination.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (2$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,2$\ast$\+N\+B+1)\\
\hline
\mbox{\tt in}  & {\em V} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 3-\/\+B\+A\+N\+D Lower-\/columnwise-\/\+Householder \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga1624c78b2bb1eea77e119ff81558ff58_ga1624c78b2bb1eea77e119ff81558ff58}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+chegst@{C\+O\+R\+E\+\_\+chegst}}
\index{C\+O\+R\+E\+\_\+chegst@{C\+O\+R\+E\+\_\+chegst}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+chegst}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+chegst (
\begin{DoxyParamCaption}
\item[{int}]{itype, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B, }
\item[{int $\ast$}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga1624c78b2bb1eea77e119ff81558ff58_ga1624c78b2bb1eea77e119ff81558ff58}
C\+O\+R\+E\+\_\+chegst -\/ reduces a complex Hermitian-\/definite generalized eigenproblem to standard form. If Plasma\+Itype == 1, the problem is A$\ast$x = lambda$\ast$\+B$\ast$x, and A is overwritten by inv(\+U$\ast$$\ast$\+H)$\ast$\+A$\ast$inv(U) or inv(\+L)$\ast$\+A$\ast$inv(L$\ast$$\ast$\+H) If Plasma\+Itype == 2 or 3, the problem is A$\ast$\+B$\ast$x = lambda$\ast$x or B$\ast$\+A$\ast$x = lambda$\ast$x, and A is overwritten by U$\ast$\+A$\ast$\+U$\ast$$\ast$\+H or L$\ast$$\ast$\+H$\ast$\+A$\ast$\+L. B must have been previously factorized as U$\ast$$\ast$\+H$\ast$\+U or L$\ast$\+L$\ast$$\ast$\+H by C\+O\+R\+E\+\_\+cpotrf.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em itype} & Intended usage\+: = 1\+: A$\ast$x=(lambda)$\ast$\+B$\ast$x = 2\+: A$\ast$\+Bx=(lambda)$\ast$x = 3\+: B$\ast$\+A$\ast$x=(lambda)$\ast$x\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular\+: = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrices A and B. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the symmetric (or Hermitian) matrix A. If uplo = Plasma\+Upper, the leading N-\/by-\/\+N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If uplo = Plasma\+Lower, the leading N-\/by-\/\+N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, if return value == 0, the transformed matrix, stored in the same format as A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt in,out}  & {\em B} & On entry, the triangular factor from the Cholesky factorization of B, as returned by P\+L\+A\+S\+M\+A\+\_\+\+C\+P\+O\+T\+R\+F.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+N).\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & 
\begin{DoxyItemize}
\item 0 on successful exit
\item $<$0 if -\/i, the i-\/th argument had an illegal value 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga039e9f2a9f753f52023537c054acb94a_ga039e9f2a9f753f52023537c054acb94a}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+chemm@{C\+O\+R\+E\+\_\+chemm}}
\index{C\+O\+R\+E\+\_\+chemm@{C\+O\+R\+E\+\_\+chemm}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+chemm}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+chemm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{beta, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C, }
\item[{int}]{L\+D\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga039e9f2a9f753f52023537c054acb94a_ga039e9f2a9f753f52023537c054acb94a}
C\+O\+R\+E\+\_\+chemm -\/ Performs one of the matrix-\/matrix operations

\[ C = \alpha \times A \times B + \beta \times C \]

or

\[ C = \alpha \times B \times A + \beta \times C \]

where alpha and beta are scalars, A is an hermitian matrix and B and C are m by n matrices.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & Specifies whether the hermitian matrix A appears on the left or right in the operation as follows\+: = Plasma\+Left\+: \[ C = \alpha \times A \times B + \beta \times C \] = Plasma\+Right\+: \[ C = \alpha \times B \times A + \beta \times C \]\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the upper or lower triangular part of the hermitian matrix A is to be referenced as follows\+: = Plasma\+Lower\+: Only the lower triangular part of the hermitian matrix A is to be referenced. = Plasma\+Upper\+: Only the upper triangular part of the hermitian matrix A is to be referenced.\\
\hline
\mbox{\tt in}  & {\em M} & Specifies the number of rows of the matrix C. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & Specifies the number of columns of the matrix C. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & Specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is a L\+D\+A-\/by-\/ka matrix, where ka is M when side = Plasma\+Left, and is N otherwise. Only the uplo triangular part is referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,ka).\\
\hline
\mbox{\tt in}  & {\em B} & B is a L\+D\+B-\/by-\/\+N matrix, where the leading M-\/by-\/\+N part of the array B must contain the matrix B.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em beta} & Specifies the scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is a L\+D\+C-\/by-\/\+N matrix. On exit, the array is overwritten by the M by N updated matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gac07e5bbc36930e45e02c0d2754dff3be_gac07e5bbc36930e45e02c0d2754dff3be}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cher2k@{C\+O\+R\+E\+\_\+cher2k}}
\index{C\+O\+R\+E\+\_\+cher2k@{C\+O\+R\+E\+\_\+cher2k}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cher2k}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cher2k (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B, }
\item[{float}]{beta, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C, }
\item[{int}]{L\+D\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gac07e5bbc36930e45e02c0d2754dff3be_gac07e5bbc36930e45e02c0d2754dff3be}
C\+O\+R\+E\+\_\+cher2k -\/ Performs one of the hermitian rank 2k operations

\[ C = \alpha [ op( A ) \times conjfg( op( B )' )] + conjfg( \alpha ) [ op( B ) \times conjfg( op( A )' )] + \beta C \], or \[ C = \alpha [ conjfg( op( A )' ) \times op( B ) ] + conjfg( \alpha ) [ conjfg( op( B )' ) \times op( A ) ] + \beta C \],

where op( X ) is one of

op( X ) = X or op( X ) = conjfg( X\textquotesingle{} )

where alpha and beta are real scalars, C is an n-\/by-\/n symmetric matrix and A and B are an n-\/by-\/k matrices the first case and k-\/by-\/n matrices in the second case.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of C is stored; = Plasma\+Lower\+: Lower triangle of C is stored.\\
\hline
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is transposed or conjfugate transposed\+: = Plasma\+No\+Trans\+: \[ C = \alpha [ op( A ) \times conjfg( op( B )' )] + conjfg( \alpha ) [ op( B ) \times conjfg( op( A )' )] + \beta C \] = Plasma\+Conj\+Trans\+: \[ C = \alpha [ conjfg( op( A )' ) \times op( B ) ] + conjfg( \alpha ) [ conjfg( op( B )' ) \times op( A ) ] + \beta C \]\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the order of the matrix C. N must be at least zero.\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of columns of the A and B matrices with trans = Plasma\+No\+Trans. K specifies the number of rows of the A and B matrices with trans = Plasma\+Trans.\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is a L\+D\+A-\/by-\/ka matrix, where ka is K when trans = Plasma\+No\+Trans, and is N otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A must be at least max( 1, N ), otherwise L\+D\+A must be at least max( 1, K ).\\
\hline
\mbox{\tt in}  & {\em B} & B is a L\+D\+B-\/by-\/kb matrix, where kb is K when trans = Plasma\+No\+Trans, and is N otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B must be at least max( 1, N ), otherwise L\+D\+B must be at least max( 1, K ).\\
\hline
\mbox{\tt in}  & {\em beta} & beta specifies the scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is a L\+D\+C-\/by-\/\+N matrix. On exit, the array uplo part of the matrix is overwritten by the uplo part of the updated matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max( 1, N ). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga0930505da4c6917a906a80ff5211b5bf_ga0930505da4c6917a906a80ff5211b5bf}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cherfb@{C\+O\+R\+E\+\_\+cherfb}}
\index{C\+O\+R\+E\+\_\+cherfb@{C\+O\+R\+E\+\_\+cherfb}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cherfb}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cherfb (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{n, }
\item[{int}]{k, }
\item[{int}]{ib, }
\item[{int}]{nb, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{ldt, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C, }
\item[{int}]{ldc, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{ldwork}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga0930505da4c6917a906a80ff5211b5bf_ga0930505da4c6917a906a80ff5211b5bf}
C\+O\+R\+E\+\_\+cherfb overwrites the symmetric complex N-\/by-\/\+N tile C with

Q$\ast$$\ast$\+T$\ast$\+C$\ast$\+Q

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(1) H(2) . . . H(k)

as returned by C\+O\+R\+E\+\_\+cgeqrt. Only Plasma\+Lower supported!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower \+: the upper part of the symmetric matrix C is not referenced. \item Plasma\+Upper \+: the lower part of the symmetric matrix C is not referenced (not supported).\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em n} & The number of rows/columns of the tile C. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & The number of elementary reflectors whose product defines the matrix Q. K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em ib} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The blocking size. N\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & The i-\/th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+cgeqrt in the first k columns of its array argument A.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+K triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em ldt} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt in,out}  & {\em C} & On entry, the symmetric N-\/by-\/\+N tile C. On exit, C is overwritten by Q$\ast$$\ast$\+T$\ast$\+C$\ast$\+Q.\\
\hline
\mbox{\tt in}  & {\em ldc} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & On exit, if I\+N\+F\+O = 0, W\+O\+R\+K(1) returns the optimal L\+D\+W\+O\+R\+K.\\
\hline
\mbox{\tt in}  & {\em ldwork} & The dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+N);\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gad3085a22b09fa5edc9d7536a58f3d15d_gad3085a22b09fa5edc9d7536a58f3d15d}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cherk@{C\+O\+R\+E\+\_\+cherk}}
\index{C\+O\+R\+E\+\_\+cherk@{C\+O\+R\+E\+\_\+cherk}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cherk}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cherk (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{float}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{float}]{beta, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C, }
\item[{int}]{L\+D\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gad3085a22b09fa5edc9d7536a58f3d15d_gad3085a22b09fa5edc9d7536a58f3d15d}
C\+O\+R\+E\+\_\+cherk -\/ Performs one of the hermitian rank k operations

\[ C = \alpha [ op( A ) \times conjfg( op( A )' )] + \beta C \],

where op( X ) is one of

op( X ) = X or op( X ) = conjfg( X\textquotesingle{} )

where alpha and beta are real scalars, C is an n-\/by-\/n hermitian matrix and A is an n-\/by-\/k matrix in the first case and a k-\/by-\/n matrix in the second case.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of C is stored; = Plasma\+Lower\+: Lower triangle of C is stored.\\
\hline
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is transposed or conjfugate transposed\+: = Plasma\+No\+Trans\+: A is not transposed; = Plasma\+Conj\+Trans\+: A is conjfugate transposed.\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the order of the matrix C. N must be at least zero.\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of columns of the matrix op( A ).\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is a L\+D\+A-\/by-\/ka matrix, where ka is K when trans = Plasma\+No\+Trans, and is N otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A must be at least max( 1, N ) if trans == Plasma\+No\+Trans, otherwise L\+D\+A must be at least max( 1, K ).\\
\hline
\mbox{\tt in}  & {\em beta} & beta specifies the scalar beta\\
\hline
\mbox{\tt in,out}  & {\em C} & C is a L\+D\+C-\/by-\/\+N matrix. On exit, the array uplo part of the matrix is overwritten by the uplo part of the updated matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max( 1, N ). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga96f9b085ef950e7cfbaf7c67af7472e7_ga96f9b085ef950e7cfbaf7c67af7472e7}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clacpy@{C\+O\+R\+E\+\_\+clacpy}}
\index{C\+O\+R\+E\+\_\+clacpy@{C\+O\+R\+E\+\_\+clacpy}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clacpy}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+clacpy (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga96f9b085ef950e7cfbaf7c67af7472e7_ga96f9b085ef950e7cfbaf7c67af7472e7}
C\+O\+R\+E\+\_\+clacpy copies all or part of a two-\/dimensional matrix A to another matrix B


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies the part of the matrix A to be copied to B. = Plasma\+Upper\+Lower\+: All the matrix A = Plasma\+Upper\+: Upper triangular part = Plasma\+Lower\+: Lower triangular part\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrices A and B. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrices A and B. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & The M-\/by-\/\+N matrix to copy.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em B} & The M-\/by-\/\+N copy of the matrix A. On exit, B = A O\+N\+L\+Y in the locations specified by uplo.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga197b7315c867d0779712120031ef001e_ga197b7315c867d0779712120031ef001e}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clacpy\+\_\+pivot@{C\+O\+R\+E\+\_\+clacpy\+\_\+pivot}}
\index{C\+O\+R\+E\+\_\+clacpy\+\_\+pivot@{C\+O\+R\+E\+\_\+clacpy\+\_\+pivot}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clacpy\+\_\+pivot}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+clacpy\+\_\+pivot (
\begin{DoxyParamCaption}
\item[{const {\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{desc\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{direct, }
\item[{int}]{k1, }
\item[{int}]{k2, }
\item[{const int $\ast$}]{ipiv, }
\item[{int $\ast$}]{rankin, }
\item[{int $\ast$}]{rankout, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda, }
\item[{int}]{init}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga197b7315c867d0779712120031ef001e_ga197b7315c867d0779712120031ef001e}
C\+O\+R\+E\+\_\+clacpy\+\_\+pivot extracts the original version of the rows selected by the ipiv array and copies them into a new buffer.

This kernel is used by tournament pivoting algorithms, to extract the selected rows from the original matrix that will make it to the next level of the tournament.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em desc\+A} & The descriptor of the matrix A in which the kernel will extract the original rows.\\
\hline
\mbox{\tt in}  & {\em direct} & \begin{DoxyItemize}
\item Plasma\+Rowwise\+: The extracted rows are stored in column major layout. \item Plasma\+Columnwise\+: The extracted rows are store in row major layout.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em k1} & The first element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em k2} & The last element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em ipiv} & The pivot indices; Only the element in position k1 to k2 are accessed. The pivots should be included in the interval 1 to A.\+m\\
\hline
\mbox{\tt in,out}  & {\em rankin} & On entry, the global indices relative to the full matrix A factorized, in the local sub-\/matrix. If init == 1, rankin is initialized to A.\+i, .. A.\+i+desc\+A.m On exit, rows are permutted according to ipiv.\\
\hline
\mbox{\tt out}  & {\em rankout} & On exit, contains the global indices of the first (k2-\/k1+1) rows.\\
\hline
\mbox{\tt out}  & {\em A} & An lda-\/by-\/desc\+A.\+n matrix. On exit, A contains the original version of the rows selected by the pivoting process.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. lda $>$= max(1,(k2-\/k1+1)).\\
\hline
\mbox{\tt in}  & {\em init} & True if rankin needs to be initialized. False, if rankin contains already initialized data.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga5304daa31c9f8f01320e77825915b9c0_ga5304daa31c9f8f01320e77825915b9c0}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clange@{C\+O\+R\+E\+\_\+clange}}
\index{C\+O\+R\+E\+\_\+clange@{C\+O\+R\+E\+\_\+clange}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clange}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+clange (
\begin{DoxyParamCaption}
\item[{int}]{norm, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{float $\ast$}]{work, }
\item[{float $\ast$}]{norm\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga5304daa31c9f8f01320e77825915b9c0_ga5304daa31c9f8f01320e77825915b9c0}
C\+O\+R\+E\+\_\+clange returns the value

clange = ( max(abs(\+A(i,j))), N\+O\+R\+M = Plasma\+Max\+Norm ( ( norm1(\+A), N\+O\+R\+M = Plasma\+One\+Norm ( ( norm\+I(\+A), N\+O\+R\+M = Plasma\+Inf\+Norm ( ( norm\+F(\+A), N\+O\+R\+M = Plasma\+Frobenius\+Norm

where norm1 denotes the one norm of a matrix (maximum column sum), norm\+I denotes the infinity norm of a matrix (maximum row sum) and norm\+F denotes the Frobenius norm of a matrix (square root of sum of squares). Note that max(abs(\+A(i,j))) is not a consistent matrix norm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em norm} & = Plasma\+Max\+Norm\+: Max norm = Plasma\+One\+Norm\+: One norm = Plasma\+Inf\+Norm\+: Infinity norm = Plasma\+Frobenius\+Norm\+: Frobenius norm\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & The M-\/by-\/\+N matrix A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em work} & Array of dimension (M\+A\+X(1,\+L\+W\+O\+R\+K)), where L\+W\+O\+R\+K $>$= M when N\+O\+R\+M = Plasma\+Inf\+Norm; otherwise, W\+O\+R\+K is not referenced.\\
\hline
\mbox{\tt out}  & {\em norm\+A} & On exit, norm\+A is the norm of matrix A. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga9134237dcc37399ecb3cb87501d702f4_ga9134237dcc37399ecb3cb87501d702f4}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clanhe@{C\+O\+R\+E\+\_\+clanhe}}
\index{C\+O\+R\+E\+\_\+clanhe@{C\+O\+R\+E\+\_\+clanhe}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clanhe}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+clanhe (
\begin{DoxyParamCaption}
\item[{int}]{norm, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{float $\ast$}]{work, }
\item[{float $\ast$}]{norm\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga9134237dcc37399ecb3cb87501d702f4_ga9134237dcc37399ecb3cb87501d702f4}
C\+O\+R\+E\+\_\+clanhe returns the value

clanhe = ( max(abs(\+A(i,j))), N\+O\+R\+M = Plasma\+Max\+Norm ( ( norm1(\+A), N\+O\+R\+M = Plasma\+One\+Norm ( ( norm\+I(\+A), N\+O\+R\+M = Plasma\+Inf\+Norm ( ( norm\+F(\+A), N\+O\+R\+M = Plasma\+Frobenius\+Norm

where norm1 denotes the one norm of a matrix (maximum column sum), norm\+I denotes the infinity norm of a matrix (maximum row sum) and norm\+F denotes the Frobenius norm of a matrix (square root of sum of squares). Note that max(abs(\+A(i,j))) is not a consistent matrix norm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em norm} & = Plasma\+Max\+Norm\+: Max norm = Plasma\+One\+Norm\+: One norm = Plasma\+Inf\+Norm\+: Infinity norm = Plasma\+Frobenius\+Norm\+: Frobenius norm\\
\hline
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns/rows of the matrix A. N $>$= 0. When N = 0, the returned value is set to zero.\\
\hline
\mbox{\tt in}  & {\em A} & The N-\/by-\/\+N matrix A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt in,out}  & {\em work} & Array of dimension (M\+A\+X(1,\+L\+W\+O\+R\+K)), where L\+W\+O\+R\+K $>$= N when norm = Plasma\+Inf\+Norm or Plasma\+One\+Norm; otherwise, work is not referenced.\\
\hline
\mbox{\tt out}  & {\em norm\+A} & On exit, norm\+A is the norm of matrix A. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga307d845e3a58beda1391f4d51c329288_ga307d845e3a58beda1391f4d51c329288}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clansy@{C\+O\+R\+E\+\_\+clansy}}
\index{C\+O\+R\+E\+\_\+clansy@{C\+O\+R\+E\+\_\+clansy}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clansy}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+clansy (
\begin{DoxyParamCaption}
\item[{int}]{norm, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{float $\ast$}]{work, }
\item[{float $\ast$}]{norm\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga307d845e3a58beda1391f4d51c329288_ga307d845e3a58beda1391f4d51c329288}
C\+O\+R\+E\+\_\+clansy returns the value

clansy = ( max(abs(\+A(i,j))), N\+O\+R\+M = Plasma\+Max\+Norm ( ( norm1(\+A), N\+O\+R\+M = Plasma\+One\+Norm ( ( norm\+I(\+A), N\+O\+R\+M = Plasma\+Inf\+Norm ( ( norm\+F(\+A), N\+O\+R\+M = Plasma\+Frobenius\+Norm

where norm1 denotes the one norm of a matrix (maximum column sum), norm\+I denotes the infinity norm of a matrix (maximum row sum) and norm\+F denotes the Frobenius norm of a matrix (square root of sum of squares). Note that max(abs(\+A(i,j))) is not a consistent matrix norm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em norm} & = Plasma\+Max\+Norm\+: Max norm = Plasma\+One\+Norm\+: One norm = Plasma\+Inf\+Norm\+: Infinity norm = Plasma\+Frobenius\+Norm\+: Frobenius norm\\
\hline
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns/rows of the matrix A. N $>$= 0. When N = 0, the returned value is set to zero.\\
\hline
\mbox{\tt in}  & {\em A} & The N-\/by-\/\+N matrix A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt in,out}  & {\em work} & Array of dimension (M\+A\+X(1,\+L\+W\+O\+R\+K)), where L\+W\+O\+R\+K $>$= N when norm = Plasma\+Inf\+Norm or Plasma\+One\+Norm; otherwise, work is not referenced.\\
\hline
\mbox{\tt out}  & {\em norm\+A} & On exit, norm\+A is the norm of matrix A. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga8af274e76af862faf884629524a4daed_ga8af274e76af862faf884629524a4daed}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clantr@{C\+O\+R\+E\+\_\+clantr}}
\index{C\+O\+R\+E\+\_\+clantr@{C\+O\+R\+E\+\_\+clantr}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clantr}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+clantr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{norm, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{diag, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{float $\ast$}]{work, }
\item[{float $\ast$}]{norm\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga8af274e76af862faf884629524a4daed_ga8af274e76af862faf884629524a4daed}
C\+O\+R\+E\+\_\+clantr returns the value

clantr = ( max(abs(\+A(i,j))), N\+O\+R\+M = Plasma\+Max\+Norm ( ( norm1(\+A), N\+O\+R\+M = Plasma\+One\+Norm ( ( norm\+I(\+A), N\+O\+R\+M = Plasma\+Inf\+Norm ( ( norm\+F(\+A), N\+O\+R\+M = Plasma\+Frobenius\+Norm

where norm1 denotes the one norm of a matrix (maximum column sum), norm\+I denotes the infinity norm of a matrix (maximum row sum) and norm\+F denotes the Frobenius norm of a matrix (square root of sum of squares). Note that max(abs(\+A(i,j))) is not a consistent matrix norm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em norm} & = Plasma\+Max\+Norm\+: Max norm = Plasma\+One\+Norm\+: One norm = Plasma\+Inf\+Norm\+: Infinity norm = Plasma\+Frobenius\+Norm\+: Frobenius norm\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular\+: = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em diag} & Specifies whether or not A is unit triangular\+: = Plasma\+Non\+Unit\+: A is non unit; = Plasma\+Unit\+: A us unit.\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0. If uplo == Plasma\+Upper, M $<$= N. When M = 0, C\+O\+R\+E\+\_\+clantr returns 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0. If uplo == Plasma\+Lower, N $<$= M. When N = 0, C\+O\+R\+E\+\_\+clantr returns 0.\\
\hline
\mbox{\tt in}  & {\em A} & The L\+D\+A-\/by-\/\+N matrix A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em work} & Array of dimension (M\+A\+X(1,\+L\+W\+O\+R\+K)), where L\+W\+O\+R\+K $>$= M when norm = Plasma\+Inf\+Norm, or L\+W\+O\+R\+K $>$= N when norm = Plasma\+One\+Norm; otherwise, work is not referenced.\\
\hline
\mbox{\tt out}  & {\em norm\+A} & On exit, norm\+A is the norm of matrix A. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga76bff5de536b4c4a64ac3c95d15ea98e_ga76bff5de536b4c4a64ac3c95d15ea98e}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clarfb\+\_\+gemm@{C\+O\+R\+E\+\_\+clarfb\+\_\+gemm}}
\index{C\+O\+R\+E\+\_\+clarfb\+\_\+gemm@{C\+O\+R\+E\+\_\+clarfb\+\_\+gemm}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clarfb\+\_\+gemm}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+clarfb\+\_\+gemm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{direct, }
\item[{int}]{storev, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C, }
\item[{int}]{L\+D\+C, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga76bff5de536b4c4a64ac3c95d15ea98e_ga76bff5de536b4c4a64ac3c95d15ea98e}
C\+O\+R\+E\+\_\+clarfb\+\_\+gemm applies a complex block reflector H or its transpose H\textquotesingle{} to a complex M-\/by-\/\+N matrix C, from either the left or the right. this kernel is similar to the lapack clarfb but it do a full gemm on the triangular Vs assuming that the upper part of Vs is zero and ones are on the diagonal. It is also based on the fact that a gemm on a small block of k reflectors is faster than a trmm on the triangular (k,k) + gemm below.

N\+O\+T\+E T\+H\+A\+T\+: Only Columnwise/\+Forward cases are treated here.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+H from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+H from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Conj\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+H.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em direct} & Indicates how H is formed from a product of elementary reflectors \begin{DoxyItemize}
\item Plasma\+Forward \+: H = H(1) H(2) . . . H(k) (Forward) \item Plasma\+Backward \+: H = H(k) . . . H(2) H(1) (Backward)\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em storev} & Indicates how the vectors which define the elementary reflectors are stored\+: \begin{DoxyItemize}
\item Plasma\+Columnwise \item Plasma\+Rowwise\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix C.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix C.\\
\hline
\mbox{\tt in}  & {\em K} & The order of the matrix T (= the number of elementary reflectors whose product defines the block reflector).\\
\hline
\mbox{\tt in}  & {\em V} & C\+O\+M\+P\+L\+E\+X$\ast$8 array, dimension (L\+D\+V,K) if storev = \textquotesingle{}C\textquotesingle{} (L\+D\+V,M) if storev = \textquotesingle{}R\textquotesingle{} and side = \textquotesingle{}L\textquotesingle{} (L\+D\+V,N) if storev = \textquotesingle{}R\textquotesingle{} and side = \textquotesingle{}R\textquotesingle{} The matrix V. See further details.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. If storev = \textquotesingle{}C\textquotesingle{} and side = \textquotesingle{}L\textquotesingle{}, L\+D\+V $>$= max(1,\+M); if storev = \textquotesingle{}C\textquotesingle{} and side = \textquotesingle{}R\textquotesingle{}, L\+D\+V $>$= max(1,\+N); if storev = \textquotesingle{}R\textquotesingle{}, L\+D\+V $>$= K.\\
\hline
\mbox{\tt in}  & {\em T} & The triangular K-\/by-\/\+K matrix T in the representation of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= K.\\
\hline
\mbox{\tt in,out}  & {\em C} & C\+O\+M\+P\+L\+E\+X$\ast$8 array, dimension (L\+D\+C,N) On entry, the M-\/by-\/\+N matrix C. On exit, C is overwritten by H$\ast$\+C or H\textquotesingle{}$\ast$\+C or C$\ast$\+H or C$\ast$\+H\textquotesingle{}.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & (workspace) C\+O\+M\+P\+L\+E\+X$\ast$8 array, dimension (L\+D\+W\+O\+R\+K,K).\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K. If side = Plasma\+Left, L\+D\+W\+O\+R\+K $>$= max(1,\+N); if side = Plasma\+Right, L\+D\+W\+O\+R\+K $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga6ab3da186625191c12ddfd0e27aca922_ga6ab3da186625191c12ddfd0e27aca922}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clarfx2@{C\+O\+R\+E\+\_\+clarfx2}}
\index{C\+O\+R\+E\+\_\+clarfx2@{C\+O\+R\+E\+\_\+clarfx2}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clarfx2}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+clarfx2 (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{T\+A\+U, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C1, }
\item[{int}]{L\+D\+C1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C2, }
\item[{int}]{L\+D\+C2}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga6ab3da186625191c12ddfd0e27aca922_ga6ab3da186625191c12ddfd0e27aca922}
C\+O\+R\+E\+\_\+clarfx2 applies a complex elementary reflector H to a complex m by n matrix C, from either the left or the right. H is represented in the form \begin{DoxyVerb}  H = I - tau * v * v'
\end{DoxyVerb}


where tau is a complex scalar and v is a complex vector.

If tau = 0, then H is taken to be the unit matrix

This version uses inline code if H has order $<$ 11.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: form H $\ast$ C \item Plasma\+Right\+: form C $\ast$ H\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of C1 and C2 if side = Plasma\+Left. The number of rows of C1 and C2 if side = Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em V} & The float complex V in the representation of H.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & The value tau in the representation of H.\\
\hline
\mbox{\tt in,out}  & {\em C1} & dimension (L\+D\+C1,N), if side = Plasma\+Left dimension (L\+D\+C1,1), if side = Plasma\+Right On entry, the m by n matrix C1. On exit, C1 is overwritten by the matrix H $\ast$ C1 if S\+I\+D\+E = Plasma\+Left, or C1 $\ast$ H if S\+I\+D\+E = Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C1} & The leading dimension of the array C1. L\+D\+C1 $>$= max(1,\+N), if side == Plasma\+Right. L\+D\+C1 $>$= 1, otherwise.\\
\hline
\mbox{\tt in,out}  & {\em C2} & dimension (L\+D\+C2,N), if side = Plasma\+Left dimension (L\+D\+C2,1), if side = Plasma\+Right On entry, the m by n matrix C2. On exit, C2 is overwritten by the matrix H $\ast$ C2 if S\+I\+D\+E = Plasma\+Left, or C2 $\ast$ H if S\+I\+D\+E = Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C2} & The leading dimension of the array C2. L\+D\+C2 $>$= max(1,\+N), if side == Plasma\+Right. L\+D\+C2 $>$= 1, otherwise.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gafd84d279fa45c7435bef96cca4128ebf_gafd84d279fa45c7435bef96cca4128ebf}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clarfx2c@{C\+O\+R\+E\+\_\+clarfx2c}}
\index{C\+O\+R\+E\+\_\+clarfx2c@{C\+O\+R\+E\+\_\+clarfx2c}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clarfx2c}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+clarfx2c (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{T\+A\+U, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C2, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C3}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gafd84d279fa45c7435bef96cca4128ebf_gafd84d279fa45c7435bef96cca4128ebf}
C\+O\+R\+E\+\_\+clarfx2c applies a complex elementary reflector H to a diagonal corner C=\mbox{[}C1, C2, C3\mbox{]}, from both the left and the right side. C = H $\ast$ C $\ast$ H. It is used in the case of Hermetian. If Plasma\+Lower, a left apply is followed by a right apply. If Plasma\+Upper, a right apply is followed by a left apply. H is represented in the form

This routine is a special code for a corner C diagonal block C1 C2 C3

\begin{DoxyVerb}   H = I - tau * v * v'
\end{DoxyVerb}


where tau is a complex scalar and v is a complex vector.

If tau = 0, then H is taken to be the unit matrix

This version uses inline code if H has order $<$ 11.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em V} & The float complex V in the representation of H.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & The value tau in the representation of H.\\
\hline
\mbox{\tt in,out}  & {\em C1} & On entry, the element C1. On exit, C1 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\mbox{\tt in,out}  & {\em C2} & On entry, the element C2. On exit, C2 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\mbox{\tt in,out}  & {\em C3} & On entry, the element C3. On exit, C3 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga27560b614aacabb021f8c902e4194ca5_ga27560b614aacabb021f8c902e4194ca5}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clarfx2ce@{C\+O\+R\+E\+\_\+clarfx2ce}}
\index{C\+O\+R\+E\+\_\+clarfx2ce@{C\+O\+R\+E\+\_\+clarfx2ce}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clarfx2ce}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+clarfx2ce (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C2, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C3}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga27560b614aacabb021f8c902e4194ca5_ga27560b614aacabb021f8c902e4194ca5}
C\+O\+R\+E\+\_\+clarfx2c applies a complex elementary reflector H to a diagonal corner C=\mbox{[}C1, C2, C3\mbox{]}, from both the left and the right side. C = H $\ast$ C $\ast$ H. It is used in the case of general matrices, where it create a nnz at the N\+E\+W\+\_\+\+N\+N\+Z position, then it eliminate it and update the reflector V and T\+A\+U. If Plasma\+Lower, a left apply is followed by a right apply. If Plasma\+Upper, a right apply is followed by a left apply. H is represented in the form

This routine is a special code for a corner C diagonal block C1 N\+E\+W\+\_\+\+N\+N\+Z C2 C3

\begin{DoxyVerb}   H = I - tau * v * v'
\end{DoxyVerb}


where tau is a complex scalar and v is a complex vector.

If tau = 0, then H is taken to be the unit matrix

This version uses inline code if H has order $<$ 11.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in,out}  & {\em V} & On entry, the float complex V in the representation of H. On exit, the float complex V in the representation of H, updated by the elimination of the N\+E\+W\+\_\+\+N\+N\+Z created by the left apply in case of Plasma\+Lower or the right apply in case of Plasma\+Upper.\\
\hline
\mbox{\tt in,out}  & {\em T\+A\+U} & On entry, the value tau in the representation of H. On exit, the value tau in the representation of H, updated by the elimination of the N\+E\+W\+\_\+\+N\+N\+Z created by the left apply in case of Plasma\+Lower or the right apply in case of Plasma\+Upper.\\
\hline
\mbox{\tt in,out}  & {\em C1} & On entry, the element C1. On exit, C1 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\mbox{\tt in,out}  & {\em C2} & On entry, the element C2. On exit, C2 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\mbox{\tt in,out}  & {\em C3} & On entry, the element C3. On exit, C3 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga8eb544f55fe27c43c7c485ccafc46cd5_ga8eb544f55fe27c43c7c485ccafc46cd5}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clarfy@{C\+O\+R\+E\+\_\+clarfy}}
\index{C\+O\+R\+E\+\_\+clarfy@{C\+O\+R\+E\+\_\+clarfy}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clarfy}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+clarfy (
\begin{DoxyParamCaption}
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga8eb544f55fe27c43c7c485ccafc46cd5_ga8eb544f55fe27c43c7c485ccafc46cd5}
C\+O\+R\+E\+\_\+clarfy applies an elementary reflector, or Householder matrix, H, to a N-\/by-\/\+N hermitian matrix C, from both the left and the right.

H is represented in the form

H = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a scalar and v is a vector.

If tau is zero, then H is taken to be the unit matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & The number of rows and columns of the matrix C. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & C\+O\+M\+P\+L\+E\+X$\ast$8 array, dimension (L\+D\+A, N) On entry, the Hermetian matrix A. On exit, A is overwritten by H $\ast$ A $\ast$ H\textquotesingle{}.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt in}  & {\em V} & The vector V that contains the Householder reflectors.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & The value tau.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga3087ef6316f2f1b9c096fbf5d8c5b545_ga3087ef6316f2f1b9c096fbf5d8c5b545}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clascal@{C\+O\+R\+E\+\_\+clascal}}
\index{C\+O\+R\+E\+\_\+clascal@{C\+O\+R\+E\+\_\+clascal}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clascal}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+clascal (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga3087ef6316f2f1b9c096fbf5d8c5b545_ga3087ef6316f2f1b9c096fbf5d8c5b545}
C\+O\+R\+E\+\_\+clascal scales a two-\/dimensional matrix A. As opposite to \hyperlink{group__CORE__PLASMA__Complex32__t_ga1a4f4c74119e6dc9f291f8d7719e5295_ga1a4f4c74119e6dc9f291f8d7719e5295}{C\+O\+R\+E\+\_\+clascl()}, no checks is performed to prevent under/overflow. This should have been done at higher level.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies the shape of A\+: = Plasma\+Upper\+Lower\+: A is a general matrix. = Plasma\+Upper\+: A is an upper trapezoidal matrix. = Plasma\+Lower\+: A is a lower trapezoidal matrix.\\
\hline
\mbox{\tt in}  & {\em m} & is the number of rows of the matrix A. m $>$= 0\\
\hline
\mbox{\tt in}  & {\em n} & is the number of columns of the matrix A. n $>$= 0\\
\hline
\mbox{\tt in}  & {\em alpha} & The scalar factor.\\
\hline
\mbox{\tt in,out}  & {\em A} & is the matrix to be multiplied by alpha\\
\hline
\mbox{\tt in}  & {\em lda} & is the leading dimension of the array A. lda $>$= max(1,m).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga1a4f4c74119e6dc9f291f8d7719e5295_ga1a4f4c74119e6dc9f291f8d7719e5295}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clascl@{C\+O\+R\+E\+\_\+clascl}}
\index{C\+O\+R\+E\+\_\+clascl@{C\+O\+R\+E\+\_\+clascl}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clascl}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+clascl (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{type, }
\item[{int}]{kl, }
\item[{int}]{ku, }
\item[{float}]{cfrom, }
\item[{float}]{cto, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga1a4f4c74119e6dc9f291f8d7719e5295_ga1a4f4c74119e6dc9f291f8d7719e5295}
C\+O\+R\+E\+\_\+clascl scales all or part of a two-\/dimensional matrix A.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em type} & Specifies the type of the matrix A. = Plasma\+General \+: A is a general matrix = Plasma\+Lower\+Triangular \+: A is a lower triangular matrix = Plasma\+Upper\+Triangular \+: A is an upper triangular matrix = Plasma\+Upper\+Hessenberg \+: A is an upper Hessenberg matrix = Plasma\+Symetric\+Band\+Lower\+Stored \+: A is a symmetric band matrix with lower bandwidth K\+L and upper bandwidth K\+U and with the only the lower half stored = Plasma\+Symetric\+Band\+Upper\+Stored \+: A is a symmetric band matrix with lower bandwidth K\+L and upper bandwidth K\+U and with the only the upper half stored = Plasma\+Band \+: A is a band matrix with lower bandwidth K\+L and upper bandwidth K\+U. See Z\+G\+B\+T\+R\+F for storage details.\\
\hline
\mbox{\tt in}  & {\em kl} & is the lower bandwidth of A. Referenced only if type = Plasma\+Symetric\+Band\+Lower\+Stored, Plasma\+Symetric\+Band\+Upper\+Stored or Plasma\+Band.\\
\hline
\mbox{\tt in}  & {\em ku} & is the upper bandwidth of A. Referenced only if type = Plasma\+Symetric\+Band\+Lower\+Stored, Plasma\+Symetric\+Band\+Upper\+Stored or Plasma\+Band.\\
\hline
\mbox{\tt in}  & {\em cfrom} & is real\\
\hline
\mbox{\tt in}  & {\em cto} & is real The matrix A is multiplied bt cto/cfrom. cfrom must be nonzero. The final result ctot$\ast$\+A(i,j)/cfrom is computed without over/underflow\\
\hline
\mbox{\tt in}  & {\em m} & is the number of rows of the matrix A. m $>$= 0\\
\hline
\mbox{\tt in}  & {\em n} & is the number of columns of the matrix A. n $>$= 0\\
\hline
\mbox{\tt in,out}  & {\em A} & is the matrix to be multiplied by cto/cfrom\\
\hline
\mbox{\tt in}  & {\em lda} & is the leading dimension of the array A. lda $>$= max(1,m).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga2e708440b68df39ec3772768cd78d79e_ga2e708440b68df39ec3772768cd78d79e}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+claset@{C\+O\+R\+E\+\_\+claset}}
\index{C\+O\+R\+E\+\_\+claset@{C\+O\+R\+E\+\_\+claset}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+claset}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+claset (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{beta, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga2e708440b68df39ec3772768cd78d79e_ga2e708440b68df39ec3772768cd78d79e}
C\+O\+R\+E\+\_\+claset -\/ Sets the elements of the matrix A on the diagonal to beta and on the off-\/diagonals to alpha


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies which elements of the matrix are to be set = Plasma\+Upper\+: Upper part of A is set; = Plasma\+Lower\+: Lower part of A is set; = Plasma\+Upper\+Lower\+: A\+L\+L elements of A are set.\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & The constant to which the off-\/diagonal elements are to be set.\\
\hline
\mbox{\tt in}  & {\em beta} & The constant to which the diagonal elements are to be set.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile A. On exit, A has been set accordingly.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gac08e91310fd70351d27546eb488fbd81_gac08e91310fd70351d27546eb488fbd81}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+claset2@{C\+O\+R\+E\+\_\+claset2}}
\index{C\+O\+R\+E\+\_\+claset2@{C\+O\+R\+E\+\_\+claset2}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+claset2}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+claset2 (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gac08e91310fd70351d27546eb488fbd81_gac08e91310fd70351d27546eb488fbd81}
C\+O\+R\+E\+\_\+claset2 -\/ Sets the elements of the matrix A to alpha. Not L\+A\+P\+A\+C\+K compliant! Read below.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies which elements of the matrix are to be set = Plasma\+Upper\+: S\+T\+R\+I\+C\+T Upper part of A is set to alpha; = Plasma\+Lower\+: S\+T\+R\+I\+C\+T Lower part of A is set to alpha; = Plasma\+Upper\+Lower\+: A\+L\+L elements of A are set to alpha. Not L\+A\+P\+A\+C\+K Compliant.\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & The constant to which the elements are to be set.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile A. On exit, A has been set to alpha accordingly.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gae932091627c46b688b67aebcfb537573_gae932091627c46b688b67aebcfb537573}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+claswp@{C\+O\+R\+E\+\_\+claswp}}
\index{C\+O\+R\+E\+\_\+claswp@{C\+O\+R\+E\+\_\+claswp}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+claswp}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+claswp (
\begin{DoxyParamCaption}
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int}]{I1, }
\item[{int}]{I2, }
\item[{const int $\ast$}]{I\+P\+I\+V, }
\item[{int}]{I\+N\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gae932091627c46b688b67aebcfb537573_gae932091627c46b688b67aebcfb537573}
C\+O\+R\+E\+\_\+claswp performs a series of row interchanges on the matrix A. One row interchange is initiated for each of rows I1 through I2 of A.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & The number of columns in the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the matrix of column dimension N to which the row interchanges will be applied. On exit, the permuted matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,max(I\+P\+I\+V\mbox{[}I1..I2\mbox{]})).\\
\hline
\mbox{\tt in}  & {\em I1} & The first element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em I2} & The last element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em I\+P\+I\+V} & The pivot indices; Only the element in position i1 to i2 are accessed. The pivot are offset by A.\+i.\\
\hline
\mbox{\tt in}  & {\em I\+N\+C} & The increment between successive values of I\+P\+I\+V. If I\+P\+I\+V is negative, the pivots are applied in reverse order. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga18336def276ef2189f9e51afc1976624_ga18336def276ef2189f9e51afc1976624}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+claswp\+\_\+ontile@{C\+O\+R\+E\+\_\+claswp\+\_\+ontile}}
\index{C\+O\+R\+E\+\_\+claswp\+\_\+ontile@{C\+O\+R\+E\+\_\+claswp\+\_\+ontile}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+claswp\+\_\+ontile}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+claswp\+\_\+ontile (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{desc\+A, }
\item[{int}]{i1, }
\item[{int}]{i2, }
\item[{const int $\ast$}]{ipiv, }
\item[{int}]{inc}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga18336def276ef2189f9e51afc1976624_ga18336def276ef2189f9e51afc1976624}
C\+O\+R\+E\+\_\+claswp\+\_\+ontile apply the claswp function on a matrix stored in tile layout


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em desc\+A} & The descriptor of the matrix A to permute.\\
\hline
\mbox{\tt in}  & {\em i1} & The first element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em i2} & The last element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em ipiv} & The pivot indices; Only the element in position i1 to i2 are accessed. The pivot are offset by A.\+i.\\
\hline
\mbox{\tt in}  & {\em inc} & The increment between successive values of I\+P\+I\+V. If I\+P\+I\+V is negative, the pivots are applied in reverse order.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga50a473e33ed85bf4b07d1b9a441a9731_ga50a473e33ed85bf4b07d1b9a441a9731}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+claswpc\+\_\+ontile@{C\+O\+R\+E\+\_\+claswpc\+\_\+ontile}}
\index{C\+O\+R\+E\+\_\+claswpc\+\_\+ontile@{C\+O\+R\+E\+\_\+claswpc\+\_\+ontile}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+claswpc\+\_\+ontile}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+claswpc\+\_\+ontile (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{desc\+A, }
\item[{int}]{i1, }
\item[{int}]{i2, }
\item[{const int $\ast$}]{ipiv, }
\item[{int}]{inc}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga50a473e33ed85bf4b07d1b9a441a9731_ga50a473e33ed85bf4b07d1b9a441a9731}
C\+O\+R\+E\+\_\+claswpc\+\_\+ontile apply the claswp function on a matrix stored in tile layout


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em desc\+A} & The descriptor of the matrix A to permute.\\
\hline
\mbox{\tt in}  & {\em i1} & The first element of I\+P\+I\+V for which a column interchange will be done.\\
\hline
\mbox{\tt in}  & {\em i2} & The last element of I\+P\+I\+V for which a column interchange will be done.\\
\hline
\mbox{\tt in}  & {\em ipiv} & The pivot indices; Only the element in position i1 to i2 are accessed. The pivot are offset by A.\+i.\\
\hline
\mbox{\tt in}  & {\em inc} & The increment between successive values of I\+P\+I\+V. If I\+P\+I\+V is negative, the pivots are applied in reverse order.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gafe9ffac6e225949a3a0d13f084db12cb_gafe9ffac6e225949a3a0d13f084db12cb}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clatro@{C\+O\+R\+E\+\_\+clatro}}
\index{C\+O\+R\+E\+\_\+clatro@{C\+O\+R\+E\+\_\+clatro}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clatro}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+clatro (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gafe9ffac6e225949a3a0d13f084db12cb_gafe9ffac6e225949a3a0d13f084db12cb}
C\+O\+R\+E\+\_\+clatro transposes a m-\/by-\/n matrix out of place.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular\+: = Plasma\+Upper\+: the upper triangle of A and the lower triangle of B are referenced. = Plasma\+Lower\+: the lower triangle of A and the upper triangle of B are referenced. = Plasma\+Upper\+Lower\+: All A and B are referenced.\\
\hline
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is transposed, not transposed or conjfugate transposed\+: = Plasma\+No\+Trans\+: B is a copy of A (equivalent to clacpy); = Plasma\+Trans\+: B is the transpose of A; = Plasma\+Conj\+Trans\+: B is the conjfugate transpose of A.\\
\hline
\mbox{\tt in}  & {\em M} & Number of rows of the matrix A and number of columns of the matrix B, if trans == Pasma\mbox{[}Conj\mbox{]}Trans. Number of rows of the matrix A and the matrix B, if trans == Pasma\+No\+Trans.\\
\hline
\mbox{\tt in}  & {\em N} & Number of columns of the matrix A and number of rows of the matrix B, if trans == Pasma\mbox{[}Conj\mbox{]}Trans. Number of columns of the matrix A and of the matrix B, if trans == Plasma\+No\+Trans.\\
\hline
\mbox{\tt in}  & {\em A} & Matrix of size L\+D\+A-\/by-\/\+N, if trans == Pasma\mbox{[}Conj\mbox{]}Trans. Matrix of size L\+D\+A-\/by-\/\+M, if trans == Pasma\+No\+Trans.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M), if trans == Pasma\mbox{[}Conj\mbox{]}Trans. L\+D\+A $>$= max(1,\+N), if trans == Pasma\+No\+Trans.\\
\hline
\mbox{\tt out}  & {\em B} & Matrix of size L\+D\+B-\/by-\/\+M, if trans == Pasma\mbox{[}Conj\mbox{]}Trans. Matrix of size L\+D\+B-\/by-\/\+N, if trans == Pasma\+No\+Trans.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+N), if trans == Pasma\mbox{[}Conj\mbox{]}Trans. L\+D\+B $>$= max(1,\+M), if trans == Pasma\+No\+Trans.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga524ade90166bbf2514e1259685dc603e_ga524ade90166bbf2514e1259685dc603e}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+clauum@{C\+O\+R\+E\+\_\+clauum}}
\index{C\+O\+R\+E\+\_\+clauum@{C\+O\+R\+E\+\_\+clauum}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+clauum}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+clauum (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga524ade90166bbf2514e1259685dc603e_ga524ade90166bbf2514e1259685dc603e}
C\+O\+R\+E\+\_\+clauum -\/ Computes the product U $\ast$ U\textquotesingle{} or L\textquotesingle{} $\ast$ L, where the triangular factor U or L is stored in the upper or lower triangular part of the array A.

If U\+P\+L\+O = \textquotesingle{}U\textquotesingle{} or \textquotesingle{}u\textquotesingle{} then the upper triangle of the result is stored, overwriting the factor U in A. If U\+P\+L\+O = \textquotesingle{}L\textquotesingle{} or \textquotesingle{}l\textquotesingle{} then the lower triangle of the result is stored, overwriting the factor L in A.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the triangular factor U or L. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the triangular factor U or L. On exit, if U\+P\+L\+O = \textquotesingle{}U\textquotesingle{}, the upper triangle of A is overwritten with the upper triangle of the product U $\ast$ U\textquotesingle{}; if U\+P\+L\+O = \textquotesingle{}L\textquotesingle{}, the lower triangle of A is overwritten with the lower triangle of the product L\textquotesingle{} $\ast$ L.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga1cba20dafe66a5e6fd0ba87604120002_ga1cba20dafe66a5e6fd0ba87604120002}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cpamm@{C\+O\+R\+E\+\_\+cpamm}}
\index{C\+O\+R\+E\+\_\+cpamm@{C\+O\+R\+E\+\_\+cpamm}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cpamm}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cpamm (
\begin{DoxyParamCaption}
\item[{int}]{op, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{storev, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{int}]{L, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W, }
\item[{int}]{L\+D\+W}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga1cba20dafe66a5e6fd0ba87604120002_ga1cba20dafe66a5e6fd0ba87604120002}
Z\+P\+A\+M\+M performs one of the matrix-\/matrix operations \begin{DoxyVerb}              LEFT                      RIGHT
\end{DoxyVerb}
 O\+P Plasma\+W \+: W = A1 + op(\+V) $\ast$ A2 or W = A1 + A2 $\ast$ op(\+V) O\+P Plasma\+A2 \+: A2 = A2 -\/ op(\+V) $\ast$ W or A2 = A2 -\/ W $\ast$ op(\+V)

where op( V ) is one of

op( V ) = V or op( V ) = V$\ast$$\ast$\+T or op( V ) = V$\ast$$\ast$\+H,

A1, A2 and W are general matrices, and V is\+: \begin{DoxyVerb}  l = k: rectangle + triangle
  l < k: rectangle + trapezoid
  l = 0: rectangle
\end{DoxyVerb}


Size of V, both rowwise and columnwise, is\+: 

 \subsubsection*{side trans size }

left N M x K T K x M right N K x N \subsubsection*{T N x K }

L\+E\+F\+T (columnwise and rowwise)\+: \begin{DoxyVerb}        |    K    |                 |         M         |
     _  __________   _              _______________        _
        |    |    |                 |             | \
\end{DoxyVerb}
 V\+: $\vert$ $\vert$ $\vert$ V\textquotesingle{}\+: $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$\+\_\+\+\_\+\+\_\+\textbackslash{} K $\vert$ $\vert$ $\vert$ M-\/\+L $\vert$ $\vert$ M $\vert$ $\vert$ $\vert$ $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+ $\vert$\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ $\vert$ \+\_\+ \textbackslash{} $\vert$ $\vert$ $\vert$ M -\/ L $\vert$ L $\vert$ \textbackslash{} $\vert$ $\vert$ L \+\_\+ $|$\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+

R\+I\+G\+H\+T (columnwise and rowwise)\+: \begin{DoxyVerb}    |         K         |                   |    N    |
    _______________        _             _  __________   _
    |             | \                       |    |    |
\end{DoxyVerb}
 V\textquotesingle{}\+: $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$\+\_\+\+\_\+\+\_\+\textbackslash{} N V\+: $\vert$ $\vert$ $\vert$ $\vert$ $\vert$ $\vert$ $\vert$ $\vert$ K-\/\+L $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+ K $\vert$ $\vert$ $\vert$ $\vert$\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ $\vert$ \+\_\+ $\vert$ K -\/ L $\vert$ L $\vert$ \textbackslash{} $\vert$ $\vert$ \textbackslash{} $\vert$ $\vert$ L \+\_\+ $|$\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+

\subsection*{Arguments }


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em op} & \begin{DoxyVerb}    OP specifies which operation to perform:

    @arg PlasmaW  : W  = A1 + op(V) * A2  or  W  = A1 + A2 * op(V)
    @arg PlasmaA2 : A2 = A2 - op(V) * W   or  A2 = A2 - W * op(V)
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em side} & \begin{DoxyVerb}    SIDE specifies whether  op( V ) multiplies A2
    or W from the left or right as follows:

    @arg PlasmaLeft  : multiply op( V ) from the left
                       OP PlasmaW  :  W  = A1 + op(V) * A2
                       OP PlasmaA2 :  A2 = A2 - op(V) * W

    @arg PlasmaRight : multiply op( V ) from the right
                       OP PlasmaW  :  W  = A1 + A2 * op(V)
                       OP PlasmaA2 :  A2 = A2 - W * op(V)
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em storev} & \begin{DoxyVerb}    Indicates how the vectors which define the elementary
    reflectors are stored in V:

    @arg PlasmaColumnwise
    @arg PlasmaRowwise
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the A1, A2 and W If S\+I\+D\+E is Plasma\+Left, the number of rows of op( V )\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the A1, A2 and W If S\+I\+D\+E is Plasma\+Right, the number of columns of op( V )\\
\hline
\mbox{\tt in}  & {\em K} & If S\+I\+D\+E is Plasma\+Left, the number of columns of op( V ) If S\+I\+D\+E is Plasma\+Right, the number of rows of op( V )\\
\hline
\mbox{\tt in}  & {\em L} & The size of the triangular part of V\\
\hline
\mbox{\tt in}  & {\em A1} & On entry, the M-\/by-\/\+N tile A1.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M-\/by-\/\+N tile A2. On exit, if O\+P is Plasma\+A2 A2 is overwritten\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em V} & The matrix V as described above. If S\+I\+D\+E is Plasma\+Left \+: op( V ) is M-\/by-\/\+K If S\+I\+D\+E is Plasma\+Right\+: op( V ) is K-\/by-\/\+N\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V.\\
\hline
\mbox{\tt in,out}  & {\em W} & On entry, the M-\/by-\/\+N matrix W. On exit, W is overwritten either if O\+P is Plasma\+A2 or Plasma\+W. If O\+P is Plasma\+A2, W is an input and is used as a workspace.\\
\hline
\mbox{\tt in}  & {\em L\+D\+W} & The leading dimension of array W\+O\+R\+K.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga450824a3da3b8be57d1f1640cd975328_ga450824a3da3b8be57d1f1640cd975328}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cparfb@{C\+O\+R\+E\+\_\+cparfb}}
\index{C\+O\+R\+E\+\_\+cparfb@{C\+O\+R\+E\+\_\+cparfb}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cparfb}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cparfb (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{direct, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{storev, }
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{L, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga450824a3da3b8be57d1f1640cd975328_ga450824a3da3b8be57d1f1640cd975328}
C\+O\+R\+E\+\_\+cparfb applies a complex upper triangular block reflector H or its transpose H\textquotesingle{} to a complex rectangular matrix formed by coupling two tiles A1 and A2. Matrix V is\+: \begin{DoxyVerb}    COLUMNWISE                    ROWWISE

   |     K     |                 |      N2-L     |   L  |
__ _____________ __           __ _________________        __
   |    |      |                 |               | \
   |    |      |                 |               |   \    L
\end{DoxyVerb}
 M2-\/\+L $\vert$ $\vert$ $\vert$ K $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\textbackslash{} \+\_\+\+\_\+ $\vert$ $\vert$ $\vert$ M2 $\vert$ $\vert$ \+\_\+\+\_\+ $\vert$\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ $\vert$ $\vert$ $\vert$ K-\/\+L \textbackslash{} $\vert$ $\vert$ \+\_\+\+\_\+ $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+\+\_\+ L \textbackslash{} $\vert$ $\vert$ \+\_\+\+\_\+ $|$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+\+\_\+ $\vert$ N2 $\vert$

$\vert$ L $\vert$ K-\/\+L $\vert$


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+H from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+H from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Conj\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+H.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em direct} & Indicates how H is formed from a product of elementary reflectors \begin{DoxyItemize}
\item Plasma\+Forward \+: H = H(1) H(2) . . . H(k) (Forward) \item Plasma\+Backward \+: H = H(k) . . . H(2) H(1) (Backward)\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em storev} & Indicates how the vectors which define the elementary reflectors are stored\+: \begin{DoxyItemize}
\item Plasma\+Columnwise \item Plasma\+Rowwise\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M1} & The number of columns of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of rows of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of columns of the tile A2. M2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of rows of the tile A2. N2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The order of the matrix T (= the number of elementary reflectors whose product defines the block reflector).\\
\hline
\mbox{\tt in}  & {\em L} & The size of the triangular part of V\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+N1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+N2).\\
\hline
\mbox{\tt in}  & {\em V} & (L\+D\+V,K) if S\+T\+O\+R\+E\+V = \textquotesingle{}C\textquotesingle{} (L\+D\+V,M2) if S\+T\+O\+R\+E\+V = \textquotesingle{}R\textquotesingle{} and S\+I\+D\+E = \textquotesingle{}L\textquotesingle{} (L\+D\+V,N2) if S\+T\+O\+R\+E\+V = \textquotesingle{}R\textquotesingle{} and S\+I\+D\+E = \textquotesingle{}R\textquotesingle{} Matrix V.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. If S\+T\+O\+R\+E\+V = \textquotesingle{}C\textquotesingle{} and S\+I\+D\+E = \textquotesingle{}L\textquotesingle{}, L\+D\+V $>$= max(1,\+M2); if S\+T\+O\+R\+E\+V = \textquotesingle{}C\textquotesingle{} and S\+I\+D\+E = \textquotesingle{}R\textquotesingle{}, L\+D\+V $>$= max(1,\+N2); if S\+T\+O\+R\+E\+V = \textquotesingle{}R\textquotesingle{}, L\+D\+V $>$= K.\\
\hline
\mbox{\tt out}  & {\em T} & The triangular K-\/by-\/\+K matrix T in the representation of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= K.\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & \\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga3b6583c1a567beb3f5245b86a78c6075_ga3b6583c1a567beb3f5245b86a78c6075}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cpemv@{C\+O\+R\+E\+\_\+cpemv}}
\index{C\+O\+R\+E\+\_\+cpemv@{C\+O\+R\+E\+\_\+cpemv}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cpemv}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cpemv (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{storev, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{L, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{A\+L\+P\+H\+A, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{X, }
\item[{int}]{I\+N\+C\+X, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{B\+E\+T\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{Y, }
\item[{int}]{I\+N\+C\+Y, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga3b6583c1a567beb3f5245b86a78c6075_ga3b6583c1a567beb3f5245b86a78c6075}
C\+O\+R\+E\+\_\+cpemv performs one of the matrix-\/vector operations

y = alpha$\ast$op( A )$\ast$x + beta$\ast$y

where op( A ) is one of

op( A ) = A or op( A ) = A$\ast$$\ast$\+T or op( A ) = A$\ast$$\ast$\+H,

alpha and beta are scalars, x and y are vectors and A is a pentagonal matrix (see further details).

\subsection*{Arguments }


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em storev} & \begin{DoxyVerb}    @arg PlasmaColumnwise :  array A stored columwise
    @arg PlasmaRowwise    :  array A stored rowwise
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyVerb}    @arg PlasmaNoTrans   :  y := alpha*A*x    + beta*y.
    @arg PlasmaTrans     :  y := alpha*A**T*x + beta*y.
    @arg PlasmaConjTrans :  y := alpha*A**H*x + beta*y.
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & Number of rows of the matrix A. M must be at least zero.\\
\hline
\mbox{\tt in}  & {\em N} & Number of columns of the matrix A. N must be at least zero.\\
\hline
\mbox{\tt in}  & {\em L} & Order of triangle within the matrix A (L specifies the shape of the matrix A; see further details).\\
\hline
\mbox{\tt in}  & {\em A\+L\+P\+H\+A} & Scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & Array of size L\+D\+A-\/by-\/\+N. On entry, the leading M by N part of the array A must contain the matrix of coefficients.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & Leading dimension of array A.\\
\hline
\mbox{\tt in}  & {\em X} & On entry, the incremented array X must contain the vector x.\\
\hline
\mbox{\tt in}  & {\em I\+N\+C\+X} & Increment for the elements of X. I\+N\+C\+X must not be zero.\\
\hline
\mbox{\tt in}  & {\em B\+E\+T\+A} & Scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em Y} & On entry, the incremented array Y must contain the vector y.\\
\hline
\mbox{\tt out}  & {\em I\+N\+C\+Y} & Increment for the elements of Y. I\+N\+C\+Y must not be zero.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size at least L.\\
\hline
\end{DoxyParams}
\subsection*{Further Details }

\begin{DoxyVerb}         |     N    |
      _   ___________   _
         |          |
\end{DoxyVerb}
 A\+: $\vert$ $\vert$ M-\/\+L $\vert$ $\vert$ $\vert$ $\vert$ M \+\_\+ $\vert$..... $\vert$ \textbackslash{} \+: $\vert$ L \textbackslash{} \+: $\vert$ \+\_\+ \textbackslash{}\+:\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+

$\vert$ L $\vert$ N-\/\+L $\vert$

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga7a8e1da6cc07180d0ff5fd4d01782121_ga7a8e1da6cc07180d0ff5fd4d01782121}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cplghe@{C\+O\+R\+E\+\_\+cplghe}}
\index{C\+O\+R\+E\+\_\+cplghe@{C\+O\+R\+E\+\_\+cplghe}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cplghe}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cplghe (
\begin{DoxyParamCaption}
\item[{float}]{bump, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda, }
\item[{int}]{g\+M, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{unsigned long long int}]{seed}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga7a8e1da6cc07180d0ff5fd4d01782121_ga7a8e1da6cc07180d0ff5fd4d01782121}
C\+O\+R\+E\+\_\+cplgsy generates an hermitian matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em bump} & Scalar added to the diagonal of the full Matrix A to make it diagonal dominant.\\
\hline
\mbox{\tt in}  & {\em m} & The number of rows of the tile A. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the tile A. n $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the m-\/by-\/n tile to be initialized. On exit, the tile initialized in the mtxtype format.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the tile A. lda $>$= max(1,m).\\
\hline
\mbox{\tt in}  & {\em g\+M} & The global number of rows of the full matrix, A is belonging to. g\+M $>$= (m0+\+M).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em seed} & The seed used for random generation. Must be the same for all tiles initialized with this routine. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gae322390ce2e35aadcda2acacecd7cc9b_gae322390ce2e35aadcda2acacecd7cc9b}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cplgsy@{C\+O\+R\+E\+\_\+cplgsy}}
\index{C\+O\+R\+E\+\_\+cplgsy@{C\+O\+R\+E\+\_\+cplgsy}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cplgsy}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cplgsy (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{bump, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda, }
\item[{int}]{g\+M, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{unsigned long long int}]{seed}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gae322390ce2e35aadcda2acacecd7cc9b_gae322390ce2e35aadcda2acacecd7cc9b}
C\+O\+R\+E\+\_\+cplgsy generates a symmetric matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em bump} & Scalar added to the diagonal of the full Matrix A to make it diagonal dominant.\\
\hline
\mbox{\tt in}  & {\em m} & The number of rows of the tile A. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the tile A. n $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the m-\/by-\/n tile to be initialized. On exit, the tile initialized in the mtxtype format.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the tile A. lda $>$= max(1,m).\\
\hline
\mbox{\tt in}  & {\em g\+M} & The global number of rows of the full matrix, A is belonging to. g\+M $>$= (m0+\+M).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em seed} & The seed used for random generation. Must be the same for all tiles initialized with this routine. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga7ae8308bfdf4f12a4b07edacf0b9b4a7_ga7ae8308bfdf4f12a4b07edacf0b9b4a7}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cplrnt@{C\+O\+R\+E\+\_\+cplrnt}}
\index{C\+O\+R\+E\+\_\+cplrnt@{C\+O\+R\+E\+\_\+cplrnt}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cplrnt}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cplrnt (
\begin{DoxyParamCaption}
\item[{int}]{m, }
\item[{int}]{n, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda, }
\item[{int}]{g\+M, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{unsigned long long int}]{seed}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga7ae8308bfdf4f12a4b07edacf0b9b4a7_ga7ae8308bfdf4f12a4b07edacf0b9b4a7}
C\+O\+R\+E\+\_\+cplrnt generates a random tile.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & The number of rows of the tile A. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the tile A. n $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the m-\/by-\/n tile to be initialized. On exit, the tile initialized in the mtxtype format.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the tile A. lda $>$= max(1,m).\\
\hline
\mbox{\tt in}  & {\em g\+M} & The global number of rows of the full matrix, A is belonging to. g\+M $>$= (m0+\+M).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em seed} & The seed used for random generation. Must be the same for all tiles initialized with this routine. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga7fe65a820c911adce00227a128567766_ga7fe65a820c911adce00227a128567766}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cpltmg@{C\+O\+R\+E\+\_\+cpltmg}}
\index{C\+O\+R\+E\+\_\+cpltmg@{C\+O\+R\+E\+\_\+cpltmg}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cpltmg}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cpltmg (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{mtxtype, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int}]{g\+M, }
\item[{int}]{g\+N, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{unsigned long long int}]{seed}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga7fe65a820c911adce00227a128567766_ga7fe65a820c911adce00227a128567766}
C\+O\+R\+E\+\_\+cpltmg initialize a tile of a random matrix from the Mat\+Lab gallery configured with the default parameters, and a few other specific matrices.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em mtxtype} & Possible types are\+: Plasma\+Matrix\+Random, Plasma\+Matrix\+Hadamard, Plasma\+Matrix\+Parter, Plasma\+Matrix\+Ris, Plasma\+Matrix\+Kms, Plasma\+Matrix\+Moler, Plasma\+Matrix\+Compan, Plasma\+Matrix\+Riemann, Plasma\+Matrix\+Lehmer, Plasma\+Matrix\+Minij, Plasma\+Matrix\+Dorr, Plasma\+Matrix\+Demmel, Plasma\+Matrix\+Invhess, Plasma\+Matrix\+Cauchy, Plasma\+Matrix\+Hilb, Plasma\+Matrix\+Lotkin, Plasma\+Matrix\+Orthog, Plasma\+Matrix\+Wilkinson, Plasma\+Matrix\+Foster, Plasma\+Matrix\+Wright, Plasma\+Matrix\+Langou (See further in the code for more details)\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized. On exit, the tile initialized in the mtxtype format.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em g\+M} & The global number of rows of the full matrix, A is belonging to. g\+M $>$= (m0+\+M).\\
\hline
\mbox{\tt in}  & {\em g\+N} & The global number of columns of the full matrix, A is belonging to. g\+N $>$= (n0+g\+N).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em seed} & The seed used for random generation. Must be the same for all tiles initialized with this routine.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga9a7cfbd866be2bca2d26375bc6766d8a_ga9a7cfbd866be2bca2d26375bc6766d8a}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cpltmg\+\_\+chebvand@{C\+O\+R\+E\+\_\+cpltmg\+\_\+chebvand}}
\index{C\+O\+R\+E\+\_\+cpltmg\+\_\+chebvand@{C\+O\+R\+E\+\_\+cpltmg\+\_\+chebvand}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cpltmg\+\_\+chebvand}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cpltmg\+\_\+chebvand (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int}]{g\+N, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga9a7cfbd866be2bca2d26375bc6766d8a_ga9a7cfbd866be2bca2d26375bc6766d8a}
C\+O\+R\+E\+\_\+cpltmg\+\_\+chebvand is a kernel used in Vandermonde-\/like matrix generation

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-999859}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/999859}

Vandermonde-\/like matrix for the Chebyshev polynomials

Produces the (primal) Chebyshev Vandermonde matrix based on the vector of points p, which define where the Chebyshev polynomial is calculated.

If seed != 0, C(i,j) = Ti  1(p(j)) where Ti  1 is the Chebyshev polynomial of degree i  1, and p is a vector of N equally spaced points on the interval \mbox{[}0,1\mbox{]}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A to initialize. M $>$= 2.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A to initialize. N $>$= 0.\\
\hline
\mbox{\tt out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized. On exit, each element of A is defined by\+: A(i,j) = Ti  1(p(j)) where Ti  1 is the Chebyshev polynomial of degree i  1\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em g\+N} & The global number of columns of the full matrix, A is belonging to. g\+N $>$= (n0+g\+N).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em g\+N} & The global number of columns of the full matrix, A is belonging to. g\+N $>$= (n0+g\+N).\\
\hline
\mbox{\tt in,out}  & {\em W} & Workspace of size 2-\/by-\/\+N, that contains the N triplets\+: ( A( m0-\/2, j), A(m0-\/1, j) ) On entry, if m == 0, W is uinitialized, otherwise contains the data described above. On exit, contains the triplets ( A(m0+\+M-\/2, j), A(m0+\+M-\/1, j) )\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga90d60bf2517ad64e6d1bf64254ac929d_ga90d60bf2517ad64e6d1bf64254ac929d}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cpltmg\+\_\+circul@{C\+O\+R\+E\+\_\+cpltmg\+\_\+circul}}
\index{C\+O\+R\+E\+\_\+cpltmg\+\_\+circul@{C\+O\+R\+E\+\_\+cpltmg\+\_\+circul}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cpltmg\+\_\+circul}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cpltmg\+\_\+circul (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int}]{g\+M, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga90d60bf2517ad64e6d1bf64254ac929d_ga90d60bf2517ad64e6d1bf64254ac929d}
C\+O\+R\+E\+\_\+cpltmg\+\_\+circul is a kernel used in circulant matrix generation

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-999880}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/999880}

Circulant matrix

A circulant matrix has the property that each row is obtained from the previous one by cyclically permuting the entries one step forward. It is a special Toeplitz matrix in which the diagonals \char`\"{}wrap around.\char`\"{}

The eigensystem of C (n-\/by-\/n) is known explicitly\+: If t is an nth root of unity, then the inner product of v and w = \mbox{[}1 t t2 ... t(n  1)\mbox{]} is an eigenvalue of C and w(n\+:-\/1\+:1) is an eigenvector, where v is the first column of C.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A to initialize. M $>$= 2.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A to initialize. N $>$= 0.\\
\hline
\mbox{\tt out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em g\+M} & The global number of rows of the full matrix, A is belonging to. g\+M $>$= (m0+g\+M).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em V} & Workspace of size g\+M, that contains the first clumn of the full matrix\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gad81007d6e27dcb18279f6fd52b823157_gad81007d6e27dcb18279f6fd52b823157}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cpltmg\+\_\+condexq@{C\+O\+R\+E\+\_\+cpltmg\+\_\+condexq}}
\index{C\+O\+R\+E\+\_\+cpltmg\+\_\+condexq@{C\+O\+R\+E\+\_\+cpltmg\+\_\+condexq}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cpltmg\+\_\+condexq}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cpltmg\+\_\+condexq (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{Q, }
\item[{int}]{L\+D\+Q}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gad81007d6e27dcb18279f6fd52b823157_gad81007d6e27dcb18279f6fd52b823157}
C\+O\+R\+E\+\_\+cpltmg\+\_\+condexq generates the Q used in condex matrix generation

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-999898}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/999898} gallery(\textquotesingle{}condex\textquotesingle{},n,4,100)

Returns a \char`\"{}counter-\/example\char`\"{} matrix to a condition estimator. It has order n and scalar parameter theta (default 100).

L\+A\+P\+A\+C\+K (R\+C\+O\+N\+D)\+: It is the inverse of this matrix that is a counter-\/example.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the matrix Q used in condex generation. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A to be generated. N $>$= 0.\\
\hline
\mbox{\tt out}  & {\em Q} & On entry, the M-\/by-\/3 matrix to be initialized. On exit, the housholder reflectors required for condex generation.\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & The leading dimension of the matrix Q. L\+D\+Q $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gab1b369f8dae16a9ad1a6479f7566d0a6_gab1b369f8dae16a9ad1a6479f7566d0a6}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cpltmg\+\_\+fiedler@{C\+O\+R\+E\+\_\+cpltmg\+\_\+fiedler}}
\index{C\+O\+R\+E\+\_\+cpltmg\+\_\+fiedler@{C\+O\+R\+E\+\_\+cpltmg\+\_\+fiedler}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cpltmg\+\_\+fiedler}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cpltmg\+\_\+fiedler (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{X, }
\item[{int}]{inc\+X, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{Y, }
\item[{int}]{inc\+Y, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gab1b369f8dae16a9ad1a6479f7566d0a6_gab1b369f8dae16a9ad1a6479f7566d0a6}
C\+O\+R\+E\+\_\+cpltmg\+\_\+fiedler is a kernel used in fiedler matrix generation

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-999960}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/999960}

Fiedler matrix of size n-\/by-\/n is defined throug a random vector c of size n, such that each element is equal to abs(n(i)-\/n(j)).

Matrix A has a dominant positive eigenvalue and all the other eigenvalues are negative.

Explicit formulas for inv(\+A) and det(\+A) are given in \mbox{[}Todd, J., Basic Numerical Mathematics, Vol. 2\+: Numerical Algebra, Birkhauser, Basel, and Academic Press, New York, 1977, p. 159\mbox{]} and attributed to Fiedler. These indicate that inv(\+A) is tridiagonal except for nonzero (1,n) and (n,1) elements.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A to initialize. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A to initialize. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em X} & X is a vector of dimension at least\+: ( 1 + ( M -\/ 1 )$\ast$abs( inc\+X ) ) On entry, the vector used to initialize A.\\
\hline
\mbox{\tt in}  & {\em inc\+X} & On entry, inc\+X specifies the increment for the elements of X. inc\+X != 0.\\
\hline
\mbox{\tt in}  & {\em Y} & Y is a vector of dimension at least\+: ( 1 + ( N -\/ 1 )$\ast$abs( inc\+Y ) ) On entry, the vector used to initialize A.\\
\hline
\mbox{\tt in}  & {\em inc\+Y} & On entry, inc\+Y specifies the increment for the elements of Y. inc\+Y != 0.\\
\hline
\mbox{\tt out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized. On exit, each element of A is defined by\+: A(i,j) = abs( X(i) -\/ Y(j) )\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga29113f4eaa98eeaa73019e2bef97b589_ga29113f4eaa98eeaa73019e2bef97b589}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cpltmg\+\_\+hankel@{C\+O\+R\+E\+\_\+cpltmg\+\_\+hankel}}
\index{C\+O\+R\+E\+\_\+cpltmg\+\_\+hankel@{C\+O\+R\+E\+\_\+cpltmg\+\_\+hankel}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cpltmg\+\_\+hankel}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cpltmg\+\_\+hankel (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{int}]{nb, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V1, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V2}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga29113f4eaa98eeaa73019e2bef97b589_ga29113f4eaa98eeaa73019e2bef97b589}
C\+O\+R\+E\+\_\+cpltmg\+\_\+hankel is a kernel used in Hankel matrix generation

See \href{http://en.wikipedia.org/wiki/Hankel_matrix}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Hankel\+\_\+matrix}

Hankel matrix

In linear algebra, a Hankel matrix (or catalecticant matrix), named after Hermann Hankel, is a square matrix with constant skew-\/diagonals (positive sloping diagonals), e.\+g.\+:

\[ \begin{bmatrix} a & b & c & d & e \\ b & c & d & e & f \\ c & d & e & f & g \\ d & e & f & g & h \\ e & f & g & h & i \\ \end{bmatrix} \].

A(i,j) = A(i-\/1,j+1)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies the part of the matrix A to be initialized. = Plasma\+Upper\+Lower\+: All the matrix A = Plasma\+Upper\+: Upper triangular part = Plasma\+Lower\+: Lower triangular part\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the tile A to initialize. M $>$= 2.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A to initialize. N $>$= 0.\\
\hline
\mbox{\tt out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The size of the V1 and V2 vectors\\
\hline
\mbox{\tt in}  & {\em V1} & Workspace of size nb, that contains the first column of the tile\\
\hline
\mbox{\tt in}  & {\em V2} & Workspace of size nb), that contains the last column of the tile\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga9c06098441579548f5ca4c3a2a60f376_ga9c06098441579548f5ca4c3a2a60f376}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd1@{C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd1}}
\index{C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd1@{C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd1}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd1}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd1 (
\begin{DoxyParamCaption}
\item[{int}]{g\+M, }
\item[{int}]{m0, }
\item[{int}]{M, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W, }
\item[{unsigned long long int}]{seed}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga9c06098441579548f5ca4c3a2a60f376_ga9c06098441579548f5ca4c3a2a60f376}
C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd1 is the first kernel used in toeppd matrix generation.

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-1000272}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/1000272}

A toeppd matrix is an n-\/by-\/n symmetric, positive semi-\/definite (S\+P\+D) Toeplitz matrix composed of the sum of m rank 2 (or, for certain theta, rank 1) S\+P\+D Toeplitz matrices. Specifically,

T = w(1)$\ast$\+T(theta(1)) + ... + w(m)$\ast$\+T(theta(m))

where T(theta(k)) has (i,j) element cos(2$\ast$pi$\ast$theta(k)$\ast$(i-\/j)).

In this matrix generation\+: w = rand(m,1), and theta = rand(m,1).

This kernel generates a portion of size 2-\/by-\/m of the full W and theta vectors.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em g\+M} & The size of the full vectors W and theta. g\+M $>$= M+m0.\\
\hline
\mbox{\tt in}  & {\em m0} & Index of the first element of W, in the full vector. m0 $>$= 0\\
\hline
\mbox{\tt in}  & {\em M} & The number of elements to generate for w and theta vector. M $>$= 0.\\
\hline
\mbox{\tt out}  & {\em W} & An 2-\/by-\/\+M matrix. On exit, the first row contains the walue of w\mbox{[}m0;m0+\+M\mbox{]} The second row contains the vector 2$\ast$pi$\ast$theta\mbox{[}m0;m0+\+M\mbox{]}\\
\hline
\mbox{\tt in}  & {\em seed} & The seed used for random generation. Must be the same for all call to this routines generating the w and theta vectors. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga838d82deafcbbf70e56b5464ee0e7538_ga838d82deafcbbf70e56b5464ee0e7538}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd2@{C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd2}}
\index{C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd2@{C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd2}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd2}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd2 (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga838d82deafcbbf70e56b5464ee0e7538_ga838d82deafcbbf70e56b5464ee0e7538}
C\+O\+R\+E\+\_\+cpltmg\+\_\+toeppd2 is the first kernel used in toeppd matrix generation.

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-1000272}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/1000272}

A toeppd matrix is an n-\/by-\/n symmetric, positive semi-\/definite (S\+P\+D) Toeplitz matrix composed of the sum of m rank 2 (or, for certain theta, rank 1) S\+P\+D Toeplitz matrices. Specifically,

T = w(1)$\ast$\+T(theta(1)) + ... + w(m)$\ast$\+T(theta(m))

where T(theta(k)) has (i,j) element cos(2$\ast$pi$\ast$theta(k)$\ast$(i-\/j)).

In this matrix generation\+: w = rand(m,1), and theta = rand(m,1).

This kernel adds to the tile A the local sum of\+: w(1)$\ast$\+T(theta(1)) + ... + w(\+K) $\ast$ T(theta(\+K))


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of matrices W() $\ast$ T(theta()) to apply.\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em W} & The 2-\/by-\/\+K array that stores the values of W and 2$\ast$pi$\ast$\+Theta. W being stored on the first row, 2$\ast$pi$\ast$theta on the second.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized with a partial sum of the Toeppliz matrices. On exit, the M-\/by-\/\+N tile update with the sum of K extra Toepplitz matrices\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga8f8839fe52398eb2b469caff40cdacd5_ga8f8839fe52398eb2b469caff40cdacd5}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cpotrf@{C\+O\+R\+E\+\_\+cpotrf}}
\index{C\+O\+R\+E\+\_\+cpotrf@{C\+O\+R\+E\+\_\+cpotrf}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cpotrf}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cpotrf (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga8f8839fe52398eb2b469caff40cdacd5_ga8f8839fe52398eb2b469caff40cdacd5}
C\+O\+R\+E\+\_\+cpotrf -\/ Computes the Cholesky factorization of a symmetric positive definite (or Hermitian positive definite in the complex case) matrix A. The factorization has the form

\[ A = \{_{L\times L^H, if uplo = PlasmaLower}^{U^H\times U, if uplo = PlasmaUpper} \]

where U is an upper triangular matrix and L is a lower triangular matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the symmetric positive definite (or Hermitian) matrix A. If uplo = Plasma\+Upper, the leading N-\/by-\/\+N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If U\+P\+L\+O = \textquotesingle{}L\textquotesingle{}, the leading N-\/by-\/\+N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, if return value = 0, the factor U or L from the Cholesky factorization A = U$\ast$$\ast$\+H$\ast$\+U or A = L$\ast$\+L$\ast$$\ast$\+H.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt out}  & {\em info} & 
\begin{DoxyItemize}
\item 0 on successful exit
\item $<$0 if -\/i, the i-\/th argument had an illegal value
\item $>$0 if i, the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga5a4ce35ecc9ab293e9ac2e87e014600e_ga5a4ce35ecc9ab293e9ac2e87e014600e}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+csetvar@{C\+O\+R\+E\+\_\+csetvar}}
\index{C\+O\+R\+E\+\_\+csetvar@{C\+O\+R\+E\+\_\+csetvar}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+csetvar}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+csetvar (
\begin{DoxyParamCaption}
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{alpha, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{x}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga5a4ce35ecc9ab293e9ac2e87e014600e_ga5a4ce35ecc9ab293e9ac2e87e014600e}
C\+O\+R\+E\+\_\+csetvar sets a single variable, x \+:= alpha.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em alpha} & Scalar to set x to, passed by pointer so it can depend on runtime value.\\
\hline
\mbox{\tt out}  & {\em x} & On exit, x = alpha. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gab0a0a5546fe5684fd80361eda2783551_gab0a0a5546fe5684fd80361eda2783551}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cshiftw@{C\+O\+R\+E\+\_\+cshiftw}}
\index{C\+O\+R\+E\+\_\+cshiftw@{C\+O\+R\+E\+\_\+cshiftw}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cshiftw}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cshiftw (
\begin{DoxyParamCaption}
\item[{int}]{s, }
\item[{int}]{cl, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{int}]{L, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gab0a0a5546fe5684fd80361eda2783551_gab0a0a5546fe5684fd80361eda2783551}




C\+O\+R\+E\+\_\+cshiftw Shift a linear chain of block using a supplied workspace by following the cycle defined by\+: k\+\_\+(i+1) = (k\+\_\+i $\ast$ m) \% q;


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em s} & Start value in the cycle\\
\hline
\mbox{\tt in}  & {\em cl} & Cycle length if cl == 0, all the permutations from the cycle are done else the cycle is split onto several threads and the number of permutation to do has to be specified to not get overlap\\
\hline
\mbox{\tt in}  & {\em m} & Number of lines of tile A\\
\hline
\mbox{\tt in}  & {\em n} & Number of columns of tile A\\
\hline
\mbox{\tt in}  & {\em L} & Length of each block of data to move\\
\hline
\mbox{\tt in,out}  & {\em A} & Matrix of size m-\/by-\/n with each element of size L. On exit, A = A\textquotesingle{}, where A\textquotesingle{} contains the permutations\\
\hline
\mbox{\tt in}  & {\em W} & Array of size L. On entry, must contain\+: W(\+:) = A(s$\ast$\+L\+:s$\ast$\+L+\+L-\/1) \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gacbcf50ddacade063d4e4dd5051cfec30_gacbcf50ddacade063d4e4dd5051cfec30}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cssssm@{C\+O\+R\+E\+\_\+cssssm}}
\index{C\+O\+R\+E\+\_\+cssssm@{C\+O\+R\+E\+\_\+cssssm}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cssssm}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cssssm (
\begin{DoxyParamCaption}
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{L1, }
\item[{int}]{L\+D\+L1, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{L2, }
\item[{int}]{L\+D\+L2, }
\item[{const int $\ast$}]{I\+P\+I\+V}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gacbcf50ddacade063d4e4dd5051cfec30_gacbcf50ddacade063d4e4dd5051cfec30}
C\+O\+R\+E\+\_\+cssssm applies the L\+U factorization update from a complex matrix formed by a lower triangular I\+B-\/by-\/\+K tile L1 on top of a M2-\/by-\/\+K tile L2 to a second complex matrix formed by a M1-\/by-\/\+N1 tile A1 on top of a M2-\/by-\/\+N2 tile A2 (N1 == N2).

This is the right-\/looking Level 2.\+5 B\+L\+A\+S version of the algorithm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of rows of the tile A2 and of the tile L2. M2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of columns of the tile A2. N2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of columns of the tiles L1 and L2. K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is updated by the application of L (L1 L2).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is updated by the application of L (L1 L2).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the array A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em L1} & The I\+B-\/by-\/\+K lower triangular tile as returned by C\+O\+R\+E\+\_\+ctstrf.\\
\hline
\mbox{\tt in}  & {\em L\+D\+L1} & The leading dimension of the array L1. L\+D\+L1 $>$= max(1,\+I\+B).\\
\hline
\mbox{\tt in}  & {\em L2} & The M2-\/by-\/\+K tile as returned by C\+O\+R\+E\+\_\+ctstrf.\\
\hline
\mbox{\tt in}  & {\em L\+D\+L2} & The leading dimension of the array L2. L\+D\+L2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em I\+P\+I\+V} & The pivot indices array of size K as returned by C\+O\+R\+E\+\_\+ctstrf.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gade63ed2cd31cb0e5c0623391bcd78020_gade63ed2cd31cb0e5c0623391bcd78020}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cstedc@{C\+O\+R\+E\+\_\+cstedc}}
\index{C\+O\+R\+E\+\_\+cstedc@{C\+O\+R\+E\+\_\+cstedc}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cstedc}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cstedc (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{compz, }
\item[{int}]{n, }
\item[{float $\ast$}]{D, }
\item[{float $\ast$}]{E, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{Z, }
\item[{int}]{L\+D\+Z, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+W\+O\+R\+K, }
\item[{float $\ast$}]{R\+W\+O\+R\+K, }
\item[{int}]{L\+R\+W\+O\+R\+K, }
\item[{int $\ast$}]{I\+W\+O\+R\+K, }
\item[{int}]{L\+I\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gade63ed2cd31cb0e5c0623391bcd78020_gade63ed2cd31cb0e5c0623391bcd78020}
C\+O\+R\+E\+\_\+cstedc -\/ solves the symmetric tridiagonal eigensystem using Divide \& Conquer


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em compz} & = Plasma\+No\+Vec\+: computes eigenvalues only. = Plasma\+Vec\+: computes eigenpairs of the original symmetric matrix. On entry, Z must contain the orthogonal matrix used to reduce the original matrix to tridiagonal form. = Plasma\+I\+Vec\+: computes eigenpairs of the tridiagonal matrix. Z is initialized to the Identity Matrix.\\
\hline
\mbox{\tt in}  & {\em n} & n specifies the order of the matrix. N $>$= 0\\
\hline
\mbox{\tt in,out}  & {\em D} & On entry, D contains the diagonal elements of the tridiagonal matrix. On exit, D contains the eigenvalues sorted into increasing order.\\
\hline
\mbox{\tt in}  & {\em E} & On entry, E contains the extra-\/diagonal elements of the tridiagonal matrix. On exit, E is destroyed.\\
\hline
\mbox{\tt in,out}  & {\em Z} & On entry, Z has to be set to the Identity matrix. On exit, Z contains the eigenvectors.\\
\hline
\mbox{\tt in}  & {\em L\+D\+Z} & L\+D\+Z specifies the leading direction of Z\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & plasma\+\_\+complex64\+\_\+t workspace\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & Size of plasma\+\_\+complex64\+\_\+t workspace\\
\hline
\mbox{\tt in}  & {\em R\+W\+O\+R\+K} & workspace\\
\hline
\mbox{\tt in}  & {\em L\+R\+W\+O\+R\+K} & Size of float workspace\\
\hline
\mbox{\tt in}  & {\em I\+W\+O\+R\+K} & Integer workspace\\
\hline
\mbox{\tt in}  & {\em L\+I\+W\+O\+R\+K} & Size of integer workspace\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gacc1980ec0484bb5269932a4f1c2bf7d1_gacc1980ec0484bb5269932a4f1c2bf7d1}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+csteqr@{C\+O\+R\+E\+\_\+csteqr}}
\index{C\+O\+R\+E\+\_\+csteqr@{C\+O\+R\+E\+\_\+csteqr}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+csteqr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+csteqr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{compz, }
\item[{int}]{n, }
\item[{float $\ast$}]{D, }
\item[{float $\ast$}]{E, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{Z, }
\item[{int}]{L\+D\+Z, }
\item[{float $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gacc1980ec0484bb5269932a4f1c2bf7d1_gacc1980ec0484bb5269932a4f1c2bf7d1}
C\+O\+R\+E\+\_\+csteqr -\/ solves the symmetric tridiagonal eigensystem using Q\+R


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em compz} & = Plasma\+No\+Vec\+: computes eigenvalues only. = Plasma\+Vec\+: computes eigenpairs of the original symmetric matrix. On entry, Z must contain the orthogonal matrix used to reduce the original matrix to tridiagonal form. = Plasma\+I\+Vec\+: computes eigenpairs of the tridiagonal matrix. Z is initialized to the Identity Matrix.\\
\hline
\mbox{\tt in}  & {\em n} & n specifies the order of the matrix. N $>$= 0\\
\hline
\mbox{\tt in,out}  & {\em D} & On entry, D contains the diagonal elements of the tridiagonal matrix. On exit, D contains the eigenvalues sorted into increasing order.\\
\hline
\mbox{\tt in}  & {\em E} & On entry, E contains the extra-\/diagonal elements of the tridiagonal matrix. On exit, E is destroyed.\\
\hline
\mbox{\tt in,out}  & {\em Z} & On entry, Z has to be set to the Identity matrix. On exit, Z contains the eigenvectors.\\
\hline
\mbox{\tt in}  & {\em L\+D\+Z} & L\+D\+Z specifies the leading direction of Z\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & Workspace.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga5a34d585eb419bdfbad7618373628dee_ga5a34d585eb419bdfbad7618373628dee}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cswap@{C\+O\+R\+E\+\_\+cswap}}
\index{C\+O\+R\+E\+\_\+cswap@{C\+O\+R\+E\+\_\+cswap}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cswap}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cswap (
\begin{DoxyParamCaption}
\item[{int}]{m, }
\item[{int}]{n, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{Q, }
\item[{int}]{ldq, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{work, }
\item[{const int $\ast$}]{perm, }
\item[{int}]{start, }
\item[{int}]{end}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga5a34d585eb419bdfbad7618373628dee_ga5a34d585eb419bdfbad7618373628dee}
C\+O\+R\+E\+\_\+cswap -\/ Extract the eigenvectors in the range \mbox{[}start,end-\/1\mbox{]} from work and copy them in order into the Q matrix thanks to the given permutation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & m specifies the number of entries in each eigenvector, i.\+e. the number of rows of the matrices Q and Work.\\
\hline
\mbox{\tt in}  & {\em n} & n specifies the number of eigenvectors to copy from work to Q, i.\+e. the number of columns of the matrices W and work.\\
\hline
\mbox{\tt out}  & {\em Q} & On entry, matrix of size L\+D\+Q -\/by-\/ n. On exit, Q will contain the n sorted eigenvectors.\\
\hline
\mbox{\tt in}  & {\em ldq} & ldq specifies the leading dimension of Q. ldq $>$= max(1,m)\\
\hline
\mbox{\tt in}  & {\em work} & On entry work contains the non-\/sorted eigenvectors and is of dimension m-\/by-\/n.\\
\hline
\mbox{\tt in}  & {\em perm} & The permutation array used to copy work into Q. On entry, the i-\/th eigenvector is stored in the column perm\mbox{[}i\mbox{]} of work, and is copied to the i-\/th column of Q.\\
\hline
\mbox{\tt in}  & {\em start} & start specifies the first column index to be considered by this kernel.\\
\hline
\mbox{\tt in}  & {\em end} & end specifies the last column index to be considered by this kernel \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaf6ebd36cbbb1b5fa7edb0499df48742d_gaf6ebd36cbbb1b5fa7edb0499df48742d}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cswpab@{C\+O\+R\+E\+\_\+cswpab}}
\index{C\+O\+R\+E\+\_\+cswpab@{C\+O\+R\+E\+\_\+cswpab}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cswpab}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+cswpab (
\begin{DoxyParamCaption}
\item[{int}]{i, }
\item[{int}]{n1, }
\item[{int}]{n2, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{work}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaf6ebd36cbbb1b5fa7edb0499df48742d_gaf6ebd36cbbb1b5fa7edb0499df48742d}




C\+O\+R\+E\+\_\+cswpab swaps two adjacent contiguous blocks of data. \begin{DoxyVerb}n1                     n2
\end{DoxyVerb}
 +-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+

become \+: n2 n1 +-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em A} & Array of size i+n1+n2. On entry, a block of size n1 followed by a block of size n2. On exit, the block of size n1 follows the block of size n2.\\
\hline
\mbox{\tt in}  & {\em i} & First block starts at A\mbox{[}i\mbox{]}.\\
\hline
\mbox{\tt in}  & {\em n1} & Size of the first block to swap.\\
\hline
\mbox{\tt in}  & {\em n2} & Size of the second block to swap.\\
\hline
\mbox{\tt out}  & {\em work} & Workspace array of size min(n1, n2). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaf715646956e16c2ad05d66b58fc8ffad_gaf715646956e16c2ad05d66b58fc8ffad}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cswptr\+\_\+ontile@{C\+O\+R\+E\+\_\+cswptr\+\_\+ontile}}
\index{C\+O\+R\+E\+\_\+cswptr\+\_\+ontile@{C\+O\+R\+E\+\_\+cswptr\+\_\+ontile}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cswptr\+\_\+ontile}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cswptr\+\_\+ontile (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{desc\+A, }
\item[{int}]{i1, }
\item[{int}]{i2, }
\item[{const int $\ast$}]{ipiv, }
\item[{int}]{inc, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{Akk, }
\item[{int}]{ldak}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaf715646956e16c2ad05d66b58fc8ffad_gaf715646956e16c2ad05d66b58fc8ffad}
C\+O\+R\+E\+\_\+cswptr\+\_\+ontile apply the claswp function on a matrix stored in tile layout, followed by a ctrsm on the first tile of the panel.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em desc\+A} & The descriptor of the matrix A to permute.\\
\hline
\mbox{\tt in}  & {\em i1} & The first element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em i2} & The last element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em ipiv} & The pivot indices; Only the element in position i1 to i2 are accessed. The pivot are offset by A.\+i.\\
\hline
\mbox{\tt in}  & {\em inc} & The increment between successive values of I\+P\+I\+V. If I\+P\+I\+V is negative, the pivots are applied in reverse order.\\
\hline
\mbox{\tt in}  & {\em Akk} & The triangular matrix Akk. The leading desc\+A.\+nb-\/by-\/desc\+A.\+nb lower triangular part of the array Akk contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. The diagonal elements of A are also not referenced and are assumed to be 1.\\
\hline
\mbox{\tt in}  & {\em ldak} & The leading dimension of the array Akk. ldak $>$= max(1,desc\+A.\+nb).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga9ee60d99c109d72f762ee69bff8f9612_ga9ee60d99c109d72f762ee69bff8f9612}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+csymm@{C\+O\+R\+E\+\_\+csymm}}
\index{C\+O\+R\+E\+\_\+csymm@{C\+O\+R\+E\+\_\+csymm}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+csymm}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+csymm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{beta, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C, }
\item[{int}]{L\+D\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga9ee60d99c109d72f762ee69bff8f9612_ga9ee60d99c109d72f762ee69bff8f9612}
C\+O\+R\+E\+\_\+csymm -\/ Performs one of the matrix-\/matrix operations

\[ C = \alpha \times A \times B + \beta \times C \]

or

\[ C = \alpha \times B \times A + \beta \times C \]

where alpha and beta are scalars, A is an symmetric matrix and B and C are m by n matrices.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & Specifies whether the symmetric matrix A appears on the left or right in the operation as follows\+: = Plasma\+Left\+: \[ C = \alpha \times A \times B + \beta \times C \] = Plasma\+Right\+: \[ C = \alpha \times B \times A + \beta \times C \]\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the upper or lower triangular part of the symmetric matrix A is to be referenced as follows\+: = Plasma\+Lower\+: Only the lower triangular part of the symmetric matrix A is to be referenced. = Plasma\+Upper\+: Only the upper triangular part of the symmetric matrix A is to be referenced.\\
\hline
\mbox{\tt in}  & {\em M} & Specifies the number of rows of the matrix C. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & Specifies the number of columns of the matrix C. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & Specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is a L\+D\+A-\/by-\/ka matrix, where ka is M when side = Plasma\+Left, and is N otherwise. Only the uplo triangular part is referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,ka).\\
\hline
\mbox{\tt in}  & {\em B} & B is a L\+D\+B-\/by-\/\+N matrix, where the leading M-\/by-\/\+N part of the array B must contain the matrix B.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em beta} & Specifies the scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is a L\+D\+C-\/by-\/\+N matrix. On exit, the array is overwritten by the M by N updated matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga9e353ab4959d266c3d7dec7e8fe39f6b_ga9e353ab4959d266c3d7dec7e8fe39f6b}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+csyr2k@{C\+O\+R\+E\+\_\+csyr2k}}
\index{C\+O\+R\+E\+\_\+csyr2k@{C\+O\+R\+E\+\_\+csyr2k}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+csyr2k}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+csyr2k (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{beta, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C, }
\item[{int}]{L\+D\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga9e353ab4959d266c3d7dec7e8fe39f6b_ga9e353ab4959d266c3d7dec7e8fe39f6b}
C\+O\+R\+E\+\_\+csyr2k -\/ Performs one of the symmetric rank 2k operations

\[ C = \alpha [ op( A ) \times conjfg( op( B )' )] + \alpha [ op( B ) \times conjfg( op( A )' )] + \beta C \], or \[ C = \alpha [ conjfg( op( A )' ) \times op( B ) ] + \alpha [ conjfg( op( B )' ) \times op( A ) ] + \beta C \],

where op( X ) is one of

op( X ) = X or op( X ) = conjfg( X\textquotesingle{} )

where alpha and beta are real scalars, C is an n-\/by-\/n symmetric matrix and A and B are an n-\/by-\/k matrices the first case and k-\/by-\/n matrices in the second case.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of C is stored; = Plasma\+Lower\+: Lower triangle of C is stored.\\
\hline
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is transposed or conjfugate transposed\+: = Plasma\+No\+Trans\+: \[ C = \alpha [ op( A ) \times conjfg( op( B )' )] + \alpha [ op( B ) \times conjfg( op( A )' )] + \beta C \] = Plasma\+Trans\+: \[ C = \alpha [ conjfg( op( A )' ) \times op( B ) ] + \alpha [ conjfg( op( B )' ) \times op( A ) ] + \beta C \]\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the order of the matrix C. N must be at least zero.\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of columns of the A and B matrices with trans = Plasma\+No\+Trans. K specifies the number of rows of the A and B matrices with trans = Plasma\+Trans.\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is a L\+D\+A-\/by-\/ka matrix, where ka is K when trans = Plasma\+No\+Trans, and is N otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A must be at least max( 1, N ), otherwise L\+D\+A must be at least max( 1, K ).\\
\hline
\mbox{\tt in}  & {\em B} & B is a L\+D\+B-\/by-\/kb matrix, where kb is K when trans = Plasma\+No\+Trans, and is N otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B must be at least max( 1, N ), otherwise L\+D\+B must be at least max( 1, K ).\\
\hline
\mbox{\tt in}  & {\em beta} & beta specifies the scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is a L\+D\+C-\/by-\/\+N matrix. On exit, the array uplo part of the matrix is overwritten by the uplo part of the updated matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max( 1, N ). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gab533c4d2ce945cd525c45a1de9f54a10_gab533c4d2ce945cd525c45a1de9f54a10}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+csyrk@{C\+O\+R\+E\+\_\+csyrk}}
\index{C\+O\+R\+E\+\_\+csyrk@{C\+O\+R\+E\+\_\+csyrk}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+csyrk}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+csyrk (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{beta, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C, }
\item[{int}]{L\+D\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gab533c4d2ce945cd525c45a1de9f54a10_gab533c4d2ce945cd525c45a1de9f54a10}
C\+O\+R\+E\+\_\+csyrk -\/ Performs one of the hermitian rank k operations

\[ C = \alpha [ op( A ) \times conjfg( op( A )' )] + \beta C \],

where op( X ) is one of

op( X ) = X or op( X ) = conjfg( X\textquotesingle{} )

where alpha and beta are real scalars, C is an n-\/by-\/n hermitian matrix and A is an n-\/by-\/k matrix in the first case and a k-\/by-\/n matrix in the second case.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of C is stored; = Plasma\+Lower\+: Lower triangle of C is stored.\\
\hline
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is transposed or conjfugate transposed\+: = Plasma\+No\+Trans\+: A is not transposed; = Plasma\+Trans \+: A is transposed.\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the order of the matrix C. N must be at least zero.\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of columns of the matrix op( A ).\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is a L\+D\+A-\/by-\/ka matrix, where ka is K when trans = Plasma\+No\+Trans, and is N otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A must be at least max( 1, N ) if trans == Plasma\+No\+Trans, otherwise L\+D\+A must be at least max( 1, K ).\\
\hline
\mbox{\tt in}  & {\em beta} & beta specifies the scalar beta\\
\hline
\mbox{\tt in,out}  & {\em C} & C is a L\+D\+C-\/by-\/\+N matrix. On exit, the array uplo part of the matrix is overwritten by the uplo part of the updated matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max( 1, N ). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga59754c7bb4987c113f48539326740534_ga59754c7bb4987c113f48539326740534}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctradd@{C\+O\+R\+E\+\_\+ctradd}}
\index{C\+O\+R\+E\+\_\+ctradd@{C\+O\+R\+E\+\_\+ctradd}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctradd}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+ctradd (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{beta, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga59754c7bb4987c113f48539326740534_ga59754c7bb4987c113f48539326740534}
C\+O\+R\+E\+\_\+ctradd adds two matrices together as in P\+B\+L\+A\+S pctradd. \begin{DoxyVerb} B <- alpha * op(A)  + beta * B,
\end{DoxyVerb}


where op(\+X) = X, X\textquotesingle{}, or conjf(X\textquotesingle{})


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies the shape of A and B matrices\+: = Plasma\+Upper\+Lower\+: A and B are general matrices. = Plasma\+Upper\+: op(\+A) and B are upper trapezoidal matrices. = Plasma\+Lower\+: op(\+A) and B are lower trapezoidal matrices.\\
\hline
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is non-\/transposed, transposed, or conjfugate transposed = Plasma\+No\+Trans\+: op(\+A) = A = Plasma\+Trans\+: op(\+A) = A\textquotesingle{} = Plasma\+Conj\+Trans\+: op(\+A) = conjf(A\textquotesingle{})\\
\hline
\mbox{\tt in}  & {\em M} & Number of rows of the matrices A and B.\\
\hline
\mbox{\tt in}  & {\em N} & Number of columns of the matrices A and B.\\
\hline
\mbox{\tt in}  & {\em alpha} & Scalar factor of A.\\
\hline
\mbox{\tt in}  & {\em A} & Matrix of size L\+D\+A-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & Leading dimension of the array A. L\+D\+A $>$= max(1,\+M)\\
\hline
\mbox{\tt in}  & {\em beta} & Scalar factor of B.\\
\hline
\mbox{\tt in,out}  & {\em B} & Matrix of size L\+D\+B-\/by-\/\+N. On exit, B = alpha $\ast$ op(\+A) + beta $\ast$ B\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & Leading dimension of the array B. L\+D\+B $>$= max(1,\+M)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
Plasma\+Lower

Plasma\+Upper\hypertarget{group__CORE__PLASMA__Complex32__t_gada4c6647fe7897a5592b3697784313ec_gada4c6647fe7897a5592b3697784313ec}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctrasm@{C\+O\+R\+E\+\_\+ctrasm}}
\index{C\+O\+R\+E\+\_\+ctrasm@{C\+O\+R\+E\+\_\+ctrasm}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctrasm}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+ctrasm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{storev, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{diag, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda, }
\item[{float $\ast$}]{work}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gada4c6647fe7897a5592b3697784313ec_gada4c6647fe7897a5592b3697784313ec}
C\+O\+R\+E\+\_\+ctrasm -\/ Computes the sums of the absolute values of elements in a same row or column in a triangular matrix. This function is an auxiliary function to triangular matrix norm computations.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em storev} & Specifies whether the sums are made per column or row. = Plasma\+Columnwise\+: Computes the sum on each column = Plasma\+Rowwise\+: Computes the sum on each row\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular = Plasma\+Upper\+: Upper triangle of A is referenced; = Plasma\+Lower\+: Lower triangle of A is referenced.\\
\hline
\mbox{\tt in}  & {\em diag} & Specifies whether or not A is unit triangular\+: = Plasma\+Non\+Unit\+: A is non unit; = Plasma\+Unit\+: A us unit.\\
\hline
\mbox{\tt in}  & {\em M} & M specifies the number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & A is a M-\/by-\/\+N matrix.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. lda $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em work} & Array of dimension M if storev = Plasma\+Rowwise; N otherwise. On exit, contains the sums of the absolute values per column or row added to the input values. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga7f5683151b1259a07e742af5dfbb98c9_ga7f5683151b1259a07e742af5dfbb98c9}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctrdalg1@{C\+O\+R\+E\+\_\+ctrdalg1}}
\index{C\+O\+R\+E\+\_\+ctrdalg1@{C\+O\+R\+E\+\_\+ctrdalg1}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctrdalg1}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+ctrdalg1 (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{int}]{nb, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{int}]{Vblksiz, }
\item[{int}]{wantz, }
\item[{int}]{i, }
\item[{int}]{sweepid, }
\item[{int}]{m, }
\item[{int}]{grsiz, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{work}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga7f5683151b1259a07e742af5dfbb98c9_ga7f5683151b1259a07e742af5dfbb98c9}
C\+O\+R\+E\+\_\+ctrdalg1 is a part of the tridiagonal reduction algorithm (bulgechasing) It correspond to a local driver of the kernels that should be executed on a single core.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & The order of the matrix A. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The size of the Bandwidth of the matrix A, which correspond to the tile size. nb $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (lda,n) On entry, the (nb+1)-\/by-\/n band lower hermetian matrix to be reduced to tridiagonal. On exit, the diagonal and first subdiagonal of A are over-\/ written by the corresponding elements of the tridiagonal.\\
\hline
\mbox{\tt in}  & {\em lda} & (input) I\+N\+T\+E\+G\+E\+R The leading dimension of the array A. L\+D\+A $>$= max(1,nb+1).\\
\hline
\mbox{\tt out}  & {\em V} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (n) if wantz=0 or ldv$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar elementary reflectors are written in this array.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t array, dimension (n) if wantz=0 or Vblksiz$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar factors of the elementary reflectors are written in this array.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & Local parameter to Plasma. It correspond to the local bloccking of the apply\+Q2 used to apply the orthogonal matrix Q2.\\
\hline
\mbox{\tt in}  & {\em wantz} & integer tobe 0 or 1. if wantz=0 the V and T\+A\+U are not stored on only they are kept for next step then overwritten.\\
\hline
\mbox{\tt in}  & {\em i} & Integer that refer to the current sweep. (outer loop).\\
\hline
\mbox{\tt in}  & {\em sweepid} & Integer that refer to the sweep to chase.(inner loop).\\
\hline
\mbox{\tt in}  & {\em m} & Integer that refer to a sweep step, to ensure order dependencies.\\
\hline
\mbox{\tt in}  & {\em grsiz} & Integer that refer to the size of a group. group mean the number of kernel that should be executed sequentially on the same core. group size is a trade-\/off between locality (cache reuse) and parallelism. a small group size increase parallelism while a large group size increase cache reuse.\\
\hline
\mbox{\tt in}  & {\em work} & Workspace of size nb. Used by the core\+\_\+chbtype\mbox{[}123\mbox{]}cb. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gad637a07cdabd30cac217af0f1278c8a0_gad637a07cdabd30cac217af0f1278c8a0}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctrmm@{C\+O\+R\+E\+\_\+ctrmm}}
\index{C\+O\+R\+E\+\_\+ctrmm@{C\+O\+R\+E\+\_\+ctrmm}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctrmm}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+ctrmm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{diag, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gad637a07cdabd30cac217af0f1278c8a0_gad637a07cdabd30cac217af0f1278c8a0}
C\+O\+R\+E\+\_\+ctrmm -\/ Computes B = alpha$\ast$op( A )$\ast$\+B or B = alpha$\ast$\+B$\ast$op( A ).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & Specifies whether A appears on the left or on the right of X\+: = Plasma\+Left\+: B = alpha$\ast$op( A )$\ast$\+B. = Plasma\+Right\+: B = alpha$\ast$\+B$\ast$op( A ).\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular\+: = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em trans\+A} & Specifies whether the matrix A is transposed, not transposed or conjfugate transposed\+: = Plasma\+No\+Trans\+: A is transposed; = Plasma\+Trans\+: A is not transposed; = Plasma\+Conj\+Trans\+: A is conjfugate transposed.\\
\hline
\mbox{\tt in}  & {\em diag} & Specifies whether or not A is unit triangular\+: = Plasma\+Non\+Unit\+: A is non unit; = Plasma\+Unit\+: A us unit.\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix B. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns pf the matrix B. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is an array of dimansion L\+D\+A-\/by-\/k, where k = M if side = Plasma\+Left and k =N when side = Plasma\+Right. The triangular matrix A. If uplo = Plasma\+Upper, the leading k-\/by-\/k upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If uplo = Plasma\+Lower, the leading k-\/by-\/k lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If diag = Plasma\+Unit, the diagonal elements of A are also not referenced and are assumed to be 1.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,k). Where k = M if side = Plasma\+Left and k =N when side = Plasma\+Right.\\
\hline
\mbox{\tt in,out}  & {\em B} & On entry, the L\+D\+B-\/by-\/\+N matrix B. On exit, if return value = 0, the M-\/by-\/\+N matrix is overwritten by the transformed matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga6b165f9de02dbc2a5f6524ca7ad9650d_ga6b165f9de02dbc2a5f6524ca7ad9650d}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctrsm@{C\+O\+R\+E\+\_\+ctrsm}}
\index{C\+O\+R\+E\+\_\+ctrsm@{C\+O\+R\+E\+\_\+ctrsm}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctrsm}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+ctrsm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{diag, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t}]{alpha, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga6b165f9de02dbc2a5f6524ca7ad9650d_ga6b165f9de02dbc2a5f6524ca7ad9650d}
C\+O\+R\+E\+\_\+ctrsm -\/ Computes triangular solve A$\ast$\+X = B or X$\ast$\+A = B.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & Specifies whether A appears on the left or on the right of X\+: = Plasma\+Left\+: A$\ast$\+X = B = Plasma\+Right\+: X$\ast$\+A = B\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular\+: = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em trans\+A} & Specifies whether the matrix A is transposed, not transposed or conjfugate transposed\+: = Plasma\+No\+Trans\+: A is transposed; = Plasma\+Trans\+: A is not transposed; = Plasma\+Conj\+Trans\+: A is conjfugate transposed.\\
\hline
\mbox{\tt in}  & {\em diag} & Specifies whether or not A is unit triangular\+: = Plasma\+Non\+Unit\+: A is non unit; = Plasma\+Unit\+: A us unit.\\
\hline
\mbox{\tt in}  & {\em M} & The order of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of right hand sides, i.\+e., the number of columns of the matrix B. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & The triangular matrix A. If uplo = Plasma\+Upper, the leading M-\/by-\/\+M upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If uplo = Plasma\+Lower, the leading M-\/by-\/\+M lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If diag = Plasma\+Unit, the diagonal elements of A are also not referenced and are assumed to be 1.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em B} & On entry, the M-\/by-\/\+N right hand side matrix B. On exit, if return value = 0, the M-\/by-\/\+N solution matrix X.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga60551b5cf1ef39496b9c9b5ed721f332_ga60551b5cf1ef39496b9c9b5ed721f332}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctrtri@{C\+O\+R\+E\+\_\+ctrtri}}
\index{C\+O\+R\+E\+\_\+ctrtri@{C\+O\+R\+E\+\_\+ctrtri}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctrtri}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+ctrtri (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{diag, }
\item[{int}]{N, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga60551b5cf1ef39496b9c9b5ed721f332_ga60551b5cf1ef39496b9c9b5ed721f332}
C\+O\+R\+E\+\_\+ctrtri -\/ Computes the inverse of a complex upper or lower triangular matrix A.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em diag} & = Plasma\+Non\+Unit\+: A is non-\/unit triangular; = Plasma\+Unit\+: A is unit triangular.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the triangular matrix A. If U\+P\+L\+O = \textquotesingle{}U\textquotesingle{}, the leading N-\/by-\/\+N upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If U\+P\+L\+O = \textquotesingle{}L\textquotesingle{}, the leading N-\/by-\/\+N lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If D\+I\+A\+G = \textquotesingle{}U\textquotesingle{}, the diagonal elements of A are also not referenced and are assumed to be 1. On exit, the (triangular) inverse of the original matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt out}  & {\em info} & 
\begin{DoxyItemize}
\item 0 on successful exit
\item $<$0 if -\/i, the i-\/th argument had an illegal value
\item $>$0 if i, A(i,i) is exactly zero. The triangular matrix is singular and its inverse can not be computed. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_gad4dfa89c572aa817837b91416c9381c0_gad4dfa89c572aa817837b91416c9381c0}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctslqt@{C\+O\+R\+E\+\_\+ctslqt}}
\index{C\+O\+R\+E\+\_\+ctslqt@{C\+O\+R\+E\+\_\+ctslqt}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctslqt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+ctslqt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gad4dfa89c572aa817837b91416c9381c0_gad4dfa89c572aa817837b91416c9381c0}
C\+O\+R\+E\+\_\+ctslqt computes a L\+Q factorization of a rectangular matrix formed by coupling side-\/by-\/side a complex M-\/by-\/\+M lower triangular tile A1 and a complex M-\/by-\/\+N tile A2\+:

$\vert$ A1 A2 $\vert$ = L $\ast$ Q

The tile Q is represented as a product of elementary reflectors

Q = H(k)\textquotesingle{} . . . H(2)\textquotesingle{} H(1)\textquotesingle{}, where k = min(\+M,\+N).

Each H(i) has the form

H(i) = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a complex scalar, and v is a complex vector with v(1\+:i-\/1) = 0 and v(i) = 1; conjfg(v(i+1\+:n)) is stored on exit in A2(i,1\+:n), and tau in T\+A\+U(i).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A1 and A2. M $>$= 0. The number of columns of the tile A1.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A2. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M-\/by-\/\+M tile A1. On exit, the elements on and below the diagonal of the array contain the M-\/by-\/\+M lower trapezoidal tile L; the elements above the diagonal are not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M-\/by-\/\+N tile A2. On exit, all the elements with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga5d276b7c438fe41e6e0e244ddd7b3edc_ga5d276b7c438fe41e6e0e244ddd7b3edc}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctsmlq@{C\+O\+R\+E\+\_\+ctsmlq}}
\index{C\+O\+R\+E\+\_\+ctsmlq@{C\+O\+R\+E\+\_\+ctsmlq}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctsmlq}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+ctsmlq (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga5d276b7c438fe41e6e0e244ddd7b3edc_ga5d276b7c438fe41e6e0e244ddd7b3edc}
C\+O\+R\+E\+\_\+ctsmlq overwrites the general complex M1-\/by-\/\+N1 tile A1 and M2-\/by-\/\+N2 tile A2 with \begin{DoxyVerb}                  SIDE = 'L'        SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 A2 $\vert$ $\ast$ Q $\vert$ A2 $\vert$

T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+H $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 A2 $\vert$ $\ast$ Q$\ast$$\ast$\+H $\vert$ A2 $\vert$

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(k)\textquotesingle{} . . . H(2)\textquotesingle{} H(1)\textquotesingle{}

as returned by C\+O\+R\+E\+\_\+\+C\+T\+S\+L\+Q\+T.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+H from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+H from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Conj\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+H.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of rows of the tile A2. M2 $>$= 0. M2 = M1 if side == Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of columns of the tile A2. N2 $>$= 0. N2 = N1 if side == Plasma\+Left.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+C\+T\+S\+L\+Q\+T in the first k rows of its array argument V.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. L\+D\+V $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+K triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+M1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,\+N1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga28e9737a152c45e8f38de6f7f26c251e_ga28e9737a152c45e8f38de6f7f26c251e}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctsmlq\+\_\+corner@{C\+O\+R\+E\+\_\+ctsmlq\+\_\+corner}}
\index{C\+O\+R\+E\+\_\+ctsmlq\+\_\+corner@{C\+O\+R\+E\+\_\+ctsmlq\+\_\+corner}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctsmlq\+\_\+corner}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+ctsmlq\+\_\+corner (
\begin{DoxyParamCaption}
\item[{int}]{m1, }
\item[{int}]{n1, }
\item[{int}]{m2, }
\item[{int}]{n2, }
\item[{int}]{m3, }
\item[{int}]{n3, }
\item[{int}]{k, }
\item[{int}]{ib, }
\item[{int}]{nb, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{lda1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{lda2, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A3, }
\item[{int}]{lda3, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{int}]{ldv, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{ldt, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{ldwork}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga28e9737a152c45e8f38de6f7f26c251e_ga28e9737a152c45e8f38de6f7f26c251e}
C\+O\+R\+E\+\_\+ctsmlq\+\_\+corner\+: see C\+O\+R\+E\+\_\+ctsmlq

This kernel applies left and right transformations as depicted below\+: $\vert$\+I -\/\+V\+T\+V\textquotesingle{}$\vert$ $\ast$ $\vert$ A1 A2 $\vert$ $\ast$ $\vert$\+I -\/ V\+T\textquotesingle{}V\textquotesingle{}$\vert$ $\vert$ A2\textquotesingle{} A3 $\vert$ where A1 and A3 are symmetric matrices. Only the lower part is referenced. This is an adhoc implementation, can be further optimized...


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m1} & The number of rows of the tile A1. m1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n1} & The number of columns of the tile A1. n1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m2} & The number of rows of the tile A2. m2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n2} & The number of columns of the tile A2. n2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m3} & The number of rows of the tile A3. m3 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n3} & The number of columns of the tile A3. n3 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em ib} & The inner-\/blocking size. ib $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The blocking size. nb $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the m1-\/by-\/n1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda1} & The leading dimension of the array A1. lda1 $>$= max(1,m1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the m2-\/by-\/n2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda2} & The leading dimension of the tile A2. lda2 $>$= max(1,m2).\\
\hline
\mbox{\tt in,out}  & {\em A3} & On entry, the m3-\/by-\/n3 tile A3.\\
\hline
\mbox{\tt in}  & {\em lda3} & The leading dimension of the tile A3. lda3 $>$= max(1,m3).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+C\+T\+S\+L\+Q\+T in the first k rows of its array argument V.\\
\hline
\mbox{\tt in}  & {\em ldv} & The leading dimension of the array V. ldv $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/n1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em ldt} & The leading dimension of the array T. ldt $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/m1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em ldwork} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,n1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gae4f109ffb197e06b188dc3a7cc697261_gae4f109ffb197e06b188dc3a7cc697261}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctsmlq\+\_\+hetra1@{C\+O\+R\+E\+\_\+ctsmlq\+\_\+hetra1}}
\index{C\+O\+R\+E\+\_\+ctsmlq\+\_\+hetra1@{C\+O\+R\+E\+\_\+ctsmlq\+\_\+hetra1}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctsmlq\+\_\+hetra1}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+ctsmlq\+\_\+hetra1 (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{m1, }
\item[{int}]{n1, }
\item[{int}]{m2, }
\item[{int}]{n2, }
\item[{int}]{k, }
\item[{int}]{ib, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{lda1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{lda2, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{int}]{ldv, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{ldt, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{ldwork}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gae4f109ffb197e06b188dc3a7cc697261_gae4f109ffb197e06b188dc3a7cc697261}
C\+O\+R\+E\+\_\+ctsmlq\+\_\+hetra1\+: see C\+O\+R\+E\+\_\+ctsmlq

This kernel applies a Right transformation on $\vert$ A1\textquotesingle{} A2 $\vert$ and does not handle the transpose of A1. Needs therefore to make the explicit transpose of A1 before and after the application of the block of reflectors Can be further optimized by changing accordingly the underneath kernel ztsrfb!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+H from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+H from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Conj\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+H.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em m1} & The number of rows of the tile A1. m1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n1} & The number of columns of the tile A1. n1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m2} & The number of rows of the tile A2. m2 $>$= 0. m2 = m1 if side == Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em n2} & The number of columns of the tile A2. n2 $>$= 0. n2 = n1 if side == Plasma\+Left.\\
\hline
\mbox{\tt in}  & {\em k} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em ib} & The inner-\/blocking size. ib $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the m1-\/by-\/n1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda1} & The leading dimension of the array A1. lda1 $>$= max(1,m1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the m2-\/by-\/n2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda2} & The leading dimension of the tile A2. lda2 $>$= max(1,m2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+C\+T\+S\+L\+Q\+T in the first k rows of its array argument V. ! \\
\hline
\mbox{\tt in}  & {\em ldv} & The leading dimension of the array V. ldv $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/n1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em ldt} & The leading dimension of the array T. ldt $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/m1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em ldwork} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,n1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaafe02678a5ac0b0359bb2a14ccb831a7_gaafe02678a5ac0b0359bb2a14ccb831a7}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctsmqr@{C\+O\+R\+E\+\_\+ctsmqr}}
\index{C\+O\+R\+E\+\_\+ctsmqr@{C\+O\+R\+E\+\_\+ctsmqr}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctsmqr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+ctsmqr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaafe02678a5ac0b0359bb2a14ccb831a7_gaafe02678a5ac0b0359bb2a14ccb831a7}
C\+O\+R\+E\+\_\+ctsmqr overwrites the general complex M1-\/by-\/\+N1 tile A1 and M2-\/by-\/\+N2 tile A2 with \begin{DoxyVerb}                  SIDE = 'L'        SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 A2 $\vert$ $\ast$ Q $\vert$ A2 $\vert$

T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+H $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 A2 $\vert$ $\ast$ Q$\ast$$\ast$\+H $\vert$ A2 $\vert$

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(1) H(2) . . . H(k)

as returned by C\+O\+R\+E\+\_\+\+C\+T\+S\+Q\+R\+T.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+H from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+H from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Conj\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+H.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of rows of the tile A2. M2 $>$= 0. M2 = M1 if side == Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of columns of the tile A2. N2 $>$= 0. N2 = N1 if side == Plasma\+Left.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+C\+T\+S\+Q\+R\+T in the first k columns of its array argument V.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. L\+D\+V $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+K triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+N1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,\+M1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaec4d357be756fd805fbbf60b79cbc735_gaec4d357be756fd805fbbf60b79cbc735}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctsmqr\+\_\+corner@{C\+O\+R\+E\+\_\+ctsmqr\+\_\+corner}}
\index{C\+O\+R\+E\+\_\+ctsmqr\+\_\+corner@{C\+O\+R\+E\+\_\+ctsmqr\+\_\+corner}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctsmqr\+\_\+corner}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+ctsmqr\+\_\+corner (
\begin{DoxyParamCaption}
\item[{int}]{m1, }
\item[{int}]{n1, }
\item[{int}]{m2, }
\item[{int}]{n2, }
\item[{int}]{m3, }
\item[{int}]{n3, }
\item[{int}]{k, }
\item[{int}]{ib, }
\item[{int}]{nb, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{lda1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{lda2, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A3, }
\item[{int}]{lda3, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{int}]{ldv, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{ldt, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{ldwork}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaec4d357be756fd805fbbf60b79cbc735_gaec4d357be756fd805fbbf60b79cbc735}
C\+O\+R\+E\+\_\+ctsmqr\+\_\+corner\+: see C\+O\+R\+E\+\_\+ctsmqr

This kernel applies left and right transformations as depicted below\+: $\vert$\+I -\/\+V\+T\textquotesingle{}V\textquotesingle{}$\vert$ $\ast$ $\vert$ A1 A2\textquotesingle{}$\vert$ $\ast$ $\vert$\+I -\/ V\+T\+V\textquotesingle{}$\vert$ $\vert$ A2 A3 $\vert$ where A1 and A3 are symmetric matrices. Only the lower part is referenced. This is an adhoc implementation, can be further optimized...


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m1} & The number of rows of the tile A1. m1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n1} & The number of columns of the tile A1. n1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m2} & The number of rows of the tile A2. m2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n2} & The number of columns of the tile A2. n2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m3} & The number of rows of the tile A3. m3 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n3} & The number of columns of the tile A3. n3 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em ib} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The blocking size. N\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda1} & The leading dimension of the array A1. lda1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda2} & The leading dimension of the tile A2. lda2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in,out}  & {\em A3} & On entry, the m3-\/by-\/n3 tile A3.\\
\hline
\mbox{\tt in}  & {\em lda3} & The leading dimension of the tile A3. lda3 $>$= max(1,m3).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+C\+T\+S\+Q\+R\+T in the first k columns of its array argument V.\\
\hline
\mbox{\tt in}  & {\em ldv} & The leading dimension of the array V. ldv $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+N1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em ldt} & The leading dimension of the array T. ldt $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+N1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em ldwork} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,\+M1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaf062e7ba21ee418d0d9779dbf01c6390_gaf062e7ba21ee418d0d9779dbf01c6390}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctsmqr\+\_\+hetra1@{C\+O\+R\+E\+\_\+ctsmqr\+\_\+hetra1}}
\index{C\+O\+R\+E\+\_\+ctsmqr\+\_\+hetra1@{C\+O\+R\+E\+\_\+ctsmqr\+\_\+hetra1}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctsmqr\+\_\+hetra1}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+ctsmqr\+\_\+hetra1 (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{m1, }
\item[{int}]{n1, }
\item[{int}]{m2, }
\item[{int}]{n2, }
\item[{int}]{k, }
\item[{int}]{ib, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{lda1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{lda2, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{int}]{ldv, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{ldt, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{ldwork}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaf062e7ba21ee418d0d9779dbf01c6390_gaf062e7ba21ee418d0d9779dbf01c6390}
C\+O\+R\+E\+\_\+ctsmqr\+\_\+hetra1\+: see C\+O\+R\+E\+\_\+ctsmqr

This kernel applies a left transformation on $\vert$ A1\textquotesingle{}$\vert$ $\vert$ A2 $\vert$

Needs therefore to make the explicit transpose of A1 before and after the application of the block of reflectors Can be further optimized by changing accordingly the underneath kernel ztsrfb!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+H from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+H from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Conj\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+H.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em m1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m2} & The number of rows of the tile A2. M2 $>$= 0. M2 = M1 if side == Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em n2} & The number of columns of the tile A2. N2 $>$= 0. N2 = N1 if side == Plasma\+Left.\\
\hline
\mbox{\tt in}  & {\em k} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em ib} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+C\+T\+S\+Q\+R\+T in the first k columns of its array argument V.\\
\hline
\mbox{\tt in}  & {\em ldv} & The leading dimension of the array V. L\+D\+V $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+N1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em ldt} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+N1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em ldwork} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,\+M1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaa0f009ac37aee2a788692cc46225a64a_gaa0f009ac37aee2a788692cc46225a64a}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctsqrt@{C\+O\+R\+E\+\_\+ctsqrt}}
\index{C\+O\+R\+E\+\_\+ctsqrt@{C\+O\+R\+E\+\_\+ctsqrt}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctsqrt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+ctsqrt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaa0f009ac37aee2a788692cc46225a64a_gaa0f009ac37aee2a788692cc46225a64a}
C\+O\+R\+E\+\_\+ctsqrt computes a Q\+R factorization of a rectangular matrix formed by coupling a complex N-\/by-\/\+N upper triangular tile A1 on top of a complex M-\/by-\/\+N tile A2\+:

$\vert$ A1 $\vert$ = Q $\ast$ R $\vert$ A2 $\vert$


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of columns of the tile A2. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of rows of the tile A1. The number of columns of the tiles A1 and A2. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the N-\/by-\/\+N tile A1. On exit, the elements on and above the diagonal of the array contain the N-\/by-\/\+N upper trapezoidal tile R; the elements below the diagonal are not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+N).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M-\/by-\/\+N tile A2. On exit, all the elements with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaec00749a149362afedaa0bab2d69fdfc_gaec00749a149362afedaa0bab2d69fdfc}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+ctstrf@{C\+O\+R\+E\+\_\+ctstrf}}
\index{C\+O\+R\+E\+\_\+ctstrf@{C\+O\+R\+E\+\_\+ctstrf}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+ctstrf}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+ctstrf (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{int}]{N\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{U, }
\item[{int}]{L\+D\+U, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{L, }
\item[{int}]{L\+D\+L, }
\item[{int $\ast$}]{I\+P\+I\+V, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K, }
\item[{int $\ast$}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaec00749a149362afedaa0bab2d69fdfc_gaec00749a149362afedaa0bab2d69fdfc}
C\+O\+R\+E\+\_\+ctstrf computes an L\+U factorization of a complex matrix formed by an upper triangular N\+B-\/by-\/\+N tile U on top of a M-\/by-\/\+N tile A using partial pivoting with row interchanges.

This is the right-\/looking Level 2.\+5 B\+L\+A\+S version of the algorithm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N\+B} & \\
\hline
\mbox{\tt in,out}  & {\em U} & On entry, the N\+B-\/by-\/\+N upper triangular tile. On exit, the new factor U from the factorization\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & The leading dimension of the array U. L\+D\+U $>$= max(1,\+N\+B).\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be factored. On exit, the factor L from the factorization\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em L} & On entry, the I\+B-\/by-\/\+N lower triangular tile. On exit, the interchanged rows form the tile A in case of pivoting.\\
\hline
\mbox{\tt in}  & {\em L\+D\+L} & The leading dimension of the array L. L\+D\+L $>$= max(1,\+I\+B).\\
\hline
\mbox{\tt out}  & {\em I\+P\+I\+V} & The pivot indices; for 1 $<$= i $<$= min(\+M,\+N), row i of the tile U was interchanged with row I\+P\+I\+V(i) of the tile A.\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & \\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The leading dimension of the array W\+O\+R\+K.\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
{\em $>$0} & if I\+N\+F\+O = k, U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga3732acb715983d998575f8b077b0b979_ga3732acb715983d998575f8b077b0b979}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cttlqt@{C\+O\+R\+E\+\_\+cttlqt}}
\index{C\+O\+R\+E\+\_\+cttlqt@{C\+O\+R\+E\+\_\+cttlqt}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cttlqt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cttlqt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga3732acb715983d998575f8b077b0b979_ga3732acb715983d998575f8b077b0b979}
C\+O\+R\+E\+\_\+cttlqt computes a L\+Q factorization of a rectangular matrix formed by coupling side-\/by-\/side a complex M-\/by-\/\+M lower triangular tile A1 and a complex M-\/by-\/\+N lower triangular tile A2\+:

$\vert$ A1 A2 $\vert$ = L $\ast$ Q

The tile Q is represented as a product of elementary reflectors

Q = H(k)\textquotesingle{} . . . H(2)\textquotesingle{} H(1)\textquotesingle{}, where k = min(\+M,\+N).

Each H(i) has the form

H(i) = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a complex scalar, and v is a complex vector with v(1\+:i-\/1) = 0 and v(i) = 1; conjfg(v(i+1\+:n)) is stored on exit in A2(i,1\+:n), and tau in T\+A\+U(i).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A1 and A2. M $>$= 0. The number of columns of the tile A1.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A2. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M-\/by-\/\+M tile A1. On exit, the elements on and below the diagonal of the array contain the M-\/by-\/\+M lower trapezoidal tile L; the elements above the diagonal are not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+N).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M-\/by-\/\+N lower triangular tile A2. On exit, the elements on and below the diagonal of the array with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the array A2. L\+D\+A2 $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga1a3b2d9dd959660e4d649a35c8b51c5e_ga1a3b2d9dd959660e4d649a35c8b51c5e}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cttmlq@{C\+O\+R\+E\+\_\+cttmlq}}
\index{C\+O\+R\+E\+\_\+cttmlq@{C\+O\+R\+E\+\_\+cttmlq}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cttmlq}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cttmlq (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga1a3b2d9dd959660e4d649a35c8b51c5e_ga1a3b2d9dd959660e4d649a35c8b51c5e}
C\+O\+R\+E\+\_\+cttmlq overwrites the general complex M1-\/by-\/\+N1 tile A1 and M2-\/by-\/\+N2 tile A2 (N1 == N2) with \begin{DoxyVerb}                  SIDE = 'L'        SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 $\vert$ $\ast$ Q $\vert$ A2 $\vert$ $\vert$ A2 $\vert$

T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+H $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 $\vert$ $\ast$ Q$\ast$$\ast$\+H $\vert$ A2 $\vert$ $\vert$ A2 $\vert$

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(1) H(2) . . . H(k)

as returned by C\+O\+R\+E\+\_\+cttqrt.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+H from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+H from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Conj\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+H.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of rows of the tile A2. M2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of columns of the tile A2. N2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+C\+T\+T\+Q\+R\+T in the first k rows of its array argument V.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. L\+D\+V $>$= max(1,\+K).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+N1.\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga942a54bd176e5520d2605e607a0dd496_ga942a54bd176e5520d2605e607a0dd496}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cttmqr@{C\+O\+R\+E\+\_\+cttmqr}}
\index{C\+O\+R\+E\+\_\+cttmqr@{C\+O\+R\+E\+\_\+cttmqr}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cttmqr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cttmqr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga942a54bd176e5520d2605e607a0dd496_ga942a54bd176e5520d2605e607a0dd496}
C\+O\+R\+E\+\_\+cttmqr overwrites the general complex M1-\/by-\/\+N1 tile A1 and M2-\/by-\/\+N2 tile A2 (N1 == N2) with \begin{DoxyVerb}                  SIDE = 'L'        SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 $\vert$ $\ast$ Q $\vert$ A2 $\vert$ $\vert$ A2 $\vert$

T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+H $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 $\vert$ $\ast$ Q$\ast$$\ast$\+H $\vert$ A2 $\vert$ $\vert$ A2 $\vert$

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(1) H(2) . . . H(k)

as returned by C\+O\+R\+E\+\_\+cttqrt.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+H from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+H from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Conj\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+H.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of rows of the tile A2. M2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of columns of the tile A2. N2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+C\+T\+T\+Q\+R\+T in the first k rows of its array argument V.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. L\+D\+V $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+N1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+N1.\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gacdf604a4fa8379f693539966b7c3c3c6_gacdf604a4fa8379f693539966b7c3c3c6}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cttqrt@{C\+O\+R\+E\+\_\+cttqrt}}
\index{C\+O\+R\+E\+\_\+cttqrt@{C\+O\+R\+E\+\_\+cttqrt}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cttqrt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cttqrt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T\+A\+U, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gacdf604a4fa8379f693539966b7c3c3c6_gacdf604a4fa8379f693539966b7c3c3c6}
C\+O\+R\+E\+\_\+cttqrt computes a Q\+R factorization of a rectangular matrix formed by coupling a complex N-\/by-\/\+N upper triangular tile A1 on top of a complex M-\/by-\/\+N upper trapezoidal tile A2\+:

$\vert$ A1 $\vert$ = Q $\ast$ R $\vert$ A2 $\vert$

The tile Q is represented as a product of elementary reflectors

Q = H(1) H(2) . . . H(k), where k = min(\+M,\+N).

Each H(i) has the form

H(i) = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a complex scalar, and v is a complex vector with v(1\+:i-\/1) = 0 and v(i) = 1; v(i+1\+:m) is stored on exit in A2(1\+:m,i), and tau in T\+A\+U(i).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A2. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A1 and A2. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the N-\/by-\/\+N tile A1. On exit, the elements on and above the diagonal of the array contain the N-\/by-\/\+N upper trapezoidal tile R; the elements below the diagonal are not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+N).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M-\/by-\/\+N upper triangular tile A2. On exit, the elements on and above the diagonal of the array with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the array A2. L\+D\+A2 $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga146c90c6b590a52e1c5a945b16364b3e_ga146c90c6b590a52e1c5a945b16364b3e}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cunmlq@{C\+O\+R\+E\+\_\+cunmlq}}
\index{C\+O\+R\+E\+\_\+cunmlq@{C\+O\+R\+E\+\_\+cunmlq}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cunmlq}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cunmlq (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C, }
\item[{int}]{L\+D\+C, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga146c90c6b590a52e1c5a945b16364b3e_ga146c90c6b590a52e1c5a945b16364b3e}
C\+O\+R\+E\+\_\+cunmlq overwrites the general complex M-\/by-\/\+N tile C with \begin{DoxyVerb}              SIDE = 'L'     SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ C C $\ast$ Q T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+H $\ast$ C C $\ast$ Q$\ast$$\ast$\+H

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(k) . . . H(2) H(1)

as returned by C\+O\+R\+E\+\_\+cgelqt. Q is of order M if S\+I\+D\+E = \textquotesingle{}L\textquotesingle{} and of order N if S\+I\+D\+E = \textquotesingle{}R\textquotesingle{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+H from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+H from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Conj\+Trans \+: Transpose, apply Q$\ast$$\ast$\+H.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the tile C. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile C. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q. If S\+I\+D\+E = Plasma\+Left, M $>$= K $>$= 0; if S\+I\+D\+E = Plasma\+Right, N $>$= K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & Dimension\+: (L\+D\+A,M) if S\+I\+D\+E = Plasma\+Left, (L\+D\+A,N) if S\+I\+D\+E = Plasma\+Right, The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+cgelqt in the first k rows of its array argument A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+K triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt in,out}  & {\em C} & On entry, the M-\/by-\/\+N tile C. On exit, C is overwritten by Q$\ast$\+C or Q$\ast$$\ast$\+T$\ast$\+C or C$\ast$\+Q$\ast$$\ast$\+T or C$\ast$\+Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & On exit, if I\+N\+F\+O = 0, W\+O\+R\+K(1) returns the optimal L\+D\+W\+O\+R\+K.\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K. If S\+I\+D\+E = Plasma\+Left, L\+D\+W\+O\+R\+K $>$= max(1,\+N); if S\+I\+D\+E = Plasma\+Right, L\+D\+W\+O\+R\+K $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gaa733869e9c9d2b29204aaf799dfab70b_gaa733869e9c9d2b29204aaf799dfab70b}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+cunmqr@{C\+O\+R\+E\+\_\+cunmqr}}
\index{C\+O\+R\+E\+\_\+cunmqr@{C\+O\+R\+E\+\_\+cunmqr}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+cunmqr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+cunmqr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{C, }
\item[{int}]{L\+D\+C, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gaa733869e9c9d2b29204aaf799dfab70b_gaa733869e9c9d2b29204aaf799dfab70b}
C\+O\+R\+E\+\_\+cunmqr overwrites the general complex M-\/by-\/\+N tile C with \begin{DoxyVerb}              SIDE = 'L'     SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ C C $\ast$ Q T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+H $\ast$ C C $\ast$ Q$\ast$$\ast$\+H

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(1) H(2) . . . H(k)

as returned by C\+O\+R\+E\+\_\+cgeqrt. Q is of order M if S\+I\+D\+E = \textquotesingle{}L\textquotesingle{} and of order N if S\+I\+D\+E = \textquotesingle{}R\textquotesingle{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+H from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+H from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Conj\+Trans \+: Transpose, apply Q$\ast$$\ast$\+H.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the tile C. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile C. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q. If S\+I\+D\+E = Plasma\+Left, M $>$= K $>$= 0; if S\+I\+D\+E = Plasma\+Right, N $>$= K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & Dimension\+: (L\+D\+A,K) The i-\/th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+cgeqrt in the first k columns of its array argument A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. If S\+I\+D\+E = Plasma\+Left, L\+D\+A $>$= max(1,\+M); if S\+I\+D\+E = Plasma\+Right, L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+K triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt in,out}  & {\em C} & On entry, the M-\/by-\/\+N tile C. On exit, C is overwritten by Q$\ast$\+C or Q$\ast$$\ast$\+T$\ast$\+C or C$\ast$\+Q$\ast$$\ast$\+T or C$\ast$\+Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & On exit, if I\+N\+F\+O = 0, W\+O\+R\+K(1) returns the optimal L\+D\+W\+O\+R\+K.\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K. If S\+I\+D\+E = Plasma\+Left, L\+D\+W\+O\+R\+K $>$= max(1,\+N); if S\+I\+D\+E = Plasma\+Right, L\+D\+W\+O\+R\+K $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__PLASMA__Complex32__t_gadc7bf683e0afadd77075b49c827cc016_gadc7bf683e0afadd77075b49c827cc016}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+scasum@{C\+O\+R\+E\+\_\+scasum}}
\index{C\+O\+R\+E\+\_\+scasum@{C\+O\+R\+E\+\_\+scasum}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+scasum}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+scasum (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{storev, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{A, }
\item[{int}]{lda, }
\item[{float $\ast$}]{work}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_gadc7bf683e0afadd77075b49c827cc016_gadc7bf683e0afadd77075b49c827cc016}
C\+O\+R\+E\+\_\+scasum -\/ Computes the sums of the absolute values of elements in a same row or column. This function is an auxiliary function to norm computations.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em storev} & Specifies whether the sums are made per column or row. = Plasma\+Columnwise\+: Computes the sum on each column = Plasma\+Rowwise\+: Computes the sum on each row\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular or general = Plasma\+Upper\+Lower\+: All matrix A is referenced; = Plasma\+Upper\+: Upper triangle of A is referenced; = Plasma\+Lower\+: Lower triangle of A is referenced.\\
\hline
\mbox{\tt in}  & {\em M} & M specifies the number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & A is a M-\/by-\/\+N matrix.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. lda $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em work} & Array of dimension M if storev = Plasma\+Rowwise; N otherwise. On exit, contains the sums of the absolute values per column or row. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__PLASMA__Complex32__t_ga2fb0a8db5844612734c55602fe3f38b1_ga2fb0a8db5844612734c55602fe3f38b1}{}\index{Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}!C\+O\+R\+E\+\_\+slag2c@{C\+O\+R\+E\+\_\+slag2c}}
\index{C\+O\+R\+E\+\_\+slag2c@{C\+O\+R\+E\+\_\+slag2c}!Kernel Interface -\/ Single Complex@{Kernel Interface -\/ Single Complex}}
\subsubsection[{C\+O\+R\+E\+\_\+slag2c}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+slag2c (
\begin{DoxyParamCaption}
\item[{int}]{m, }
\item[{int}]{n, }
\item[{const float $\ast$}]{R, }
\item[{int}]{ldr, }
\item[{P\+L\+A\+S\+M\+A\+\_\+\+Complex32\+\_\+t $\ast$}]{Z, }
\item[{int}]{ldz}
\end{DoxyParamCaption}
)}\label{group__CORE__PLASMA__Complex32__t_ga2fb0a8db5844612734c55602fe3f38b1_ga2fb0a8db5844612734c55602fe3f38b1}
C\+O\+R\+E\+\_\+slag2c -\/ Copy a real matrix R into the real part of a complex matrix Z


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & m specifies the number of rows of the matrices R and Z.\\
\hline
\mbox{\tt in}  & {\em n} & n specifies the number of columns of the matrices R and Z.\\
\hline
\mbox{\tt in}  & {\em R} & R contains the real coefficient to be copied into the complex matrix. R is of size ldr -\/by-\/ n.\\
\hline
\mbox{\tt in}  & {\em ldr} & ldr specifies the leading dimension of R. ldr $>$= max(1,m).\\
\hline
\mbox{\tt out}  & {\em Z} & On exit, the real part of the values of Z will be set to the ones stored in R, and the imagfinary part set to 0. Z is of size ldz -\/by-\/ n.\\
\hline
\mbox{\tt in}  & {\em ldz} & ldz specifies the leading dimension of Z. ldz $>$= max(1,m).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
