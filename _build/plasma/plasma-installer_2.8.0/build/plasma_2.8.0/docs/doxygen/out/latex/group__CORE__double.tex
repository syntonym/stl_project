\hypertarget{group__CORE__double}{}\section{Kernel Interface -\/ Double Real}
\label{group__CORE__double}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group__CORE__double_ga53dc4af00adc7b3b4d12eafb71596dfc_ga53dc4af00adc7b3b4d12eafb71596dfc}{S\+E\+L\+E\+C\+T}~20
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group__CORE__double_ga11c4e4a071c38e9623b0a1279cb73499_ga11c4e4a071c38e9623b0a1279cb73499}{C\+O\+R\+E\+\_\+dasum} (P\+L\+A\+S\+M\+A\+\_\+enum storev, P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, const double $\ast$A, int lda, double $\ast$work)
\item 
void \hyperlink{group__CORE__double_ga7e2b483dffea59c30d89f188b2c7be40_ga7e2b483dffea59c30d89f188b2c7be40}{C\+O\+R\+E\+\_\+dbrdalg1} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int n, int nb, double $\ast$A, int lda, double $\ast$V\+Q, double $\ast$T\+A\+U\+Q, double $\ast$V\+P, double $\ast$T\+A\+U\+P, int Vblksiz, int wantz, int i, int sweepid, int m, int grsiz, double $\ast$work)
\item 
int \hyperlink{group__CORE__double_gaad4a5ec87fa6d69ba1a6fb03f7b3963d_gaad4a5ec87fa6d69ba1a6fb03f7b3963d}{C\+O\+R\+E\+\_\+dgbelr} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, double $\ast$V, double $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
int \hyperlink{group__CORE__double_ga33d2edbfc8d4322981b57243433758e8_ga33d2edbfc8d4322981b57243433758e8}{C\+O\+R\+E\+\_\+dgblrx} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, double $\ast$V, double $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
int \hyperlink{group__CORE__double_gaf8beaaa27cb9a11f78eac099fbacd4b8_gaf8beaaa27cb9a11f78eac099fbacd4b8}{C\+O\+R\+E\+\_\+dgbrce} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, double $\ast$V, double $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
void \hyperlink{group__CORE__double_gaf7c14d4df0b70516d0b7dba06a76eaa5_gaf7c14d4df0b70516d0b7dba06a76eaa5}{C\+O\+R\+E\+\_\+dgbtype1cb} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, int N\+B, double $\ast$A, int L\+D\+A, double $\ast$V\+Q, double $\ast$T\+A\+U\+Q, double $\ast$V\+P, double $\ast$T\+A\+U\+P, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, double $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__double_ga110e47047bf9b4e72abf8e9b5ceeb05f_ga110e47047bf9b4e72abf8e9b5ceeb05f}{C\+O\+R\+E\+\_\+dgbtype2cb} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, int N\+B, double $\ast$A, int L\+D\+A, double $\ast$V\+Q, double $\ast$T\+A\+U\+Q, double $\ast$V\+P, double $\ast$T\+A\+U\+P, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, double $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__double_ga7e6f6499c138a6d38ed8a0908ddee64c_ga7e6f6499c138a6d38ed8a0908ddee64c}{C\+O\+R\+E\+\_\+dgbtype3cb} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, int N\+B, double $\ast$A, int L\+D\+A, double $\ast$V\+Q, double $\ast$T\+A\+U\+Q, double $\ast$V\+P, double $\ast$T\+A\+U\+P, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, double $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_gaca52e4d3203bb82422d184f8970b9968_gaca52e4d3203bb82422d184f8970b9968}{C\+O\+R\+E\+\_\+dgeadd} (P\+L\+A\+S\+M\+A\+\_\+enum trans, int M, int N, double alpha, const double $\ast$A, int L\+D\+A, double beta, double $\ast$B, int L\+D\+B)
\item 
int \hyperlink{group__CORE__double_ga2bff35db3d30069fcb9fde474e642f03_ga2bff35db3d30069fcb9fde474e642f03}{C\+O\+R\+E\+\_\+dgelqt} (int M, int N, int I\+B, double $\ast$A, int L\+D\+A, double $\ast$T, int L\+D\+T, double $\ast$T\+A\+U, double $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__double_ga0f4f7fdf0eb156d55c71386eb1b76d1e_ga0f4f7fdf0eb156d55c71386eb1b76d1e}{C\+O\+R\+E\+\_\+dgemm} (P\+L\+A\+S\+M\+A\+\_\+enum trans\+A, int trans\+B, int M, int N, int K, double alpha, const double $\ast$A, int L\+D\+A, const double $\ast$B, int L\+D\+B, double beta, double $\ast$C, int L\+D\+C)
\item 
void \hyperlink{group__CORE__double_gad5d21bddba2726e03cf218681e559d36_gad5d21bddba2726e03cf218681e559d36}{C\+O\+R\+E\+\_\+dgemv} (P\+L\+A\+S\+M\+A\+\_\+enum trans, int m, int n, double alpha, const double $\ast$A, int lda, const double $\ast$x, int incx, double beta, double $\ast$y, int incy)
\item 
void \hyperlink{group__CORE__double_ga04c474827ce4bd9af88919a8734dd6e7_ga04c474827ce4bd9af88919a8734dd6e7}{C\+O\+R\+E\+\_\+dgeqp3\+\_\+init} (int n, int $\ast$jpvt)
\item 
void \hyperlink{group__CORE__double_ga1ada7f30a1198540065ca3393f27ea73_ga1ada7f30a1198540065ca3393f27ea73}{C\+O\+R\+E\+\_\+dgeqp3\+\_\+larfg} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} A, int ii, int jj, int i, int j, double $\ast$tau, double $\ast$beta)
\item 
void \hyperlink{group__CORE__double_gae0c64547ad5f825af9af811b583ea231_gae0c64547ad5f825af9af811b583ea231}{C\+O\+R\+E\+\_\+dgeqp3\+\_\+norms} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} A, int ioff, int joff, double $\ast$norms1, double $\ast$norms2)
\item 
void \hyperlink{group__CORE__double_gaf606d0b2de38604d78d13242d81b9824_gaf606d0b2de38604d78d13242d81b9824}{C\+O\+R\+E\+\_\+dgeqp3\+\_\+pivot} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} A, double $\ast$F, int ldf, int jj, int k, int $\ast$jpvt, double $\ast$norms1, double $\ast$norms2, int $\ast$info)
\item 
void \hyperlink{group__CORE__double_ga15093a96afb5bad4404f6b1d112d53f5_ga15093a96afb5bad4404f6b1d112d53f5}{C\+O\+R\+E\+\_\+dgeqp3\+\_\+update} (const double $\ast$Ajj, int lda1, double $\ast$Ajk, int lda2, const double $\ast$Fk, int ldf, int joff, int k, int koff, int nb, double $\ast$norms1, double $\ast$norms2, int $\ast$info)
\item 
int \hyperlink{group__CORE__double_gab8583bd4b0eb7a10fd9375f329a92b04_gab8583bd4b0eb7a10fd9375f329a92b04}{C\+O\+R\+E\+\_\+dgeqrt} (int M, int N, int I\+B, double $\ast$A, int L\+D\+A, double $\ast$T, int L\+D\+T, double $\ast$T\+A\+U, double $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_gaa343ed98ffecdd2a665c496662f47dd2_gaa343ed98ffecdd2a665c496662f47dd2}{C\+O\+R\+E\+\_\+dgessm} (int M, int N, int K, int I\+B, const int $\ast$I\+P\+I\+V, const double $\ast$L, int L\+D\+L, double $\ast$A, int L\+D\+A)
\item 
int \hyperlink{group__CORE__double_ga5150032fe134978e7ee6f8fc4a031a9d_ga5150032fe134978e7ee6f8fc4a031a9d}{C\+O\+R\+E\+\_\+dgetf2\+\_\+nopiv} (int M, int N, double $\ast$A, int L\+D\+A)
\item 
int \hyperlink{group__CORE__double_ga9fc744fcea215ec1d5a92452b2490fc4_ga9fc744fcea215ec1d5a92452b2490fc4}{C\+O\+R\+E\+\_\+dgetrf} (int m, int n, double $\ast$A, int lda, int $\ast$I\+P\+I\+V, int $\ast$info)
\item 
int \hyperlink{group__CORE__double_gab173cf6731777f03013286028c876ce7_gab173cf6731777f03013286028c876ce7}{C\+O\+R\+E\+\_\+dgetrf\+\_\+incpiv} (int M, int N, int I\+B, double $\ast$A, int L\+D\+A, int $\ast$I\+P\+I\+V, int $\ast$I\+N\+F\+O)
\item 
int \hyperlink{group__CORE__double_ga30400ad99aa04946859afdac1a716eff_ga30400ad99aa04946859afdac1a716eff}{C\+O\+R\+E\+\_\+dgetrf\+\_\+nopiv} (int M, int N, int I\+B, double $\ast$A, int L\+D\+A)
\item 
int \hyperlink{group__CORE__double_ga14a9a22ac40973261b22d2d299664fbe_ga14a9a22ac40973261b22d2d299664fbe}{C\+O\+R\+E\+\_\+dgetrf\+\_\+reclap} (\hyperlink{structCORE__dgetrf__data__s}{C\+O\+R\+E\+\_\+dgetrf\+\_\+data\+\_\+t} $\ast$data, int M, int N, double $\ast$A, int L\+D\+A, int $\ast$I\+P\+I\+V, int $\ast$info)
\item 
int \hyperlink{group__CORE__double_gab19afc12efaf81167776221dcc3e4095_gab19afc12efaf81167776221dcc3e4095}{C\+O\+R\+E\+\_\+dgetrf\+\_\+rectil} (\hyperlink{structCORE__dgetrf__data__s}{C\+O\+R\+E\+\_\+dgetrf\+\_\+data\+\_\+t} $\ast$data, const \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} A, int $\ast$I\+P\+I\+V, int $\ast$info)
\item 
void \hyperlink{group__CORE__double_gaef525bd155bb8cccbcb8055a8ac19170_gaef525bd155bb8cccbcb8055a8ac19170}{C\+O\+R\+E\+\_\+dgetrip} (int m, int n, double $\ast$A, double $\ast$W)
\item 
int \hyperlink{group__CORE__double_gadb56425edd66af0d0baaafa4db730687_gadb56425edd66af0d0baaafa4db730687}{C\+O\+R\+E\+\_\+dhbelr} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, double $\ast$V, double $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
int \hyperlink{group__CORE__double_ga6b181b2a5e76222ea33f2bb6cf02419e_ga6b181b2a5e76222ea33f2bb6cf02419e}{C\+O\+R\+E\+\_\+dhblrx} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, double $\ast$V, double $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
int \hyperlink{group__CORE__double_gaeac6ec5ddb7fb26216c32ffae11a9d20_gaeac6ec5ddb7fb26216c32ffae11a9d20}{C\+O\+R\+E\+\_\+dhbrce} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$A, double $\ast$V, double $\ast$T\+A\+U, int st, int ed, int eltsize)
\item 
void \hyperlink{group__CORE__double_gabe6acc0e0cb39b2a16cb484ce527e19e_gabe6acc0e0cb39b2a16cb484ce527e19e}{C\+O\+R\+E\+\_\+dlacpy} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, const double $\ast$A, int L\+D\+A, double $\ast$B, int L\+D\+B)
\item 
int \hyperlink{group__CORE__double_gaf9b1c36e5bd489b8e488243b076814f8_gaf9b1c36e5bd489b8e488243b076814f8}{C\+O\+R\+E\+\_\+dlacpy\+\_\+pivot} (const \hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} desc\+A, P\+L\+A\+S\+M\+A\+\_\+enum direct, int k1, int k2, const int $\ast$ipiv, int $\ast$rankin, int $\ast$rankout, double $\ast$A, int lda, int init)
\item 
void \hyperlink{group__CORE__double_ga785e1bf88728ffb2b7339e9de433d0f2_ga785e1bf88728ffb2b7339e9de433d0f2}{C\+O\+R\+E\+\_\+dlaed0\+\_\+betaapprox} (int subpbs, const int $\ast$subpbs\+\_\+info, double $\ast$D, const double $\ast$E)
\item 
void \hyperlink{group__CORE__double_ga2bdc9efff9f2cae6d89fd67a162c7f2a_ga2bdc9efff9f2cae6d89fd67a162c7f2a}{C\+O\+R\+E\+\_\+dlaed2\+\_\+compressq} (int n, int n1, const int $\ast$I\+N\+D\+X, const int $\ast$ctot, const double $\ast$Q, int L\+D\+Q, double $\ast$Q2, int start, int end)
\item 
void \hyperlink{group__CORE__double_ga0b7db3e9b6066968ce09af2cdbe15ed1_ga0b7db3e9b6066968ce09af2cdbe15ed1}{C\+O\+R\+E\+\_\+dlaed2\+\_\+copydef} (int n, int n1, int K, const int $\ast$ctot, double $\ast$Q, int L\+D\+Q, const double $\ast$Q2, int start, int end)
\item 
void \hyperlink{group__CORE__double_ga6a307ebecf8a76fa174e00a626ac5f2b_ga6a307ebecf8a76fa174e00a626ac5f2b}{C\+O\+R\+E\+\_\+dlaed2\+\_\+compute\+K} (int $\ast$Kptr, int n, int n1, double $\ast$betaptr, double $\ast$D, double $\ast$Q, int L\+D\+Q, double $\ast$Z, double $\ast$D\+L\+A\+M\+B\+D\+A, double $\ast$W, int $\ast$I\+N\+D\+X, int $\ast$I\+N\+D\+X\+C, int $\ast$I\+N\+D\+X\+P, int $\ast$I\+N\+D\+X\+Q, int $\ast$C\+O\+L\+T\+Y\+P)
\item 
void \hyperlink{group__CORE__double_ga3be1c5d54e7c9c950f2b93cc1ffe1ef8_ga3be1c5d54e7c9c950f2b93cc1ffe1ef8}{C\+O\+R\+E\+\_\+dlaed3\+\_\+computevectors} (int K, int il\+\_\+nondef, int iu\+\_\+nondef, double $\ast$Q, int L\+D\+Q, double $\ast$W, double $\ast$S, const int $\ast$I\+N\+D\+X\+C, int start, int end)
\item 
void \hyperlink{group__CORE__double_gaa85a007085ddd54918d2097cb65df311_gaa85a007085ddd54918d2097cb65df311}{C\+O\+R\+E\+\_\+dlaed3\+\_\+compute\+W} (int n, int K, const double $\ast$Q, int L\+D\+Q, const double $\ast$D\+L\+A\+M\+B\+D\+A, double $\ast$W, const int $\ast$I\+N\+D\+X, int start, int end)
\item 
void \hyperlink{group__CORE__double_ga8d57d669e0bcef9e6fd1fd3a8592f697_ga8d57d669e0bcef9e6fd1fd3a8592f697}{C\+O\+R\+E\+\_\+dlaed3\+\_\+merge} (int n, int K, double $\ast$D, int $\ast$I\+N\+D\+X\+Q)
\item 
void \hyperlink{group__CORE__double_ga160f1c4633dd0ace97ce8ec2b89dd242_ga160f1c4633dd0ace97ce8ec2b89dd242}{C\+O\+R\+E\+\_\+dlaed3\+\_\+reduce\+W} (int n, int n1, int K, int l, const double $\ast$Q, int L\+D\+Q, const double $\ast$Wred, double $\ast$W)
\item 
void \hyperlink{group__CORE__double_ga3af898271ac8252073cd06625efc4df9_ga3af898271ac8252073cd06625efc4df9}{C\+O\+R\+E\+\_\+dlaed3\+\_\+updatevectors} (int op, int wsmode, int n, int n1, int K, int il\+\_\+nondef, int iu\+\_\+nondef, double $\ast$Q, int ldq, double $\ast$Q2, const int $\ast$ctot, double $\ast$W, int start, int end)
\item 
int \hyperlink{group__CORE__double_gab7b88d94f96333ae870c7fdafe41c194_gab7b88d94f96333ae870c7fdafe41c194}{C\+O\+R\+E\+\_\+dlaed4} (int n, int K, double $\ast$D, double beta, double $\ast$Q, int L\+D\+Q, const double $\ast$D0, const double $\ast$Z, const int $\ast$I\+N\+D\+X, int start, int end)
\item 
void \hyperlink{group__CORE__double_gad314c3ce1d85697c2edccd6763300e93_gad314c3ce1d85697c2edccd6763300e93}{C\+O\+R\+E\+\_\+dlag2s} (int m, int n, const double $\ast$A, int lda, float $\ast$B, int ldb, int $\ast$info)
\item 
void \hyperlink{group__CORE__double_ga0e4b82b2033ca8c4a3bdbfa6327810ab_ga0e4b82b2033ca8c4a3bdbfa6327810ab}{C\+O\+R\+E\+\_\+slag2d} (int m, int n, const float $\ast$A, int lda, double $\ast$B, int ldb)
\item 
void \hyperlink{group__CORE__double_ga1ecb4af5d609ccaca3c438134f1e6452_ga1ecb4af5d609ccaca3c438134f1e6452}{C\+O\+R\+E\+\_\+dlange} (int norm, int M, int N, const double $\ast$A, int L\+D\+A, double $\ast$work, double $\ast$norm\+A)
\item 
void \hyperlink{group__CORE__double_ga8b19aabbaa27e74346193ce1cda858b9_ga8b19aabbaa27e74346193ce1cda858b9}{C\+O\+R\+E\+\_\+dlansy} (int norm, P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, const double $\ast$A, int L\+D\+A, double $\ast$work, double $\ast$norm\+A)
\item 
void \hyperlink{group__CORE__double_gad604d5c2ee20d5e2c9f4e669e540bab2_gad604d5c2ee20d5e2c9f4e669e540bab2}{C\+O\+R\+E\+\_\+dlantr} (P\+L\+A\+S\+M\+A\+\_\+enum norm, P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum diag, int M, int N, const double $\ast$A, int L\+D\+A, double $\ast$work, double $\ast$norm\+A)
\item 
int \hyperlink{group__CORE__double_gabd19ac0084a19fd2763defa6d3e94e94_gabd19ac0084a19fd2763defa6d3e94e94}{C\+O\+R\+E\+\_\+dlarfb\+\_\+gemm} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int direct, int storev, int M, int N, int K, const double $\ast$V, int L\+D\+V, const double $\ast$T, int L\+D\+T, double $\ast$C, int L\+D\+C, double $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_ga80d7223148dcbf874885d5bb0707f231_ga80d7223148dcbf874885d5bb0707f231}{C\+O\+R\+E\+\_\+dlarfx2} (P\+L\+A\+S\+M\+A\+\_\+enum side, int N, double V, double T\+A\+U, double $\ast$C1, int L\+D\+C1, double $\ast$C2, int L\+D\+C2)
\item 
int \hyperlink{group__CORE__double_ga49acb5eb786b9f9dedf219519700a4ee_ga49acb5eb786b9f9dedf219519700a4ee}{C\+O\+R\+E\+\_\+dlarfx2c} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, double V, double T\+A\+U, double $\ast$C1, double $\ast$C2, double $\ast$C3)
\item 
int \hyperlink{group__CORE__double_ga202fe50b16b0e3d62660d8095892c60a_ga202fe50b16b0e3d62660d8095892c60a}{C\+O\+R\+E\+\_\+dlarfx2ce} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, double $\ast$V, double $\ast$T\+A\+U, double $\ast$C1, double $\ast$C2, double $\ast$C3)
\item 
void \hyperlink{group__CORE__double_gae4b0750d5458f4e789c2c2e46f7803db_gae4b0750d5458f4e789c2c2e46f7803db}{C\+O\+R\+E\+\_\+dlarfy} (int N, double $\ast$A, int L\+D\+A, const double $\ast$V, const double $\ast$T\+A\+U, double $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_ga2aaae67cd886ae1519b6b275399224fb_ga2aaae67cd886ae1519b6b275399224fb}{C\+O\+R\+E\+\_\+dlascal} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int m, int n, double alpha, double $\ast$A, int lda)
\item 
int \hyperlink{group__CORE__double_ga36b17d504981a34d6d99186da82e2a28_ga36b17d504981a34d6d99186da82e2a28}{C\+O\+R\+E\+\_\+dlascl} (P\+L\+A\+S\+M\+A\+\_\+enum type, int kl, int ku, double cfrom, double cto, int m, int n, double $\ast$A, int lda)
\item 
void \hyperlink{group__CORE__double_ga1c669131b52830b6553434ea23afa985_ga1c669131b52830b6553434ea23afa985}{C\+O\+R\+E\+\_\+dlaset} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, double alpha, double beta, double $\ast$A, int L\+D\+A)
\item 
void \hyperlink{group__CORE__double_ga4642e2b653e27425594106afd89c4859_ga4642e2b653e27425594106afd89c4859}{C\+O\+R\+E\+\_\+dlaset2} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, double alpha, double $\ast$A, int L\+D\+A)
\item 
void \hyperlink{group__CORE__double_ga106b201ef777b959b2233bd7d4b40305_ga106b201ef777b959b2233bd7d4b40305}{C\+O\+R\+E\+\_\+dlaswp} (int N, double $\ast$A, int L\+D\+A, int I1, int I2, const int $\ast$I\+P\+I\+V, int I\+N\+C)
\item 
int \hyperlink{group__CORE__double_gadb50a1cf5c2191046cfa1055414bcc89_gadb50a1cf5c2191046cfa1055414bcc89}{C\+O\+R\+E\+\_\+dlaswp\+\_\+ontile} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} desc\+A, int i1, int i2, const int $\ast$ipiv, int inc)
\item 
int \hyperlink{group__CORE__double_gaead98c5d81d7747aef84af1883b4bac1_gaead98c5d81d7747aef84af1883b4bac1}{C\+O\+R\+E\+\_\+dswptr\+\_\+ontile} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} desc\+A, int i1, int i2, const int $\ast$ipiv, int inc, const double $\ast$Akk, int ldak)
\item 
int \hyperlink{group__CORE__double_gab49a7c8c5a269b2358ee568c559cc948_gab49a7c8c5a269b2358ee568c559cc948}{C\+O\+R\+E\+\_\+dlaswpc\+\_\+ontile} (\hyperlink{structplasma__desc__t}{P\+L\+A\+S\+M\+A\+\_\+desc} desc\+A, int i1, int i2, const int $\ast$ipiv, int inc)
\item 
int \hyperlink{group__CORE__double_ga164bb987707f2c51fafe19b1c630d5d3_ga164bb987707f2c51fafe19b1c630d5d3}{C\+O\+R\+E\+\_\+dlatro} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M, int N, const double $\ast$A, int L\+D\+A, double $\ast$B, int L\+D\+B)
\item 
void \hyperlink{group__CORE__double_ga7b1e511d379ee30b94e0b0baf0b66661_ga7b1e511d379ee30b94e0b0baf0b66661}{C\+O\+R\+E\+\_\+dlauum} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, double $\ast$A, int L\+D\+A)
\item 
int \hyperlink{group__CORE__double_ga041e33a314b8316c8ecfa37ed236d826_ga041e33a314b8316c8ecfa37ed236d826}{C\+O\+R\+E\+\_\+dormlq} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M, int N, int K, int I\+B, const double $\ast$A, int L\+D\+A, const double $\ast$T, int L\+D\+T, double $\ast$C, int L\+D\+C, double $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_ga88f757c9197146e057b433613021da79_ga88f757c9197146e057b433613021da79}{C\+O\+R\+E\+\_\+dormqr} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M, int N, int K, int I\+B, const double $\ast$A, int L\+D\+A, const double $\ast$T, int L\+D\+T, double $\ast$C, int L\+D\+C, double $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_ga321879836e956b6c8420ebb49db208e5_ga321879836e956b6c8420ebb49db208e5}{C\+O\+R\+E\+\_\+dpamm} (int op, P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum storev, int M, int N, int K, int L, const double $\ast$A1, int L\+D\+A1, double $\ast$A2, int L\+D\+A2, const double $\ast$V, int L\+D\+V, double $\ast$W, int L\+D\+W)
\item 
int \hyperlink{group__CORE__double_gab9f985d68d7efaf1bbd811598c6eb987_gab9f985d68d7efaf1bbd811598c6eb987}{C\+O\+R\+E\+\_\+dparfb} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, P\+L\+A\+S\+M\+A\+\_\+enum direct, P\+L\+A\+S\+M\+A\+\_\+enum storev, int M1, int N1, int M2, int N2, int K, int L, double $\ast$A1, int L\+D\+A1, double $\ast$A2, int L\+D\+A2, const double $\ast$V, int L\+D\+V, const double $\ast$T, int L\+D\+T, double $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_ga7e36702038ad3e238158fef1dc86eb61_ga7e36702038ad3e238158fef1dc86eb61}{C\+O\+R\+E\+\_\+dpemv} (P\+L\+A\+S\+M\+A\+\_\+enum trans, int storev, int M, int N, int L, double A\+L\+P\+H\+A, const double $\ast$A, int L\+D\+A, const double $\ast$X, int I\+N\+C\+X, double B\+E\+T\+A, double $\ast$Y, int I\+N\+C\+Y, double $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__double_gae5ff912cce66f5666d5b76fb7da5e9e2_gae5ff912cce66f5666d5b76fb7da5e9e2}{C\+O\+R\+E\+\_\+dplgsy} (double bump, int m, int n, double $\ast$A, int lda, int g\+M, int m0, int n0, unsigned long long int seed)
\item 
void \hyperlink{group__CORE__double_gaf3c013847f99f3d28eb16c98ae5c4e11_gaf3c013847f99f3d28eb16c98ae5c4e11}{C\+O\+R\+E\+\_\+dplrnt} (int m, int n, double $\ast$A, int lda, int g\+M, int m0, int n0, unsigned long long int seed)
\item 
int \hyperlink{group__CORE__double_ga676f991618b7d88938f1d6d19d4eabc8_ga676f991618b7d88938f1d6d19d4eabc8}{C\+O\+R\+E\+\_\+dpltmg} (P\+L\+A\+S\+M\+A\+\_\+enum mtxtype, int M, int N, double $\ast$A, int L\+D\+A, int g\+M, int g\+N, int m0, int n0, unsigned long long int seed)
\item 
int \hyperlink{group__CORE__double_gab0f1d5c66afbf4770932b2a61a32b837_gab0f1d5c66afbf4770932b2a61a32b837}{C\+O\+R\+E\+\_\+dpltmg\+\_\+chebvand} (int M, int N, double $\ast$A, int L\+D\+A, int g\+N, int m0, int n0, double $\ast$W)
\item 
int \hyperlink{group__CORE__double_ga548433b2a88abe28bcf0dafdb7777833_ga548433b2a88abe28bcf0dafdb7777833}{C\+O\+R\+E\+\_\+dpltmg\+\_\+circul} (int M, int N, double $\ast$A, int L\+D\+A, int g\+M, int m0, int n0, const double $\ast$V)
\item 
void \hyperlink{group__CORE__double_ga230f3c575fe0c38f1e59a7671ab111a1_ga230f3c575fe0c38f1e59a7671ab111a1}{C\+O\+R\+E\+\_\+dpltmg\+\_\+condexq} (int M, int N, double $\ast$Q, int L\+D\+Q)
\item 
void \hyperlink{group__CORE__double_gae0a46d5ef37e8689c3ace89dac0d7d46_gae0a46d5ef37e8689c3ace89dac0d7d46}{C\+O\+R\+E\+\_\+dpltmg\+\_\+fiedler} (int M, int N, const double $\ast$X, int inc\+X, const double $\ast$Y, int inc\+Y, double $\ast$A, int L\+D\+A)
\item 
int \hyperlink{group__CORE__double_gade5dc2c549c2f807eb633058637786fb_gade5dc2c549c2f807eb633058637786fb}{C\+O\+R\+E\+\_\+dpltmg\+\_\+hankel} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, double $\ast$A, int L\+D\+A, int m0, int n0, int nb, const double $\ast$V1, const double $\ast$V2)
\item 
void \hyperlink{group__CORE__double_gae47778b25933f0e1b13d1bce66d9f0c9_gae47778b25933f0e1b13d1bce66d9f0c9}{C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd1} (int g\+M, int m0, int M, double $\ast$W, unsigned long long int seed)
\item 
void \hyperlink{group__CORE__double_ga58e55cc51125622f0a4f8135fe1c9d81_ga58e55cc51125622f0a4f8135fe1c9d81}{C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd2} (int M, int N, int K, int m0, int n0, const double $\ast$W, double $\ast$A, int L\+D\+A)
\item 
void \hyperlink{group__CORE__double_ga0971d5ea439913fdb900931d6c7a0ad1_ga0971d5ea439913fdb900931d6c7a0ad1}{C\+O\+R\+E\+\_\+dpotrf} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, double $\ast$A, int L\+D\+A, int $\ast$info)
\item 
void \hyperlink{group__CORE__double_ga13d61f05b9ffab57ab8dc28a7d2f04ac_ga13d61f05b9ffab57ab8dc28a7d2f04ac}{C\+O\+R\+E\+\_\+dsbtype1cb} (int N, int N\+B, double $\ast$A, int L\+D\+A, double $\ast$V, double $\ast$T\+A\+U, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, double $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__double_gabd46a4aa466ef8c4e71f4d05b952f652_gabd46a4aa466ef8c4e71f4d05b952f652}{C\+O\+R\+E\+\_\+dsbtype2cb} (int N, int N\+B, double $\ast$A, int L\+D\+A, double $\ast$V, double $\ast$T\+A\+U, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, double $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__double_ga740babd14602b6a1bac2235bd34fff33_ga740babd14602b6a1bac2235bd34fff33}{C\+O\+R\+E\+\_\+dsbtype3cb} (int N, int N\+B, double $\ast$A, int L\+D\+A, const double $\ast$V, const double $\ast$T\+A\+U, int st, int ed, int sweep, int Vblksiz, int W\+A\+N\+T\+Z, double $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__double_ga470a57a47ccf26158cb24e925c850aca_ga470a57a47ccf26158cb24e925c850aca}{C\+O\+R\+E\+\_\+dsetvar} (const double $\ast$alpha, double $\ast$x)
\item 
void \hyperlink{group__CORE__double_gaa5faaea7077323e921ad2c92e12a15c1_gaa5faaea7077323e921ad2c92e12a15c1}{C\+O\+R\+E\+\_\+dshiftw} (int s, int cl, int m, int n, int L, double $\ast$A, double $\ast$W)
\item 
int \hyperlink{group__CORE__double_ga307f80b43bbc184b00aeac63931c28b2_ga307f80b43bbc184b00aeac63931c28b2}{C\+O\+R\+E\+\_\+dssssm} (int M1, int N1, int M2, int N2, int K, int I\+B, double $\ast$A1, int L\+D\+A1, double $\ast$A2, int L\+D\+A2, const double $\ast$L1, int L\+D\+L1, const double $\ast$L2, int L\+D\+L2, const int $\ast$I\+P\+I\+V)
\item 
int \hyperlink{group__CORE__double_gab985a11c7b456c6d198d57a7b2f16769_gab985a11c7b456c6d198d57a7b2f16769}{C\+O\+R\+E\+\_\+dstedc} (P\+L\+A\+S\+M\+A\+\_\+enum compz, int n, double $\ast$D, double $\ast$E, double $\ast$Z, int L\+D\+Z, double $\ast$W\+O\+R\+K, int L\+W\+O\+R\+K, int $\ast$I\+W\+O\+R\+K, int L\+I\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_gafc01ee65617fee823278fb6ad75dc6ea_gafc01ee65617fee823278fb6ad75dc6ea}{C\+O\+R\+E\+\_\+dsteqr} (P\+L\+A\+S\+M\+A\+\_\+enum compz, int n, double $\ast$D, double $\ast$E, double $\ast$Z, int L\+D\+Z, double $\ast$W\+O\+R\+K)
\item 
void \hyperlink{group__CORE__double_ga2a3bd8a49ed2aa43c45e142531c0b18f_ga2a3bd8a49ed2aa43c45e142531c0b18f}{C\+O\+R\+E\+\_\+dswap} (int m, int n, double $\ast$Q, int ldq, const double $\ast$work, const int $\ast$perm, int start, int end)
\item 
void \hyperlink{group__CORE__double_ga3983570062ad523e1ad59613e1fdc9eb_ga3983570062ad523e1ad59613e1fdc9eb}{C\+O\+R\+E\+\_\+dswpab} (int i, int n1, int n2, double $\ast$A, double $\ast$work)
\item 
void \hyperlink{group__CORE__double_ga6e726df73c21c70ca2a790d2f54d6852_ga6e726df73c21c70ca2a790d2f54d6852}{C\+O\+R\+E\+\_\+dsygst} (int itype, P\+L\+A\+S\+M\+A\+\_\+enum uplo, int N, double $\ast$A, int L\+D\+A, double $\ast$B, int L\+D\+B, int $\ast$I\+N\+F\+O)
\item 
void \hyperlink{group__CORE__double_ga8da8500bfcaab1c2d482e16cd3774587_ga8da8500bfcaab1c2d482e16cd3774587}{C\+O\+R\+E\+\_\+dsymm} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum uplo, int M, int N, double alpha, const double $\ast$A, int L\+D\+A, const double $\ast$B, int L\+D\+B, double beta, double $\ast$C, int L\+D\+C)
\item 
void \hyperlink{group__CORE__double_ga55ae098bde1db27aa5e48217fde7161c_ga55ae098bde1db27aa5e48217fde7161c}{C\+O\+R\+E\+\_\+dsyr2k} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans, int N, int K, double alpha, const double $\ast$A, int L\+D\+A, const double $\ast$B, int L\+D\+B, double beta, double $\ast$C, int L\+D\+C)
\item 
int \hyperlink{group__CORE__double_ga48b7ed94f1b65f6a0f070fcd1375348a_ga48b7ed94f1b65f6a0f070fcd1375348a}{C\+O\+R\+E\+\_\+dsyrfb} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, int n, int k, int ib, int nb, const double $\ast$A, int lda, const double $\ast$T, int ldt, double $\ast$C, int ldc, double $\ast$W\+O\+R\+K, int ldwork)
\item 
void \hyperlink{group__CORE__double_gae955397a1509aade89dd6c33cbd46d88_gae955397a1509aade89dd6c33cbd46d88}{C\+O\+R\+E\+\_\+dsyrk} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans, int N, int K, double alpha, const double $\ast$A, int L\+D\+A, double beta, double $\ast$C, int L\+D\+C)
\item 
int \hyperlink{group__CORE__double_ga36e584eda1f30774893edc6f205705ee_ga36e584eda1f30774893edc6f205705ee}{C\+O\+R\+E\+\_\+dtradd} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M, int N, double alpha, const double $\ast$A, int L\+D\+A, double beta, double $\ast$B, int L\+D\+B)
\item 
void \hyperlink{group__CORE__double_gaeda54b92bd167ce4b3b2e9b84e588fd7_gaeda54b92bd167ce4b3b2e9b84e588fd7}{C\+O\+R\+E\+\_\+dtrasm} (P\+L\+A\+S\+M\+A\+\_\+enum storev, P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum diag, int M, int N, const double $\ast$A, int lda, double $\ast$work)
\item 
void \hyperlink{group__CORE__double_ga5b86142ed209d6ff1ae914d3d2198fe4_ga5b86142ed209d6ff1ae914d3d2198fe4}{C\+O\+R\+E\+\_\+dtrdalg1} (int n, int nb, double $\ast$A, int lda, double $\ast$V, double $\ast$T\+A\+U, int Vblksiz, int wantz, int i, int sweepid, int m, int grsiz, double $\ast$work)
\item 
void \hyperlink{group__CORE__double_gaac031425cb643fc8dd2ca59ae14aa299_gaac031425cb643fc8dd2ca59ae14aa299}{C\+O\+R\+E\+\_\+dtrmm} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans\+A, P\+L\+A\+S\+M\+A\+\_\+enum diag, int M, int N, double alpha, const double $\ast$A, int L\+D\+A, double $\ast$B, int L\+D\+B)
\item 
void \hyperlink{group__CORE__double_ga01d4724a8dc091661b4fc3049ec04cdd_ga01d4724a8dc091661b4fc3049ec04cdd}{C\+O\+R\+E\+\_\+dtrsm} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum trans\+A, P\+L\+A\+S\+M\+A\+\_\+enum diag, int M, int N, double alpha, const double $\ast$A, int L\+D\+A, double $\ast$B, int L\+D\+B)
\item 
void \hyperlink{group__CORE__double_gae38b32f77aa0a15b60c7a4130ca39615_gae38b32f77aa0a15b60c7a4130ca39615}{C\+O\+R\+E\+\_\+dtrtri} (P\+L\+A\+S\+M\+A\+\_\+enum uplo, P\+L\+A\+S\+M\+A\+\_\+enum diag, int N, double $\ast$A, int L\+D\+A, int $\ast$info)
\item 
int \hyperlink{group__CORE__double_ga0cd12ddad904abd1a00df453bc5bb126_ga0cd12ddad904abd1a00df453bc5bb126}{C\+O\+R\+E\+\_\+dtslqt} (int M, int N, int I\+B, double $\ast$A1, int L\+D\+A1, double $\ast$A2, int L\+D\+A2, double $\ast$T, int L\+D\+T, double $\ast$T\+A\+U, double $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_gafb81efeef8942dd4b3bd85d3e58d3c8c_gafb81efeef8942dd4b3bd85d3e58d3c8c}{C\+O\+R\+E\+\_\+dtsmlq} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M1, int N1, int M2, int N2, int K, int I\+B, double $\ast$A1, int L\+D\+A1, double $\ast$A2, int L\+D\+A2, const double $\ast$V, int L\+D\+V, const double $\ast$T, int L\+D\+T, double $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_gab75e15e330b097d4cb04e580b526c37d_gab75e15e330b097d4cb04e580b526c37d}{C\+O\+R\+E\+\_\+dtsmlq\+\_\+corner} (int m1, int n1, int m2, int n2, int m3, int n3, int k, int ib, int nb, double $\ast$A1, int lda1, double $\ast$A2, int lda2, double $\ast$A3, int lda3, const double $\ast$V, int ldv, const double $\ast$T, int ldt, double $\ast$W\+O\+R\+K, int ldwork)
\item 
int \hyperlink{group__CORE__double_ga4efacaf4c386e7c5cef9cd111d910ad9_ga4efacaf4c386e7c5cef9cd111d910ad9}{C\+O\+R\+E\+\_\+dtsmlq\+\_\+sytra1} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int m1, int n1, int m2, int n2, int k, int ib, double $\ast$A1, int lda1, double $\ast$A2, int lda2, const double $\ast$V, int ldv, const double $\ast$T, int ldt, double $\ast$W\+O\+R\+K, int ldwork)
\item 
int \hyperlink{group__CORE__double_gae324a24ebf7b2b6009f63454134d5824_gae324a24ebf7b2b6009f63454134d5824}{C\+O\+R\+E\+\_\+dtsmqr} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M1, int N1, int M2, int N2, int K, int I\+B, double $\ast$A1, int L\+D\+A1, double $\ast$A2, int L\+D\+A2, const double $\ast$V, int L\+D\+V, const double $\ast$T, int L\+D\+T, double $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_ga502c8674867dfe112ce5fc9ac8ca1be7_ga502c8674867dfe112ce5fc9ac8ca1be7}{C\+O\+R\+E\+\_\+dtsmqr\+\_\+corner} (int m1, int n1, int m2, int n2, int m3, int n3, int k, int ib, int nb, double $\ast$A1, int lda1, double $\ast$A2, int lda2, double $\ast$A3, int lda3, const double $\ast$V, int ldv, const double $\ast$T, int ldt, double $\ast$W\+O\+R\+K, int ldwork)
\item 
int \hyperlink{group__CORE__double_ga2a731f8fc79ae3f45e1d006a83c5dc6e_ga2a731f8fc79ae3f45e1d006a83c5dc6e}{C\+O\+R\+E\+\_\+dtsmqr\+\_\+sytra1} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int m1, int n1, int m2, int n2, int k, int ib, double $\ast$A1, int lda1, double $\ast$A2, int lda2, const double $\ast$V, int ldv, const double $\ast$T, int ldt, double $\ast$W\+O\+R\+K, int ldwork)
\item 
int \hyperlink{group__CORE__double_ga6e39a0a7ef341418aa3cc2056f447b2c_ga6e39a0a7ef341418aa3cc2056f447b2c}{C\+O\+R\+E\+\_\+dtsqrt} (int M, int N, int I\+B, double $\ast$A1, int L\+D\+A1, double $\ast$A2, int L\+D\+A2, double $\ast$T, int L\+D\+T, double $\ast$T\+A\+U, double $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_ga19d4b2953d6e1f639990267b2b68fcc9_ga19d4b2953d6e1f639990267b2b68fcc9}{C\+O\+R\+E\+\_\+dtstrf} (int M, int N, int I\+B, int N\+B, double $\ast$U, int L\+D\+U, double $\ast$A, int L\+D\+A, double $\ast$L, int L\+D\+L, int $\ast$I\+P\+I\+V, double $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K, int $\ast$I\+N\+F\+O)
\item 
int \hyperlink{group__CORE__double_ga4016fab866fa44b3f0926b1a99e06348_ga4016fab866fa44b3f0926b1a99e06348}{C\+O\+R\+E\+\_\+dttlqt} (int M, int N, int I\+B, double $\ast$A1, int L\+D\+A1, double $\ast$A2, int L\+D\+A2, double $\ast$T, int L\+D\+T, double $\ast$T\+A\+U, double $\ast$W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_gaa5facd81cc090e201d164e9802e5b5a3_gaa5facd81cc090e201d164e9802e5b5a3}{C\+O\+R\+E\+\_\+dttmlq} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M1, int N1, int M2, int N2, int K, int I\+B, double $\ast$A1, int L\+D\+A1, double $\ast$A2, int L\+D\+A2, const double $\ast$V, int L\+D\+V, const double $\ast$T, int L\+D\+T, double $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_ga5ff20296ac5424b6a431f514771bac87_ga5ff20296ac5424b6a431f514771bac87}{C\+O\+R\+E\+\_\+dttmqr} (P\+L\+A\+S\+M\+A\+\_\+enum side, P\+L\+A\+S\+M\+A\+\_\+enum trans, int M1, int N1, int M2, int N2, int K, int I\+B, double $\ast$A1, int L\+D\+A1, double $\ast$A2, int L\+D\+A2, const double $\ast$V, int L\+D\+V, const double $\ast$T, int L\+D\+T, double $\ast$W\+O\+R\+K, int L\+D\+W\+O\+R\+K)
\item 
int \hyperlink{group__CORE__double_ga28849d5bca87c3e7f82a32f838c32588_ga28849d5bca87c3e7f82a32f838c32588}{C\+O\+R\+E\+\_\+dttqrt} (int M, int N, int I\+B, double $\ast$A1, int L\+D\+A1, double $\ast$A2, int L\+D\+A2, double $\ast$T, int L\+D\+T, double $\ast$T\+A\+U, double $\ast$W\+O\+R\+K)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This is the group of double real kernels available in coreblas library. 

\subsection{Macro Definition Documentation}
\hypertarget{group__CORE__double_ga53dc4af00adc7b3b4d12eafb71596dfc_ga53dc4af00adc7b3b4d12eafb71596dfc}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!S\+E\+L\+E\+C\+T@{S\+E\+L\+E\+C\+T}}
\index{S\+E\+L\+E\+C\+T@{S\+E\+L\+E\+C\+T}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{S\+E\+L\+E\+C\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define S\+E\+L\+E\+C\+T~20}\label{group__CORE__double_ga53dc4af00adc7b3b4d12eafb71596dfc_ga53dc4af00adc7b3b4d12eafb71596dfc}
C\+O\+R\+E\+\_\+dlapst -\/ It is a modified version of the L\+A\+P\+A\+C\+K routine D inspired from the Sca\+L\+A\+P\+A\+C\+K dlapst.

Define a permutation I\+N\+D\+X that sorts the numbers in D in increasing order (if I\+D = \textquotesingle{}I\textquotesingle{}) or in decreasing order (if I\+D = \textquotesingle{}D\textquotesingle{} ).

Use Quick Sort, reverting to Insertion sort on arrays of size $<$= 20. Dimension of S\+T\+A\+C\+K limits N to about 2$\ast$$\ast$32.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em type} & The type of sorting \textquotesingle{}Plasma\+Increasing\+Order\textquotesingle{} for increasing order \textquotesingle{}Plasma\+Decreasing\+Order\textquotesingle{} for decreasing order\\
\hline
\mbox{\tt in}  & {\em n} & n specifies the dimension of the array D\\
\hline
\mbox{\tt in}  & {\em D} & D is the array to be sorted of dimension n.\\
\hline
\mbox{\tt out}  & {\em I\+N\+D\+X} & On exit, contains the permutation which sorts the array D. I\+N\+D\+X is of dimension n. \\
\hline
\end{DoxyParams}


\subsection{Function Documentation}
\hypertarget{group__CORE__double_ga11c4e4a071c38e9623b0a1279cb73499_ga11c4e4a071c38e9623b0a1279cb73499}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dasum@{C\+O\+R\+E\+\_\+dasum}}
\index{C\+O\+R\+E\+\_\+dasum@{C\+O\+R\+E\+\_\+dasum}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dasum}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dasum (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{storev, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const double $\ast$}]{A, }
\item[{int}]{lda, }
\item[{double $\ast$}]{work}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga11c4e4a071c38e9623b0a1279cb73499_ga11c4e4a071c38e9623b0a1279cb73499}
C\+O\+R\+E\+\_\+dasum -\/ Computes the sums of the absolute values of elements in a same row or column. This function is an auxiliary function to norm computations.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em storev} & Specifies whether the sums are made per column or row. = Plasma\+Columnwise\+: Computes the sum on each column = Plasma\+Rowwise\+: Computes the sum on each row\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular or general = Plasma\+Upper\+Lower\+: All matrix A is referenced; = Plasma\+Upper\+: Upper triangle of A is referenced; = Plasma\+Lower\+: Lower triangle of A is referenced.\\
\hline
\mbox{\tt in}  & {\em M} & M specifies the number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & A is a M-\/by-\/\+N matrix.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. lda $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em work} & Array of dimension M if storev = Plasma\+Rowwise; N otherwise. On exit, contains the sums of the absolute values per column or row. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga7e2b483dffea59c30d89f188b2c7be40_ga7e2b483dffea59c30d89f188b2c7be40}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dbrdalg1@{C\+O\+R\+E\+\_\+dbrdalg1}}
\index{C\+O\+R\+E\+\_\+dbrdalg1@{C\+O\+R\+E\+\_\+dbrdalg1}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dbrdalg1}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dbrdalg1 (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{n, }
\item[{int}]{nb, }
\item[{double $\ast$}]{A, }
\item[{int}]{lda, }
\item[{double $\ast$}]{V\+Q, }
\item[{double $\ast$}]{T\+A\+U\+Q, }
\item[{double $\ast$}]{V\+P, }
\item[{double $\ast$}]{T\+A\+U\+P, }
\item[{int}]{Vblksiz, }
\item[{int}]{wantz, }
\item[{int}]{i, }
\item[{int}]{sweepid, }
\item[{int}]{m, }
\item[{int}]{grsiz, }
\item[{double $\ast$}]{work}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga7e2b483dffea59c30d89f188b2c7be40_ga7e2b483dffea59c30d89f188b2c7be40}
C\+O\+R\+E\+\_\+dbrdalg1 is a part of the bidiagonal reduction algorithm (bulgechasing). It correspond to a local driver of the kernels that should be executed on a single core.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em n} & The order of the matrix A. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The size of the Bandwidth of the matrix A, which correspond to the tile size. nb $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & double array, dimension (lda,n) On entry, the (2nb+1)-\/by-\/n lower or upper band general matrix to be reduced to bidiagonal. On exit, if uplo = Plasma\+Upper, the diagonal and first superdiagonal of A are overwritten by the corresponding elements of the bidiagonal matrix B. if uplo = Plasma\+Lower the diagonal and first subdiagonal of A are overwritten by the corresponding elements of the elements of the bidiagonal matrix B.\\
\hline
\mbox{\tt in}  & {\em lda} & (input) I\+N\+T\+E\+G\+E\+R The leading dimension of the array A. L\+D\+A $>$= max(1,nb+1).\\
\hline
\mbox{\tt out}  & {\em V\+Q} & double array, dimension (n) if wantz=0 or ldv$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar elementary left reflectors are written in this array.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+Q} & double array, dimension (n) if wantz=0 or Vblksiz$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar factors of the left elementary reflectors are written in this array.\\
\hline
\mbox{\tt in}  & {\em V\+P} & double array, dimension (n) if wantz=0 or ldv$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar elementary right reflectors are written in this array.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U\+P} & double array, dimension (n) if wantz=0 or Vblksiz$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar factors of the right elementary reflectors are written in this array.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & Local parameter to Plasma. It correspond to the local bloccking of the apply\+Q2 used to apply the orthogonal matrix Q2.\\
\hline
\mbox{\tt in}  & {\em wantz} & integer tobe 0 or 1. if wantz=0 the V and T\+A\+U are not stored on only they are kept for next step then overwritten.\\
\hline
\mbox{\tt in}  & {\em i} & Integer that refer to the current sweep. (outer loop).\\
\hline
\mbox{\tt in}  & {\em sweepid} & Integer that refer to the sweep to chase.(inner loop).\\
\hline
\mbox{\tt in}  & {\em m} & Integer that refer to a sweep step, to ensure order dependencies.\\
\hline
\mbox{\tt in}  & {\em grsiz} & Integer that refer to the size of a group. group mean the number of kernel that should be executed sequentially on the same core. group size is a trade-\/off between locality (cache reuse) and parallelism. a small group size increase parallelism while a large group size increase cache reuse.\\
\hline
\mbox{\tt in}  & {\em work} & Workspace of size nb. Used by the core\+\_\+dgbtype\mbox{[}123\mbox{]}cb. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gaad4a5ec87fa6d69ba1a6fb03f7b3963d_gaad4a5ec87fa6d69ba1a6fb03f7b3963d}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgbelr@{C\+O\+R\+E\+\_\+dgbelr}}
\index{C\+O\+R\+E\+\_\+dgbelr@{C\+O\+R\+E\+\_\+dgbelr}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgbelr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgbelr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{double $\ast$}]{V, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaad4a5ec87fa6d69ba1a6fb03f7b3963d_gaad4a5ec87fa6d69ba1a6fb03f7b3963d}
C\+O\+R\+E\+\_\+dgbelr is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel eliminate a column by an element-\/wise annihiliation, and for each annihiliation, it apply a left update, followed by an right update on the diagonal 2x2 element, where it create a new nnz, eliminate it and update V and T\+A\+U, then it continue until finishing the the whole column. When this is done, it take advantage that data are on cache and will apply the right on the remaining part of this region that has not been updated by the right yet. Note that the column to be eliminated is located at st-\/1.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & double array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & double array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga33d2edbfc8d4322981b57243433758e8_ga33d2edbfc8d4322981b57243433758e8}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgblrx@{C\+O\+R\+E\+\_\+dgblrx}}
\index{C\+O\+R\+E\+\_\+dgblrx@{C\+O\+R\+E\+\_\+dgblrx}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgblrx}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgblrx (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{double $\ast$}]{V, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga33d2edbfc8d4322981b57243433758e8_ga33d2edbfc8d4322981b57243433758e8}
C\+O\+R\+E\+\_\+dgblrx is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a left update, followed by an right and for each annihiliation, it apply a left update, followed by an right update on the diagonal 2x2 element, where it create a new nnz, eliminate it and update V and T\+A\+U, then it continue until finishing the the whole column. When this is done, it take advantage that data are on cache and will apply the right on the remaining part of this region that has not been updated by the right yet.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & double array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & double array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gaf8beaaa27cb9a11f78eac099fbacd4b8_gaf8beaaa27cb9a11f78eac099fbacd4b8}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgbrce@{C\+O\+R\+E\+\_\+dgbrce}}
\index{C\+O\+R\+E\+\_\+dgbrce@{C\+O\+R\+E\+\_\+dgbrce}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgbrce}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgbrce (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{double $\ast$}]{V, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaf8beaaa27cb9a11f78eac099fbacd4b8_gaf8beaaa27cb9a11f78eac099fbacd4b8}
C\+O\+R\+E\+\_\+dgbrce is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a right update, create a new nnz, then it eliminate it, and move to the next right update, create a new nnz, eliminate it and so on until finishing. When this is done, it take advantage that data are on cache and will apply the left on the remaining part of this region that has not been updated by the left yet.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & double array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & double array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gaf7c14d4df0b70516d0b7dba06a76eaa5_gaf7c14d4df0b70516d0b7dba06a76eaa5}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgbtype1cb@{C\+O\+R\+E\+\_\+dgbtype1cb}}
\index{C\+O\+R\+E\+\_\+dgbtype1cb@{C\+O\+R\+E\+\_\+dgbtype1cb}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgbtype1cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dgbtype1cb (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{V\+Q, }
\item[{double $\ast$}]{T\+A\+U\+Q, }
\item[{double $\ast$}]{V\+P, }
\item[{double $\ast$}]{T\+A\+U\+P, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaf7c14d4df0b70516d0b7dba06a76eaa5_gaf7c14d4df0b70516d0b7dba06a76eaa5}
C\+O\+R\+E\+\_\+dgbtype1cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel eliminate a column by an column-\/wise annihiliation, then it apply a left+right update on the hermitian triangle. Note that the column to be eliminated is located at st-\/1.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (3$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,3$\ast$\+N\+B+1)\\
\hline
\mbox{\tt out}  & {\em V\+P} & T\+O\+D\+O\+: Check and fix doc double array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+P} & T\+O\+D\+O\+: Check and fix doc double array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt out}  & {\em V\+Q} & T\+O\+D\+O\+: Check and fix doc double array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+Q} & T\+O\+D\+O\+: Check and fix doc double array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga110e47047bf9b4e72abf8e9b5ceeb05f_ga110e47047bf9b4e72abf8e9b5ceeb05f}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgbtype2cb@{C\+O\+R\+E\+\_\+dgbtype2cb}}
\index{C\+O\+R\+E\+\_\+dgbtype2cb@{C\+O\+R\+E\+\_\+dgbtype2cb}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgbtype2cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dgbtype2cb (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{V\+Q, }
\item[{double $\ast$}]{T\+A\+U\+Q, }
\item[{double $\ast$}]{V\+P, }
\item[{double $\ast$}]{T\+A\+U\+P, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga110e47047bf9b4e72abf8e9b5ceeb05f_ga110e47047bf9b4e72abf8e9b5ceeb05f}
C\+O\+R\+E\+\_\+dgbtype2cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply the right update remaining from the type1 and this later will create a bulge so it eliminate the first column of the created bulge and do the corresponding Left update.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (3$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,3$\ast$\+N\+B+1)\\
\hline
\mbox{\tt in,out}  & {\em V\+P} & T\+O\+D\+O\+: Check and fix doc double array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in,out}  & {\em T\+A\+U\+P} & T\+O\+D\+O\+: Check and fix doc double array, dimension (N). The scalar factors of the Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in,out}  & {\em V\+Q} & T\+O\+D\+O\+: Check and fix doc double array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in,out}  & {\em T\+A\+U\+Q} & T\+O\+D\+O\+: Check and fix doc double array, dimension (N). The scalar factors of the Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga7e6f6499c138a6d38ed8a0908ddee64c_ga7e6f6499c138a6d38ed8a0908ddee64c}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgbtype3cb@{C\+O\+R\+E\+\_\+dgbtype3cb}}
\index{C\+O\+R\+E\+\_\+dgbtype3cb@{C\+O\+R\+E\+\_\+dgbtype3cb}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgbtype3cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dgbtype3cb (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{V\+Q, }
\item[{double $\ast$}]{T\+A\+U\+Q, }
\item[{double $\ast$}]{V\+P, }
\item[{double $\ast$}]{T\+A\+U\+P, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga7e6f6499c138a6d38ed8a0908ddee64c_ga7e6f6499c138a6d38ed8a0908ddee64c}
C\+O\+R\+E\+\_\+dgbtype3cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a left+right update on the hermitian triangle. Note that this kernel is very similar to type1 but does not do an elimination.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (3$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,3$\ast$\+N\+B+1)\\
\hline
\mbox{\tt in}  & {\em V\+P} & T\+O\+D\+O\+: Check and fix doc double array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U\+P} & T\+O\+D\+O\+: Check and fix doc double array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em V\+Q} & T\+O\+D\+O\+: Check and fix doc double array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U\+Q} & T\+O\+D\+O\+: Check and fix doc double array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gaca52e4d3203bb82422d184f8970b9968_gaca52e4d3203bb82422d184f8970b9968}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgeadd@{C\+O\+R\+E\+\_\+dgeadd}}
\index{C\+O\+R\+E\+\_\+dgeadd@{C\+O\+R\+E\+\_\+dgeadd}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgeadd}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgeadd (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double}]{alpha, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double}]{beta, }
\item[{double $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaca52e4d3203bb82422d184f8970b9968_gaca52e4d3203bb82422d184f8970b9968}
C\+O\+R\+E\+\_\+dgeadd adds two matrices together as in P\+B\+L\+A\+S pdgeadd. \begin{DoxyVerb} B <- alpha * op(A)  + beta * B,
\end{DoxyVerb}


where op(\+X) = X, X\textquotesingle{}, or (X\textquotesingle{})


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is non-\/transposed, transposed, or ugate transposed = Plasma\+No\+Trans\+: op(\+A) = A = Plasma\+Trans\+: op(\+A) = A\textquotesingle{} = Plasma\+Trans\+: op(\+A) = (A\textquotesingle{})\\
\hline
\mbox{\tt in}  & {\em M} & Number of rows of the matrices op(\+A) and B.\\
\hline
\mbox{\tt in}  & {\em N} & Number of columns of the matrices op(\+A) and B.\\
\hline
\mbox{\tt in}  & {\em alpha} & Scalar factor of A.\\
\hline
\mbox{\tt in}  & {\em A} & Matrix of size L\+D\+A-\/by-\/\+N, if trans = Plasma\+No\+Trans, L\+D\+A-\/by-\/\+M otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & Leading dimension of the array A. L\+D\+A $>$= max(1,k), with k=M, if trans = Plasma\+No\+Trans, and k=N otherwise.\\
\hline
\mbox{\tt in}  & {\em beta} & Scalar factor of B.\\
\hline
\mbox{\tt in,out}  & {\em B} & Matrix of size L\+D\+B-\/by-\/\+N. On exit, B = alpha $\ast$ op(\+A) + beta $\ast$ B\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & Leading dimension of the array B. L\+D\+B $>$= max(1,\+M)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga2bff35db3d30069fcb9fde474e642f03_ga2bff35db3d30069fcb9fde474e642f03}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgelqt@{C\+O\+R\+E\+\_\+dgelqt}}
\index{C\+O\+R\+E\+\_\+dgelqt@{C\+O\+R\+E\+\_\+dgelqt}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgelqt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgelqt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga2bff35db3d30069fcb9fde474e642f03_ga2bff35db3d30069fcb9fde474e642f03}
C\+O\+R\+E\+\_\+dgelqt -\/ computes a L\+Q factorization of a complex M-\/by-\/\+N tile A\+: A = L $\ast$ Q.

The tile Q is represented as a product of elementary reflectors

Q = H(k)\textquotesingle{} . . . H(2)\textquotesingle{} H(1)\textquotesingle{}, where k = min(\+M,\+N).

Each H(i) has the form

H(i) = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a complex scalar, and v is a complex vector with v(1\+:i-\/1) = 0 and v(i) = 1; g(v(i+1\+:n)) is stored on exit in A(i,i+1\+:n), and tau in T\+A\+U(i).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile A. On exit, the elements on and below the diagonal of the array contain the M-\/by-\/min(M,N) lower trapezoidal tile L (L is lower triangular if M $<$= N); the elements above the diagonal, with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga0f4f7fdf0eb156d55c71386eb1b76d1e_ga0f4f7fdf0eb156d55c71386eb1b76d1e}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgemm@{C\+O\+R\+E\+\_\+dgemm}}
\index{C\+O\+R\+E\+\_\+dgemm@{C\+O\+R\+E\+\_\+dgemm}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgemm}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dgemm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans\+A, }
\item[{int}]{trans\+B, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{double}]{alpha, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const double $\ast$}]{B, }
\item[{int}]{L\+D\+B, }
\item[{double}]{beta, }
\item[{double $\ast$}]{C, }
\item[{int}]{L\+D\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga0f4f7fdf0eb156d55c71386eb1b76d1e_ga0f4f7fdf0eb156d55c71386eb1b76d1e}
C\+O\+R\+E\+\_\+dgemm -\/ Performs one of the matrix-\/matrix operations

\[ C = \alpha [op( A )\times op( B )] + \beta C \],

where op( X ) is one of

op( X ) = X or op( X ) = X\textquotesingle{} or op( X ) = g( X\textquotesingle{} )

alpha and beta are scalars, and A, B and C are matrices, with op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em trans\+A} & Specifies whether the matrix A is transposed, not transposed or ugate transposed\+: = Plasma\+No\+Trans\+: A is not transposed; = Plasma\+Trans\+: A is transposed; = Plasma\+Trans\+: A is ugate transposed.\\
\hline
\mbox{\tt in}  & {\em trans\+B} & Specifies whether the matrix B is transposed, not transposed or ugate transposed\+: = Plasma\+No\+Trans\+: B is not transposed; = Plasma\+Trans\+: B is transposed; = Plasma\+Trans\+: B is ugate transposed.\\
\hline
\mbox{\tt in}  & {\em M} & M specifies the number of rows of the matrix op( A ) and of the matrix C. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the number of columns of the matrix op( B ) and of the matrix C. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of columns of the matrix op( A ) and the number of rows of the matrix op( B ). K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha\\
\hline
\mbox{\tt in}  & {\em A} & A is a L\+D\+A-\/by-\/ka matrix, where ka is K when trans\+A = Plasma\+No\+Trans, and is M otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em B} & B is a L\+D\+B-\/by-\/kb matrix, where kb is N when trans\+B = Plasma\+No\+Trans, and is K otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+N).\\
\hline
\mbox{\tt in}  & {\em beta} & beta specifies the scalar beta\\
\hline
\mbox{\tt in,out}  & {\em C} & C is a L\+D\+C-\/by-\/\+N matrix. On exit, the array is overwritten by the M by N matrix ( alpha$\ast$op( A )$\ast$op( B ) + beta$\ast$\+C )\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gad5d21bddba2726e03cf218681e559d36_gad5d21bddba2726e03cf218681e559d36}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgemv@{C\+O\+R\+E\+\_\+dgemv}}
\index{C\+O\+R\+E\+\_\+dgemv@{C\+O\+R\+E\+\_\+dgemv}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgemv}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dgemv (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{double}]{alpha, }
\item[{const double $\ast$}]{A, }
\item[{int}]{lda, }
\item[{const double $\ast$}]{x, }
\item[{int}]{incx, }
\item[{double}]{beta, }
\item[{double $\ast$}]{y, }
\item[{int}]{incy}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gad5d21bddba2726e03cf218681e559d36_gad5d21bddba2726e03cf218681e559d36}
C\+O\+R\+E\+\_\+dgemv performs one of the matrix-\/vector operations

y \+:= alpha$\ast$\+A$\ast$x + beta$\ast$y, or y \+:= alpha$\ast$\+A$\ast$$\ast$\+T$\ast$x + beta$\ast$y, or y \+:= alpha$\ast$\+A$\ast$$\ast$\+T$\ast$x + beta$\ast$y,

where alpha and beta are scalars, x and y are vectors, and A is an m by n matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans\+: y \+:= alpha$\ast$\+A$\ast$x + beta$\ast$y \item Plasma\+Trans\+: y \+:= alpha$\ast$\+A$\ast$$\ast$\+T$\ast$x + beta$\ast$y \item Plasma\+Trans\+: y \+:= alpha$\ast$\+A$\ast$$\ast$\+T$\ast$x + beta$\ast$y\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em m} & Number of rows of matrix A.\\
\hline
\mbox{\tt in}  & {\em n} & Number of columns of matrix A.\\
\hline
\mbox{\tt in}  & {\em alpha} & Scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & On entry, m by n matrix A. Dimension (lda,n).\\
\hline
\mbox{\tt in}  & {\em lda} & Leading dimension of array A. lda $>$= max(1,m).\\
\hline
\mbox{\tt in}  & {\em x} & On entry, vector x. If trans == Plasma\+No\+Trans, the n vector x has dimension 1 + (n-\/1)$\ast$abs(incx). Else, the m vector x has dimension 1 + (m-\/1)$\ast$abs(incx).\\
\hline
\mbox{\tt in}  & {\em incx} & Increment between elements of x. incx must not be zero.\\
\hline
\mbox{\tt in}  & {\em beta} & Scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em y} & On entry, vector y. On exit, y is overwritten by updated vector y. If trans == Plasma\+No\+Trans, the m vector y has dimension 1 + (m-\/1)$\ast$abs(incy). Else, the n vector y has dimension 1 + (n-\/1)$\ast$abs(incy).\\
\hline
\mbox{\tt in}  & {\em incy} & Increment between elements of y. incy must not be zero. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga04c474827ce4bd9af88919a8734dd6e7_ga04c474827ce4bd9af88919a8734dd6e7}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgeqp3\+\_\+init@{C\+O\+R\+E\+\_\+dgeqp3\+\_\+init}}
\index{C\+O\+R\+E\+\_\+dgeqp3\+\_\+init@{C\+O\+R\+E\+\_\+dgeqp3\+\_\+init}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgeqp3\+\_\+init}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dgeqp3\+\_\+init (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{int $\ast$}]{jpvt}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga04c474827ce4bd9af88919a8734dd6e7_ga04c474827ce4bd9af88919a8734dd6e7}
C\+O\+R\+E\+\_\+dgeqp3\+\_\+init initializes jpvt to \mbox{[}1, ..., n\mbox{]}. Uses 1-\/based indexing for Fortran compatability.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & Size of vector.\\
\hline
\mbox{\tt in,out}  & {\em jpvt} & Vector of size n. On exit, jpvt\mbox{[}i\mbox{]} = i+1. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga1ada7f30a1198540065ca3393f27ea73_ga1ada7f30a1198540065ca3393f27ea73}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgeqp3\+\_\+larfg@{C\+O\+R\+E\+\_\+dgeqp3\+\_\+larfg}}
\index{C\+O\+R\+E\+\_\+dgeqp3\+\_\+larfg@{C\+O\+R\+E\+\_\+dgeqp3\+\_\+larfg}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgeqp3\+\_\+larfg}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dgeqp3\+\_\+larfg (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{A, }
\item[{int}]{ii, }
\item[{int}]{jj, }
\item[{int}]{i, }
\item[{int}]{j, }
\item[{double $\ast$}]{tau, }
\item[{double $\ast$}]{beta}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga1ada7f30a1198540065ca3393f27ea73_ga1ada7f30a1198540065ca3393f27ea73}
C\+O\+R\+E\+\_\+dgeqp3\+\_\+larfg generates a Householder elementary reflector H, such that \begin{DoxyVerb}H**T * x = [ beta ]  and  H**T * H = I.
           [ 0    ]
\end{DoxyVerb}


where alpha and beta are scalars, with beta real, and x is an n element vector. H is reperested in the form \begin{DoxyVerb}H = I - tau * [ 1 ] * [ 1 v**T ],
              [ v ]
\end{DoxyVerb}


where tau is a scalar and v is an (n-\/1) element vector. If x\mbox{[}1\+:\mbox{]} = 0 and x\mbox{[}0\mbox{]} is real, then tau = 0 and H = I. Otherwise, 1 $<$= real(tau) $<$= 2 and abs(tau-\/1) $<$= 1.

Here, x = A\mbox{[} ii$\ast$mb + i \+: m, jj$\ast$nb + j \mbox{]}. That is, x is j-\/th column of the jj-\/th block-\/column of A, starting in the i-\/th row of the ii-\/th block-\/row of A, and going to the last row. Note that x spans multiple tiles of A.

This D\+I\+F\+F\+E\+R\+S from L\+A\+P\+A\+C\+K in that the 1.\+0 is stored explicitly in the top element of x and beta is stored separately. (Whereas in L\+A\+P\+A\+C\+K, the 1.\+0 is implicit and beta is stored in the top element of x.)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em A} & Description of m by n matrix A. On entry, A\mbox{[} ii$\ast$mb + i \+: m, jj$\ast$nb + j \mbox{]} is the vector x. On exit, A\mbox{[} ii$\ast$mb + i \+: m, jj$\ast$nb + j \mbox{]} is overwritten with \mbox{[} 1, v \mbox{]}.\\
\hline
\mbox{\tt in}  & {\em ii} & Index of block row of A to start in.\\
\hline
\mbox{\tt in}  & {\em jj} & Index of block column of A.\\
\hline
\mbox{\tt in}  & {\em i} & Index of row within ii-\/th block row to start in.\\
\hline
\mbox{\tt in}  & {\em j} & Index of column within jj-\/th block column.\\
\hline
\mbox{\tt out}  & {\em tau} & The scalar tau.\\
\hline
\mbox{\tt out}  & {\em beta} & The scalar beta. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gae0c64547ad5f825af9af811b583ea231_gae0c64547ad5f825af9af811b583ea231}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgeqp3\+\_\+norms@{C\+O\+R\+E\+\_\+dgeqp3\+\_\+norms}}
\index{C\+O\+R\+E\+\_\+dgeqp3\+\_\+norms@{C\+O\+R\+E\+\_\+dgeqp3\+\_\+norms}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgeqp3\+\_\+norms}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dgeqp3\+\_\+norms (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{A, }
\item[{int}]{ioff, }
\item[{int}]{joff, }
\item[{double $\ast$}]{norms1, }
\item[{double $\ast$}]{norms2}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gae0c64547ad5f825af9af811b583ea231_gae0c64547ad5f825af9af811b583ea231}
C\+O\+R\+E\+\_\+dgeqp3\+\_\+norms computes the 2-\/norm of each column of A\mbox{[} ioff\+:m, joff\+:n \mbox{]} that is marked with norms2\mbox{[}j\mbox{]} == -\/1 on entry. Entries that are not marked are assumed to already contain the correct 2-\/norm, so that the same routine can be used for computing the initial norms and for updating bad norms. The result is stored duplicated in norms1 and norms2.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em A} & P\+L\+A\+S\+M\+A descriptor of the matrix A. On entry, the M-\/by-\/\+N matrix described by the descriptor.\\
\hline
\mbox{\tt in}  & {\em ioff} & Row offset.\\
\hline
\mbox{\tt in}  & {\em joff} & Column offset.\\
\hline
\mbox{\tt in,out}  & {\em norms1} & Vector of size A.\+n. On exit, norms1\mbox{[}j\mbox{]} is 2-\/norm of column j, for j $>$= joff.\\
\hline
\mbox{\tt in,out}  & {\em norms2} & Vector of size A.\+n. On entry, if norms2\mbox{[}j\mbox{]} == -\/1, re-\/compute norm of column j. On exit, norms2\mbox{[}j\mbox{]} is 2-\/norm of column j, for j $>$= joff. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gaf606d0b2de38604d78d13242d81b9824_gaf606d0b2de38604d78d13242d81b9824}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgeqp3\+\_\+pivot@{C\+O\+R\+E\+\_\+dgeqp3\+\_\+pivot}}
\index{C\+O\+R\+E\+\_\+dgeqp3\+\_\+pivot@{C\+O\+R\+E\+\_\+dgeqp3\+\_\+pivot}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgeqp3\+\_\+pivot}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dgeqp3\+\_\+pivot (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{A, }
\item[{double $\ast$}]{F, }
\item[{int}]{ldf, }
\item[{int}]{jj, }
\item[{int}]{k, }
\item[{int $\ast$}]{jpvt, }
\item[{double $\ast$}]{norms1, }
\item[{double $\ast$}]{norms2, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaf606d0b2de38604d78d13242d81b9824_gaf606d0b2de38604d78d13242d81b9824}
C\+O\+R\+E\+\_\+dgeqp3\+\_\+pivot finds next pivot, pvt, based on maximum column norm. It applies the swap to the matrices A, F, and vectors jpvt, norms1, norms2. If info != 0, it returns immediately, doing no work.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em A} & On entry, descriptor for m by n matrix A. On exit, column k of jj-\/th block column is swapped with column pvt.\\
\hline
\mbox{\tt in,out}  & {\em F} & On entry, n by nb matrix F. On exit, row k is swapped with row pvt -\/ jj$\ast$nb. Currently, F is stored column-\/wise, not tile-\/wise.\\
\hline
\mbox{\tt in}  & {\em ldf} & Leading dimension of F. ldf $>$= max(1,A.\+n).\\
\hline
\mbox{\tt in}  & {\em jj} & Index of current block column, 0 $<$= jj $<$ A.\+nt.\\
\hline
\mbox{\tt in}  & {\em k} & Index of current column within block column, 0 $<$= k $<$ A.\+nb.\\
\hline
\mbox{\tt in,out}  & {\em jpvt} & Permutation vector, dimension n. On exit, swaps entries jpvt\mbox{[}k+jj$\ast$nb\mbox{]} and jpvt\mbox{[}pvt\mbox{]}.\\
\hline
\mbox{\tt in,out}  & {\em norms1} & On entry, vector of partial column norms, dimension n. On exit, sets norms1\mbox{[}pvt\mbox{]} = norms1\mbox{[}k+jj$\ast$nb\mbox{]}.\\
\hline
\mbox{\tt in,out}  & {\em norms2} & On entry, vector of original column norms, dimension n. On exit, sets norms2\mbox{[}pvt\mbox{]} = norms2\mbox{[}k+jj$\ast$nb\mbox{]}.\\
\hline
\mbox{\tt in}  & {\em info} & Error code from dgeqp3\+\_\+update; zero if no error. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga15093a96afb5bad4404f6b1d112d53f5_ga15093a96afb5bad4404f6b1d112d53f5}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgeqp3\+\_\+update@{C\+O\+R\+E\+\_\+dgeqp3\+\_\+update}}
\index{C\+O\+R\+E\+\_\+dgeqp3\+\_\+update@{C\+O\+R\+E\+\_\+dgeqp3\+\_\+update}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgeqp3\+\_\+update}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dgeqp3\+\_\+update (
\begin{DoxyParamCaption}
\item[{const double $\ast$}]{Ajj, }
\item[{int}]{lda1, }
\item[{double $\ast$}]{Ajk, }
\item[{int}]{lda2, }
\item[{const double $\ast$}]{Fk, }
\item[{int}]{ldf, }
\item[{int}]{joff, }
\item[{int}]{k, }
\item[{int}]{koff, }
\item[{int}]{nb, }
\item[{double $\ast$}]{norms1, }
\item[{double $\ast$}]{norms2, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga15093a96afb5bad4404f6b1d112d53f5_ga15093a96afb5bad4404f6b1d112d53f5}
C\+O\+R\+E\+\_\+dgeqp3\+\_\+update updates row k of one tile of A and subtracts that row from the column norms.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em Ajj} & Diagonal tile (jj,jj) of A.\\
\hline
\mbox{\tt in}  & {\em lda1} & Leading dimension of Ajj.\\
\hline
\mbox{\tt in,out}  & {\em Ajk} & Tile (jj,kk) of A, kk $>$= jj. On exit, updates row joff+k (i.\+e., as if Q was applied to trailing matrix).\\
\hline
\mbox{\tt in}  & {\em lda2} & Leading dimension of Ajk.\\
\hline
\mbox{\tt in}  & {\em Fk} & Tile kk of F.\\
\hline
\mbox{\tt in}  & {\em ldf} & Leading dimension of Fk.\\
\hline
\mbox{\tt in}  & {\em joff} & Row offset.\\
\hline
\mbox{\tt in}  & {\em k} & Update row joff+k, based on having factored k columns. (That is, joff columns of this tile were factored in previous panels; k columns have been factored during this panel.)\\
\hline
\mbox{\tt in}  & {\em koff} & Column to start updating. For diagonal tile, koff=joff+k+1, else koff=0.\\
\hline
\mbox{\tt in}  & {\em nb} & Number of columns in kk-\/th block-\/column of A.\\
\hline
\mbox{\tt in,out}  & {\em norms1} & kk-\/th block of partial column norms vector, dimension nb. On exit, norms1\mbox{[}koff\+:nb\mbox{]} -\/= Ajk\mbox{[}k, koff\+:nb \mbox{]}.\\
\hline
\mbox{\tt in,out}  & {\em norms2} & kk-\/th block of original column norms vector, dimension nb. Unchanged on exit, except if cancellation is detected for some column j, sets norm2\mbox{[}j\mbox{]} = -\/1 and sets info = 1.\\
\hline
\mbox{\tt out}  & {\em info} & Set to true if numerical instability (cancellation) is detected in updating column norms. dgeqp3 handles this error. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gab8583bd4b0eb7a10fd9375f329a92b04_gab8583bd4b0eb7a10fd9375f329a92b04}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgeqrt@{C\+O\+R\+E\+\_\+dgeqrt}}
\index{C\+O\+R\+E\+\_\+dgeqrt@{C\+O\+R\+E\+\_\+dgeqrt}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgeqrt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgeqrt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gab8583bd4b0eb7a10fd9375f329a92b04_gab8583bd4b0eb7a10fd9375f329a92b04}
C\+O\+R\+E\+\_\+dgeqrt computes a Q\+R factorization of a complex M-\/by-\/\+N tile A\+: A = Q $\ast$ R.

The tile Q is represented as a product of elementary reflectors

Q = H(1) H(2) . . . H(k), where k = min(\+M,\+N).

Each H(i) has the form

H(i) = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a complex scalar, and v is a complex vector with v(1\+:i-\/1) = 0 and v(i) = 1; v(i+1\+:m) is stored on exit in A(i+1\+:m,i), and tau in T\+A\+U(i).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile A. On exit, the elements on and above the diagonal of the array contain the min(\+M,\+N)-\/by-\/\+N upper trapezoidal tile R (R is upper triangular if M $>$= N); the elements below the diagonal, with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gaa343ed98ffecdd2a665c496662f47dd2_gaa343ed98ffecdd2a665c496662f47dd2}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgessm@{C\+O\+R\+E\+\_\+dgessm}}
\index{C\+O\+R\+E\+\_\+dgessm@{C\+O\+R\+E\+\_\+dgessm}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgessm}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgessm (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{const int $\ast$}]{I\+P\+I\+V, }
\item[{const double $\ast$}]{L, }
\item[{int}]{L\+D\+L, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaa343ed98ffecdd2a665c496662f47dd2_gaa343ed98ffecdd2a665c496662f47dd2}
C\+O\+R\+E\+\_\+dgessm applies the factors L computed by C\+O\+R\+E\+\_\+dgetrf\+\_\+incpiv to a complex M-\/by-\/\+N tile A.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of columns of the tile L. K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+P\+I\+V} & The pivot indices array of size K as returned by C\+O\+R\+E\+\_\+dgetrf\+\_\+incpiv.\\
\hline
\mbox{\tt in}  & {\em L} & The M-\/by-\/\+K lower triangular tile.\\
\hline
\mbox{\tt in}  & {\em L\+D\+L} & The leading dimension of the array L. L\+D\+L $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile A. On exit, updated by the application of L.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga5150032fe134978e7ee6f8fc4a031a9d_ga5150032fe134978e7ee6f8fc4a031a9d}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgetf2\+\_\+nopiv@{C\+O\+R\+E\+\_\+dgetf2\+\_\+nopiv}}
\index{C\+O\+R\+E\+\_\+dgetf2\+\_\+nopiv@{C\+O\+R\+E\+\_\+dgetf2\+\_\+nopiv}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgetf2\+\_\+nopiv}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgetf2\+\_\+nopiv (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga5150032fe134978e7ee6f8fc4a031a9d_ga5150032fe134978e7ee6f8fc4a031a9d}
C\+O\+R\+E\+\_\+dgetf2\+\_\+nopiv computes an L\+U factorization of a general diagonal dominant M-\/by-\/\+N matrix A witout no pivoting and no blocking. It is the internal function called by \hyperlink{group__CORE__double_ga30400ad99aa04946859afdac1a716eff_ga30400ad99aa04946859afdac1a716eff}{C\+O\+R\+E\+\_\+dgetrf\+\_\+nopiv()}.

The factorization has the form A = L $\ast$ U where L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n).

This is the right-\/looking Level 3 B\+L\+A\+S version of the algorithm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N matrix to be factored. On exit, the factors L and U from the factorization A = P$\ast$\+L$\ast$\+U; the unit diagonal elements of L are not stored.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
{\em $>$0} & if I\+N\+F\+O = k, U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga9fc744fcea215ec1d5a92452b2490fc4_ga9fc744fcea215ec1d5a92452b2490fc4}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgetrf@{C\+O\+R\+E\+\_\+dgetrf}}
\index{C\+O\+R\+E\+\_\+dgetrf@{C\+O\+R\+E\+\_\+dgetrf}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgetrf}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgetrf (
\begin{DoxyParamCaption}
\item[{int}]{m, }
\item[{int}]{n, }
\item[{double $\ast$}]{A, }
\item[{int}]{lda, }
\item[{int $\ast$}]{I\+P\+I\+V, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga9fc744fcea215ec1d5a92452b2490fc4_ga9fc744fcea215ec1d5a92452b2490fc4}
C\+O\+R\+E\+\_\+dgetrf -\/ Computes an L\+U factorization of a general M-\/by-\/\+N matrix A using the tile L\+U algorithm with partial tile pivoting with row interchanges.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & The number of rows of the matrix A. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the matrix A. n $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N matrix to be factored. On exit, the tile factors L and U from the factorization.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em I\+P\+I\+V} & The pivot indices that define the permutations.\\
\hline
\mbox{\tt out}  & {\em info} & 
\begin{DoxyItemize}
\item 0 on successful exit
\item $<$0 if -\/i, the i-\/th argument had an illegal value
\item $>$0 if i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gab173cf6731777f03013286028c876ce7_gab173cf6731777f03013286028c876ce7}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgetrf\+\_\+incpiv@{C\+O\+R\+E\+\_\+dgetrf\+\_\+incpiv}}
\index{C\+O\+R\+E\+\_\+dgetrf\+\_\+incpiv@{C\+O\+R\+E\+\_\+dgetrf\+\_\+incpiv}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgetrf\+\_\+incpiv}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgetrf\+\_\+incpiv (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int $\ast$}]{I\+P\+I\+V, }
\item[{int $\ast$}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gab173cf6731777f03013286028c876ce7_gab173cf6731777f03013286028c876ce7}
C\+O\+R\+E\+\_\+dgetrf\+\_\+incpiv computes an L\+U factorization of a general M-\/by-\/\+N tile A using partial pivoting with row interchanges.

The factorization has the form

A = P $\ast$ L $\ast$ U

where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n).

This is the right-\/looking Level 2.\+5 B\+L\+A\+S version of the algorithm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be factored. On exit, the factors L and U from the factorization A = P$\ast$\+L$\ast$\+U; the unit diagonal elements of L are not stored.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em I\+P\+I\+V} & The pivot indices; for 1 $<$= i $<$= min(\+M,\+N), row i of the tile was interchanged with row I\+P\+I\+V(i).\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & See returned value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
{\em $>$0} & if I\+N\+F\+O = k, U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga30400ad99aa04946859afdac1a716eff_ga30400ad99aa04946859afdac1a716eff}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgetrf\+\_\+nopiv@{C\+O\+R\+E\+\_\+dgetrf\+\_\+nopiv}}
\index{C\+O\+R\+E\+\_\+dgetrf\+\_\+nopiv@{C\+O\+R\+E\+\_\+dgetrf\+\_\+nopiv}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgetrf\+\_\+nopiv}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgetrf\+\_\+nopiv (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga30400ad99aa04946859afdac1a716eff_ga30400ad99aa04946859afdac1a716eff}
C\+O\+R\+E\+\_\+dgetrf\+\_\+nopiv computes an L\+U factorization of a general diagonal dominant M-\/by-\/\+N matrix A witout pivoting.

The factorization has the form A = L $\ast$ U where L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n).

This is the right-\/looking Level 3 B\+L\+A\+S version of the algorithm. W\+A\+R\+N\+I\+N\+G\+: Your matrix need to be diagonal dominant if you want to call this routine safely.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The block size to switch between blocked and unblocked code.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N matrix to be factored. On exit, the factors L and U from the factorization A = P$\ast$\+L$\ast$\+U; the unit diagonal elements of L are not stored.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
{\em $>$0} & if I\+N\+F\+O = k, U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga14a9a22ac40973261b22d2d299664fbe_ga14a9a22ac40973261b22d2d299664fbe}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgetrf\+\_\+reclap@{C\+O\+R\+E\+\_\+dgetrf\+\_\+reclap}}
\index{C\+O\+R\+E\+\_\+dgetrf\+\_\+reclap@{C\+O\+R\+E\+\_\+dgetrf\+\_\+reclap}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgetrf\+\_\+reclap}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgetrf\+\_\+reclap (
\begin{DoxyParamCaption}
\item[{{\bf C\+O\+R\+E\+\_\+dgetrf\+\_\+data\+\_\+t} $\ast$}]{data, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int $\ast$}]{I\+P\+I\+V, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga14a9a22ac40973261b22d2d299664fbe_ga14a9a22ac40973261b22d2d299664fbe}
C\+O\+R\+E\+\_\+dgetrf\+\_\+reclap computes a L\+U factorization of a general M-\/by-\/\+N matrix A stored in C\+C\+R\+B layout using partial pivoting with row interchanges.

The factorization has the form

A = P $\ast$ L $\ast$ U

where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n).

This is the recursive version of the algorithm applied on column major layout.

W\+A\+R\+N\+I\+N\+G\+S\+:
\begin{DoxyItemize}
\item The function C\+O\+R\+E\+\_\+dgetrf\+\_\+reclap\+\_\+init has to be called prior to any call to this function.
\item You cannot call this kernel on different matrices at the same time.
\item The matrix A cannot be more than one tile wide.
\item The number of threads calling this function has to be excatly the number defined by info\mbox{[}2\mbox{]} with each one of them a different index between 0 included and info\mbox{[}2\mbox{]} excluded.
\end{DoxyItemize}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em data} & Common data structure to all threads initialized by C\+O\+R\+E\+\_\+dgetrf\+\_\+reclap\+\_\+init() that contains information for thread synchronization and maximum reductions. All threads working on a given matrix A must provide the same data structure.\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N matrix to be factorized. On exit, the factors L and U from the factorization A = P$\ast$\+L$\ast$\+U; the unit diagonal elements of L are not stored.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em I\+P\+I\+V} & The pivot indices; for 1 $<$= i $<$= min(\+M,\+N), row i of the matrix was interchanged with row I\+P\+I\+V(i). 1 $<$= I\+P\+I\+V\mbox{[}i\mbox{]} $<$= M.\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of 3 integers
\begin{DoxyItemize}
\item info\mbox{[}0\mbox{]}, see returned value
\item info\mbox{[}1\mbox{]}, is the thread index 0 $<$= info\mbox{[}0\mbox{]} $<$ info\mbox{[}2\mbox{]}
\item info\mbox{[}2\mbox{]}, on entry is the number of threads trying to participate to the factorization, on exit is the real number of threads used to perform the factorization. Info\mbox{[}2\mbox{]} threads, and exactly info\mbox{[}2\mbox{]}, have to call this function to avoid dead lock.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em -\/k,the} & k-\/th argument had an illegal value \\
\hline
{\em k} & if U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gab19afc12efaf81167776221dcc3e4095_gab19afc12efaf81167776221dcc3e4095}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgetrf\+\_\+rectil@{C\+O\+R\+E\+\_\+dgetrf\+\_\+rectil}}
\index{C\+O\+R\+E\+\_\+dgetrf\+\_\+rectil@{C\+O\+R\+E\+\_\+dgetrf\+\_\+rectil}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgetrf\+\_\+rectil}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dgetrf\+\_\+rectil (
\begin{DoxyParamCaption}
\item[{{\bf C\+O\+R\+E\+\_\+dgetrf\+\_\+data\+\_\+t} $\ast$}]{data, }
\item[{const {\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{A, }
\item[{int $\ast$}]{I\+P\+I\+V, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gab19afc12efaf81167776221dcc3e4095_gab19afc12efaf81167776221dcc3e4095}
C\+O\+R\+E\+\_\+dgetrf\+\_\+rectil computes a L\+U factorization of a general M-\/by-\/\+N matrix A stored in C\+C\+R\+B layout using partial pivoting with row interchanges.

The factorization has the form

A = P $\ast$ L $\ast$ U

where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n).

This is the recursive version of the algorithm applied on tile layout.

W\+A\+R\+N\+I\+N\+G\+S\+:
\begin{DoxyItemize}
\item The function C\+O\+R\+E\+\_\+dgetrf\+\_\+rectil\+\_\+init has to be called prior to any call to this function.
\item You cannot call this kernel on different matrices at the same time.
\item The matrix A cannot be more than one tile wide.
\item The number of threads calling this function has to be excatly the number defined by info\mbox{[}2\mbox{]} with each one of them a different index between 0 included and info\mbox{[}2\mbox{]} excluded.
\end{DoxyItemize}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em data} & Common data structure to all threads initialized by C\+O\+R\+E\+\_\+dgetrf\+\_\+rectil\+\_\+init() that contains information for thread synchronization and maximum reductions. All threads working on a given matrix A must provide the same data structure.\\
\hline
\mbox{\tt in,out}  & {\em A} & P\+L\+A\+S\+M\+A descriptor of the matrix A to be factorized. On entry, the M-\/by-\/\+N matrix to be factorized. On exit, the factors L and U from the factorization A = P$\ast$\+L$\ast$\+U; the unit diagonal elements of L are not stored.\\
\hline
\mbox{\tt out}  & {\em I\+P\+I\+V} & The pivot indices; for 0 $<$= i $<$ min(\+M,\+N) stored in Fortran mode (starting at 1), row i of the matrix was interchanged with row I\+P\+I\+V(i). On exit, each value I\+P\+I\+V\mbox{[}i\mbox{]} for 0 $<$= i $<$ min(\+M,\+N) is increased by A.\+i, which means A.\+i $<$ I\+P\+I\+V\mbox{[}i\mbox{]} $<$= A.\+i+\+M.\\
\hline
\mbox{\tt in,out}  & {\em info} & Array of 3 integers.
\begin{DoxyItemize}
\item info\mbox{[}0\mbox{]}, see returned value
\item info\mbox{[}1\mbox{]}, is the thread index 0 $<$= info\mbox{[}0\mbox{]} $<$ info\mbox{[}2\mbox{]}
\item info\mbox{[}2\mbox{]}, on entry is the number of threads trying to participate to the factorization, on exit is the real number of threads used to perform the factorization. Info\mbox{[}2\mbox{]} threads, and exactly info\mbox{[}2\mbox{]}, have to call this function to avoid dead lock.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em -\/k,the} & k-\/th argument had an illegal value \\
\hline
{\em k} & if U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gaef525bd155bb8cccbcb8055a8ac19170_gaef525bd155bb8cccbcb8055a8ac19170}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dgetrip@{C\+O\+R\+E\+\_\+dgetrip}}
\index{C\+O\+R\+E\+\_\+dgetrip@{C\+O\+R\+E\+\_\+dgetrip}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dgetrip}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dgetrip (
\begin{DoxyParamCaption}
\item[{int}]{m, }
\item[{int}]{n, }
\item[{double $\ast$}]{A, }
\item[{double $\ast$}]{W}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaef525bd155bb8cccbcb8055a8ac19170_gaef525bd155bb8cccbcb8055a8ac19170}




C\+O\+R\+E\+\_\+dgetrip transposes a m-\/by-\/n matrix in place using an extra workspace of size m-\/by-\/n. Note \+: For square tile, workspace is not used.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & Number of lines of tile A\\
\hline
\mbox{\tt in}  & {\em n} & Number of columns of tile A\\
\hline
\mbox{\tt in,out}  & {\em A} & Tile of size m-\/by-\/n On exit, A = trans(\+A)\\
\hline
\mbox{\tt out}  & {\em W} & Workspace of size n-\/by-\/m if n != m, N\+U\+L\+L otherwise. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gadb56425edd66af0d0baaafa4db730687_gadb56425edd66af0d0baaafa4db730687}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dhbelr@{C\+O\+R\+E\+\_\+dhbelr}}
\index{C\+O\+R\+E\+\_\+dhbelr@{C\+O\+R\+E\+\_\+dhbelr}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dhbelr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dhbelr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{double $\ast$}]{V, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gadb56425edd66af0d0baaafa4db730687_gadb56425edd66af0d0baaafa4db730687}
C\+O\+R\+E\+\_\+dhbelr is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel eliminate a column by an element-\/wise annihiliation, and for each annihiliation, it apply a left update, followed by an right update on the diagonal 2x2 element, then it continue until finishing the the whole column. When this is done, it take advantage that data are on cache and will apply the right on the remaining part of this region that has not been updated by the right yet. Note that the column to be eliminated is located at st-\/1.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & double array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & double array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga6b181b2a5e76222ea33f2bb6cf02419e_ga6b181b2a5e76222ea33f2bb6cf02419e}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dhblrx@{C\+O\+R\+E\+\_\+dhblrx}}
\index{C\+O\+R\+E\+\_\+dhblrx@{C\+O\+R\+E\+\_\+dhblrx}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dhblrx}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dhblrx (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{double $\ast$}]{V, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga6b181b2a5e76222ea33f2bb6cf02419e_ga6b181b2a5e76222ea33f2bb6cf02419e}
C\+O\+R\+E\+\_\+dhblrx is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a left update, followed by an right update on the diagonal 2x2 element, then it continue until finishing the the whole column. When this is done, it take advantage that data are on cache and will apply the right on the remaining part of this region that has not been updated by the right yet.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & double array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & double array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gaeac6ec5ddb7fb26216c32ffae11a9d20_gaeac6ec5ddb7fb26216c32ffae11a9d20}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dhbrce@{C\+O\+R\+E\+\_\+dhbrce}}
\index{C\+O\+R\+E\+\_\+dhbrce@{C\+O\+R\+E\+\_\+dhbrce}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dhbrce}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dhbrce (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc} $\ast$}]{A, }
\item[{double $\ast$}]{V, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{eltsize}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaeac6ec5ddb7fb26216c32ffae11a9d20_gaeac6ec5ddb7fb26216c32ffae11a9d20}
C\+O\+R\+E\+\_\+dhbrce is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a right update, create a new nnz, then it eliminate it, and move to the next right update, create a new nnz, eliminate it and so on until finishing. When this is done, it take advantage that data are on cache and will apply the left on the remaining part of this region that has not been updated by the left yet.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower\+: \item Plasma\+Upper\+:\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the descriptor of the matrix A.\\
\hline
\mbox{\tt out}  & {\em V} & double array, dimension (N). The scalar elementary reflectors are written in this array. So it is used as a workspace for V at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & double array, dimension (N). The scalar factors of the elementary reflectors are written in thisarray. So it is used as a workspace for T\+A\+U at each step of the bulge chasing algorithm.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em eltsize} & P\+L\+A\+S\+M\+A internal value which refer to the size of the precision.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 1-\/\+B\+D\+L Householder add -\/1 because of C \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gabe6acc0e0cb39b2a16cb484ce527e19e_gabe6acc0e0cb39b2a16cb484ce527e19e}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlacpy@{C\+O\+R\+E\+\_\+dlacpy}}
\index{C\+O\+R\+E\+\_\+dlacpy@{C\+O\+R\+E\+\_\+dlacpy}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlacpy}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlacpy (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gabe6acc0e0cb39b2a16cb484ce527e19e_gabe6acc0e0cb39b2a16cb484ce527e19e}
C\+O\+R\+E\+\_\+dlacpy copies all or part of a two-\/dimensional matrix A to another matrix B


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies the part of the matrix A to be copied to B. = Plasma\+Upper\+Lower\+: All the matrix A = Plasma\+Upper\+: Upper triangular part = Plasma\+Lower\+: Lower triangular part\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrices A and B. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrices A and B. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & The M-\/by-\/\+N matrix to copy.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em B} & The M-\/by-\/\+N copy of the matrix A. On exit, B = A O\+N\+L\+Y in the locations specified by uplo.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gaf9b1c36e5bd489b8e488243b076814f8_gaf9b1c36e5bd489b8e488243b076814f8}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlacpy\+\_\+pivot@{C\+O\+R\+E\+\_\+dlacpy\+\_\+pivot}}
\index{C\+O\+R\+E\+\_\+dlacpy\+\_\+pivot@{C\+O\+R\+E\+\_\+dlacpy\+\_\+pivot}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlacpy\+\_\+pivot}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dlacpy\+\_\+pivot (
\begin{DoxyParamCaption}
\item[{const {\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{desc\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{direct, }
\item[{int}]{k1, }
\item[{int}]{k2, }
\item[{const int $\ast$}]{ipiv, }
\item[{int $\ast$}]{rankin, }
\item[{int $\ast$}]{rankout, }
\item[{double $\ast$}]{A, }
\item[{int}]{lda, }
\item[{int}]{init}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaf9b1c36e5bd489b8e488243b076814f8_gaf9b1c36e5bd489b8e488243b076814f8}
C\+O\+R\+E\+\_\+dlacpy\+\_\+pivot extracts the original version of the rows selected by the ipiv array and copies them into a new buffer.

This kernel is used by tournament pivoting algorithms, to extract the selected rows from the original matrix that will make it to the next level of the tournament.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em desc\+A} & The descriptor of the matrix A in which the kernel will extract the original rows.\\
\hline
\mbox{\tt in}  & {\em direct} & \begin{DoxyItemize}
\item Plasma\+Rowwise\+: The extracted rows are stored in column major layout. \item Plasma\+Columnwise\+: The extracted rows are store in row major layout.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em k1} & The first element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em k2} & The last element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em ipiv} & The pivot indices; Only the element in position k1 to k2 are accessed. The pivots should be included in the interval 1 to A.\+m\\
\hline
\mbox{\tt in,out}  & {\em rankin} & On entry, the global indices relative to the full matrix A factorized, in the local sub-\/matrix. If init == 1, rankin is initialized to A.\+i, .. A.\+i+desc\+A.m On exit, rows are permutted according to ipiv.\\
\hline
\mbox{\tt out}  & {\em rankout} & On exit, contains the global indices of the first (k2-\/k1+1) rows.\\
\hline
\mbox{\tt out}  & {\em A} & An lda-\/by-\/desc\+A.\+n matrix. On exit, A contains the original version of the rows selected by the pivoting process.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. lda $>$= max(1,(k2-\/k1+1)).\\
\hline
\mbox{\tt in}  & {\em init} & True if rankin needs to be initialized. False, if rankin contains already initialized data.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga785e1bf88728ffb2b7339e9de433d0f2_ga785e1bf88728ffb2b7339e9de433d0f2}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaed0\+\_\+betaapprox@{C\+O\+R\+E\+\_\+dlaed0\+\_\+betaapprox}}
\index{C\+O\+R\+E\+\_\+dlaed0\+\_\+betaapprox@{C\+O\+R\+E\+\_\+dlaed0\+\_\+betaapprox}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaed0\+\_\+betaapprox}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaed0\+\_\+betaapprox (
\begin{DoxyParamCaption}
\item[{int}]{subpbs, }
\item[{const int $\ast$}]{subpbs\+\_\+info, }
\item[{double $\ast$}]{D, }
\item[{const double $\ast$}]{E}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga785e1bf88728ffb2b7339e9de433d0f2_ga785e1bf88728ffb2b7339e9de433d0f2}
C\+O\+R\+E\+\_\+dlaed0\+\_\+betaapprox -\/ compute the rank-\/1 approximation for each subproblem. When a larger problem is split into two subproblems, the last diagonal element of the first subproblem and the first diagonal element of the second subproblem are set to D\mbox{[}i\mbox{]}-\/\+E\mbox{[}i+1\mbox{]}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em subpbs} & specifies the number of merge to be done at the leaf of the tree\\
\hline
\mbox{\tt in}  & {\em subpbs\+\_\+info} & subpbs\+\_\+info\mbox{[}i\mbox{]} is the position of the first eigenvalue of the ith eigenproblem.\\
\hline
\mbox{\tt in,out}  & {\em D} & On entry, D contains the diagonal elements of the two submatrices to be merged. On exit, D contains the updated rank-\/1 approximated diagonal elements.\\
\hline
\mbox{\tt in}  & {\em E} & E contains the extra-\/diagonal elements of the two submatrices to be merged. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga2bdc9efff9f2cae6d89fd67a162c7f2a_ga2bdc9efff9f2cae6d89fd67a162c7f2a}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaed2\+\_\+compressq@{C\+O\+R\+E\+\_\+dlaed2\+\_\+compressq}}
\index{C\+O\+R\+E\+\_\+dlaed2\+\_\+compressq@{C\+O\+R\+E\+\_\+dlaed2\+\_\+compressq}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaed2\+\_\+compressq}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaed2\+\_\+compressq (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{int}]{n1, }
\item[{const int $\ast$}]{I\+N\+D\+X, }
\item[{const int $\ast$}]{ctot, }
\item[{const double $\ast$}]{Q, }
\item[{int}]{L\+D\+Q, }
\item[{double $\ast$}]{Q2, }
\item[{int}]{start, }
\item[{int}]{end}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga2bdc9efff9f2cae6d89fd67a162c7f2a_ga2bdc9efff9f2cae6d89fd67a162c7f2a}
C\+O\+R\+E\+\_\+dlaed2\+\_\+compressq -\/ Copy a set of vectors from the Q matrix into the compressed Q2 matrix. Q2 matrix is oragnized as follow\+:

Q2 = ( q1\+\_\+1 mix1 0 def1 ) ( 0 mix2 q2 def2 ) and stored in memory by columns in the order (q1\+\_\+1, mix1, mix2, q2, def), with q1 and q2 the non deflated values, of the two subproblems, (mix1, mix2) the mixed eigenvalues and def the deflated eiegnvalues.

Rk\+: Note that here we follow the same order that L\+A\+P\+A\+C\+K dlaed2 routine, so the copy from Q to Q2 is done such that Q2 is filled in a continuous manner.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & n specifies the dimension of the symmetric tridiagonal matrix\\
\hline
\mbox{\tt in}  & {\em n1} & n1 specifies the location of the last eigenvalue of the first subproblem min(1, n) $<$= n1 $<$= n/2\\
\hline
\mbox{\tt in}  & {\em start} & start specifies the first sorted column index to be considered by this kernel.\\
\hline
\mbox{\tt in}  & {\em end} & end specifies the last column index to be considered by this kernel. start $<$= end $<$= n.\\
\hline
\mbox{\tt in}  & {\em I\+N\+D\+X} & The permutation array used to sort Q into Q2. Array of dimension n, but only I\+N\+D\+X\mbox{[}i\mbox{]} for start $<$= i $<$ end are referenced.\\
\hline
\mbox{\tt in}  & {\em ctot} & ctot\mbox{[}i\mbox{]} is the number of columns of type i, as defined with I\+N\+D\+X. 0-\/ number of colums with non-\/zero in the upper half only 1-\/ number of dense colums 2-\/ number of colums with non-\/zero in the lower half only 3-\/ number of deflated columns\\
\hline
\mbox{\tt in}  & {\em Q} & On entry, Q contains the eigenvectors in the uncompressed form. W\+A\+R\+N\+I\+N\+G\+: Q is the pointer to the full matrix even if only a subset of vectors will be extract.\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & L\+D\+Q specifies the leading dimension of Q\\
\hline
\mbox{\tt out}  & {\em Q2} & On exit, columns start to end from Q2 stores the eigenvectors in the compressed form and sorted by type. W\+A\+R\+N\+I\+N\+G\+: Q2 is the pointer to the full matrix even if only columns start to end are touched. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga6a307ebecf8a76fa174e00a626ac5f2b_ga6a307ebecf8a76fa174e00a626ac5f2b}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaed2\+\_\+compute\+K@{C\+O\+R\+E\+\_\+dlaed2\+\_\+compute\+K}}
\index{C\+O\+R\+E\+\_\+dlaed2\+\_\+compute\+K@{C\+O\+R\+E\+\_\+dlaed2\+\_\+compute\+K}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaed2\+\_\+compute\+K}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaed2\+\_\+compute\+K (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{Kptr, }
\item[{int}]{n, }
\item[{int}]{n1, }
\item[{double $\ast$}]{betaptr, }
\item[{double $\ast$}]{D, }
\item[{double $\ast$}]{Q, }
\item[{int}]{L\+D\+Q, }
\item[{double $\ast$}]{Z, }
\item[{double $\ast$}]{D\+L\+A\+M\+B\+D\+A, }
\item[{double $\ast$}]{W, }
\item[{int $\ast$}]{I\+N\+D\+X, }
\item[{int $\ast$}]{I\+N\+D\+X\+C, }
\item[{int $\ast$}]{I\+N\+D\+X\+P, }
\item[{int $\ast$}]{I\+N\+D\+X\+Q, }
\item[{int $\ast$}]{C\+O\+L\+T\+Y\+P}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga6a307ebecf8a76fa174e00a626ac5f2b_ga6a307ebecf8a76fa174e00a626ac5f2b}
C\+O\+R\+E\+\_\+dlaed2\+\_\+compute\+K -\/ Computes the number of deflated eigenvalues of a symmetric tridiagonal matrix. A eigenvalue is deflated if it\textquotesingle{}s close enough to another eigenvalue or if the vector Z contains a tiny entry. This operation is useful when two subproblems, which were previously solved, are merge into a larger problem.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em Kptr} & On exit, Kptr stores the number of non-\/deflated eigenvalues\\
\hline
\mbox{\tt in}  & {\em n} & n specifies the dimension of the symmetric tridiagonal matrix\\
\hline
\mbox{\tt in}  & {\em n1} & n1 specifies the location of the last eigenvalue of the first subproblem min(1, n) $<$= n1 $<$= n/2\\
\hline
\mbox{\tt in,out}  & {\em betaptr} & betaptr\mbox{[}0\mbox{]} specifies the rank-\/1 approximation that was used for splitting the problem into two subproblems. On exit, it contains the updated beta for L\+A\+E\+D3.\\
\hline
\mbox{\tt in,out}  & {\em D} & On entry, D contains the eigenvalues of the two submatrices to be merged. On exit, D contains the updated eigenvalues sorted into increasing order.\\
\hline
\mbox{\tt in,out}  & {\em Q} & On entry, Q contains the eigenvectors of each subproblem. On exit, Q contains the updated eigenvectors, which can be modified through givens rotation (with close eigenvalues).\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & L\+D\+Q specifies the leading direction of Q\\
\hline
\mbox{\tt out}  & {\em Z} & Z will contain the updating vectors, composed of the last row of the first subproblem and the first row of the second subproblem.\\
\hline
\mbox{\tt out}  & {\em D\+L\+A\+M\+B\+D\+A} & D\+L\+A\+M\+B\+D\+A will contain a copy of the first K eigenvalues and then an update of those eigenvalues for usage in L\+A\+E\+D3. In L\+A\+P\+A\+C\+K, the call of dlamc3 is done at the beginning of L\+A\+E\+D3.\\
\hline
\mbox{\tt out}  & {\em W} & W will contain the fisrt K values of the final Z vector, for future use in L\+A\+E\+D3.\\
\hline
\mbox{\tt out}  & {\em I\+N\+D\+X} & The permutation used to sort the contents of D\+L\+A\+M\+B\+D\+A into ascending order\\
\hline
\mbox{\tt out}  & {\em I\+N\+D\+X\+C} & The permutation used to arrange the columns of the deflated Q matrix 1-\/ non-\/zero elements only at and above n1 2-\/ non-\/zero elements only below n1 3-\/ dense\\
\hline
\mbox{\tt out}  & {\em I\+N\+D\+X\+P} & I\+N\+D\+X\+P is the permutation used to place deflated eigenvalues at the end of the array I\+N\+D\+X\+P(0\+:K-\/1) points to the non-\/deflated D values I\+N\+D\+X\+P(K-\/1\+:N-\/1) points to the deflated D values\\
\hline
\mbox{\tt in,out}  & {\em I\+N\+D\+X\+Q} & The permutation which separetely sorts each subprobem in D into ascending order. In the second half of the permutation, elements will have n1 added to their value.\\
\hline
\mbox{\tt out}  & {\em C\+O\+L\+T\+Y\+P} & C\+O\+L\+T\+Y\+P indicate the type of the Q matrix columns during the process. 1-\/ non-\/zero in the upper half only 2-\/ dense 3-\/ non-\/zero in the lower half only 4-\/ deflated \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga0b7db3e9b6066968ce09af2cdbe15ed1_ga0b7db3e9b6066968ce09af2cdbe15ed1}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaed2\+\_\+copydef@{C\+O\+R\+E\+\_\+dlaed2\+\_\+copydef}}
\index{C\+O\+R\+E\+\_\+dlaed2\+\_\+copydef@{C\+O\+R\+E\+\_\+dlaed2\+\_\+copydef}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaed2\+\_\+copydef}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaed2\+\_\+copydef (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{int}]{n1, }
\item[{int}]{K, }
\item[{const int $\ast$}]{ctot, }
\item[{double $\ast$}]{Q, }
\item[{int}]{L\+D\+Q, }
\item[{const double $\ast$}]{Q2, }
\item[{int}]{start, }
\item[{int}]{end}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga0b7db3e9b6066968ce09af2cdbe15ed1_ga0b7db3e9b6066968ce09af2cdbe15ed1}
C\+O\+R\+E\+\_\+dlaed2\+\_\+copydef -\/ Copy back a portion of the deflated eigenvectors from Q2 to Q.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & n specifies the dimension of the symmetric tridiagonal matrix\\
\hline
\mbox{\tt in}  & {\em n1} & n1 specifies the location of the last eigenvalue of the first subproblem min(1, n) $<$= n1 $<$= n/2\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of non-\/deflated eigenvalues\\
\hline
\mbox{\tt in}  & {\em start} & start specifies the first column index to be considered by this kernel note that this index can be $<$ K, it is supported\\
\hline
\mbox{\tt in}  & {\em end} & end specifies the last column index to be considered by this kernel\\
\hline
\mbox{\tt in}  & {\em ctot} & ctot\mbox{[}i\mbox{]} is the number of columns of type i, as defined with I\+N\+D\+X. 0-\/ number of colums with non-\/zero in the upper half only 1-\/ number of dense colums 2-\/ number of colums with non-\/zero in the lower half only 3-\/ number of deflated columns\\
\hline
\mbox{\tt out}  & {\em Q} & On exit, Q(start\+:end-\/1) contains the updated eigenvectors\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & L\+D\+Q specifies the leading direction of Q\\
\hline
\mbox{\tt in}  & {\em Q2} & On entry, Q2 contains the saved eigenvectors in the compressed form. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga3be1c5d54e7c9c950f2b93cc1ffe1ef8_ga3be1c5d54e7c9c950f2b93cc1ffe1ef8}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaed3\+\_\+computevectors@{C\+O\+R\+E\+\_\+dlaed3\+\_\+computevectors}}
\index{C\+O\+R\+E\+\_\+dlaed3\+\_\+computevectors@{C\+O\+R\+E\+\_\+dlaed3\+\_\+computevectors}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaed3\+\_\+computevectors}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaed3\+\_\+computevectors (
\begin{DoxyParamCaption}
\item[{int}]{K, }
\item[{int}]{il\+\_\+nondef, }
\item[{int}]{iu\+\_\+nondef, }
\item[{double $\ast$}]{Q, }
\item[{int}]{L\+D\+Q, }
\item[{double $\ast$}]{W, }
\item[{double $\ast$}]{S, }
\item[{const int $\ast$}]{I\+N\+D\+X\+C, }
\item[{int}]{start, }
\item[{int}]{end}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga3be1c5d54e7c9c950f2b93cc1ffe1ef8_ga3be1c5d54e7c9c950f2b93cc1ffe1ef8}
C\+O\+R\+E\+\_\+dlaed3\+\_\+computevectors -\/ Compute the subset(start\+:end) of eigenvectors of the modified rank-\/1 system.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em K} & K specifies the number of non-\/deflated eigenvalues\\
\hline
\mbox{\tt in}  & {\em il\+\_\+nondef} & The first eigenvector index when computing only a subset of all eigenpairs\\
\hline
\mbox{\tt in}  & {\em iu\+\_\+nondef} & The last eigenvector index when computing only a subset of all eigenpairs\\
\hline
\mbox{\tt in,out}  & {\em Q} & Q is an array of dimension (L\+D\+Q, end) Initially the first K columns of the full Q matrix are used as workspace. On output the Q(start\+:end) contain the updated eigenvectors.\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & L\+D\+Q specifies the leading dimension of Q\\
\hline
\mbox{\tt in}  & {\em W} & W is the result of the previous computation after reduction. See core\+\_\+dlaed3\+\_\+compute\+W() and core\+\_\+dlaed3\+\_\+reduce\+W(). The first K elements of this array contain the components of the deflation-\/adjusted updating vector. Destroyed on output.\\
\hline
\mbox{\tt in}  & {\em S} & S is local workspace of size K.\\
\hline
\mbox{\tt in}  & {\em I\+N\+D\+X\+C} & I\+N\+D\+X\+C is the permutation used to arrange the columns of the deflated Q matrix into three groups (see core\+\_\+dlaed2\+\_\+compute\+K()). The rows of the eigenvectors found by core\+\_\+dlaed4() must be likewise permuted before the matrix multiply of core\+\_\+dlaed3\+\_\+updatevectors() can take place.\\
\hline
\mbox{\tt in}  & {\em start} & start specifies the first column index to be considered by this kernel\\
\hline
\mbox{\tt in}  & {\em end} & end specifies the last column index to be considered by this kernel \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gaa85a007085ddd54918d2097cb65df311_gaa85a007085ddd54918d2097cb65df311}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaed3\+\_\+compute\+W@{C\+O\+R\+E\+\_\+dlaed3\+\_\+compute\+W}}
\index{C\+O\+R\+E\+\_\+dlaed3\+\_\+compute\+W@{C\+O\+R\+E\+\_\+dlaed3\+\_\+compute\+W}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaed3\+\_\+compute\+W}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaed3\+\_\+compute\+W (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{int}]{K, }
\item[{const double $\ast$}]{Q, }
\item[{int}]{L\+D\+Q, }
\item[{const double $\ast$}]{D\+L\+A\+M\+B\+D\+A, }
\item[{double $\ast$}]{W, }
\item[{const int $\ast$}]{I\+N\+D\+X, }
\item[{int}]{start, }
\item[{int}]{end}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaa85a007085ddd54918d2097cb65df311_gaa85a007085ddd54918d2097cb65df311}
C\+O\+R\+E\+\_\+dlaed2\+\_\+compute\+K -\/ Computes the number of deflated eigenvalues of a symmetric tridiagonal matrix. A eigenvalue is deflated if it\textquotesingle{}s close enough to another eigenvalue or if the vector Z contains a tiny entry. This operation is useful when two subproblems, which were previously solved, are merge into a larger problem.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & n specifies the dimension of the symmetric tridiagonal matrix\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of non-\/deflated eigenvalues\\
\hline
\mbox{\tt in}  & {\em Q} & On entry, Q contains the eigenvectors after dlaed4\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & L\+D\+Q specifies the leading direction of Q\\
\hline
\mbox{\tt in}  & {\em D\+L\+A\+M\+B\+D\+A} & D\+L\+A\+M\+B\+D\+A contains a copy of the first K eigenvalues\\
\hline
\mbox{\tt out}  & {\em W} & W\\
\hline
\mbox{\tt out}  & {\em I\+N\+D\+X} & The permutation used to sort the contents of D\+L\+A\+M\+B\+D\+A into ascending order\\
\hline
\mbox{\tt in}  & {\em start} & start specifies the first column index to be considered by this kernel\\
\hline
\mbox{\tt in}  & {\em end} & end specifies the last column index to be considered by this kernel note that this index can be $>$ n, it is supported \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga8d57d669e0bcef9e6fd1fd3a8592f697_ga8d57d669e0bcef9e6fd1fd3a8592f697}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaed3\+\_\+merge@{C\+O\+R\+E\+\_\+dlaed3\+\_\+merge}}
\index{C\+O\+R\+E\+\_\+dlaed3\+\_\+merge@{C\+O\+R\+E\+\_\+dlaed3\+\_\+merge}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaed3\+\_\+merge}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaed3\+\_\+merge (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{int}]{K, }
\item[{double $\ast$}]{D, }
\item[{int $\ast$}]{I\+N\+D\+X\+Q}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga8d57d669e0bcef9e6fd1fd3a8592f697_ga8d57d669e0bcef9e6fd1fd3a8592f697}
C\+O\+R\+E\+\_\+dlaed3\+\_\+merge -\/ Merge the eigenvalues of two subproblems and generates the index arrays to sort the associated eigenvectors.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & n specifies the dimension of the symmetric tridiagonal matrix\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of non-\/deflated eigenvalues\\
\hline
\mbox{\tt out}  & {\em D} & Array of double of size n. On exit, stores the sorted eigenvalues.\\
\hline
\mbox{\tt out}  & {\em I\+N\+D\+X\+Q} & Array of integers of size n. On exit, I\+N\+D\+X\+Q stores the permutation array to sort the eigenvectors. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga160f1c4633dd0ace97ce8ec2b89dd242_ga160f1c4633dd0ace97ce8ec2b89dd242}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaed3\+\_\+reduce\+W@{C\+O\+R\+E\+\_\+dlaed3\+\_\+reduce\+W}}
\index{C\+O\+R\+E\+\_\+dlaed3\+\_\+reduce\+W@{C\+O\+R\+E\+\_\+dlaed3\+\_\+reduce\+W}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaed3\+\_\+reduce\+W}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaed3\+\_\+reduce\+W (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{int}]{n1, }
\item[{int}]{K, }
\item[{int}]{l, }
\item[{const double $\ast$}]{Q, }
\item[{int}]{L\+D\+Q, }
\item[{const double $\ast$}]{Wred, }
\item[{double $\ast$}]{W}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga160f1c4633dd0ace97ce8ec2b89dd242_ga160f1c4633dd0ace97ce8ec2b89dd242}
C\+O\+R\+E\+\_\+dlaed3\+\_\+reduce\+W -\/ Computes the reduction of multiple W l threads were computing Wred(\+:,j) and this kernel will compute the Pi( Wred(i,j), j=1..l )


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & n specifies the dimension of the symmetric tridiagonal matrix\\
\hline
\mbox{\tt in}  & {\em n1} & n1 specifies the location of the last eigenvalue of the first subproblem min(1, n) $<$= n1 $<$= n/2\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of non-\/deflated eigenvalues\\
\hline
\mbox{\tt in}  & {\em l} & l specifies the number of columns of Wred\\
\hline
\mbox{\tt out}  & {\em Q} & \\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & L\+D\+Q specifies the leading direction of Q\\
\hline
\mbox{\tt in}  & {\em Wred} & Wred\mbox{[}\+:,j\mbox{]} corresponds to the local W for a previous task\\
\hline
\mbox{\tt out}  & {\em W} & On exit, W(i) = sqrt( Pi( Wred(i,j), j=1..l ) $\ast$ Q(i,i) ) \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga3af898271ac8252073cd06625efc4df9_ga3af898271ac8252073cd06625efc4df9}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaed3\+\_\+updatevectors@{C\+O\+R\+E\+\_\+dlaed3\+\_\+updatevectors}}
\index{C\+O\+R\+E\+\_\+dlaed3\+\_\+updatevectors@{C\+O\+R\+E\+\_\+dlaed3\+\_\+updatevectors}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaed3\+\_\+updatevectors}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaed3\+\_\+updatevectors (
\begin{DoxyParamCaption}
\item[{int}]{op, }
\item[{int}]{wsmode, }
\item[{int}]{n, }
\item[{int}]{n1, }
\item[{int}]{K, }
\item[{int}]{il\+\_\+nondef, }
\item[{int}]{iu\+\_\+nondef, }
\item[{double $\ast$}]{Q, }
\item[{int}]{ldq, }
\item[{double $\ast$}]{Q2, }
\item[{const int $\ast$}]{ctot, }
\item[{double $\ast$}]{W, }
\item[{int}]{start, }
\item[{int}]{end}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga3af898271ac8252073cd06625efc4df9_ga3af898271ac8252073cd06625efc4df9}
C\+O\+R\+E\+\_\+dlaed3\+\_\+updatevectors -\/


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em op} & Type of operation to apply = Plasma\+Laed3\+Update1\+: Apply the G\+E\+M\+M on the first subproblem = Plasma\+Laed3\+Update2\+: Apply the G\+E\+M\+M on the second subproblem and merge the eigenvalues. = Plasma\+Laed3\+Update\+All\+: Apply all operations in one call.\\
\hline
\mbox{\tt in}  & {\em wsmode} & Specifies the amount of extra workspace used for the computations. = 0 \+: means that no extra workspace is available (W\+O\+R\+K = N\+U\+L\+L). S = Q2 + n12 $\ast$ n1 + n23 $\ast$ (n-\/n1) is used as the workspace to sequentially apply the updates = 1 \+: means that extra workspace has been allocated in \hyperlink{group__CORE__double_ga3be1c5d54e7c9c950f2b93cc1ffe1ef8_ga3be1c5d54e7c9c950f2b93cc1ffe1ef8}{C\+O\+R\+E\+\_\+dlaed3\+\_\+computevectors()} to apply the updates in parallel. If op = Plasma\+Laed3\+Update1, the first subproblem is updated. If op = Plasma\+Laed3\+Update2, the second subproblem is updated. = 3 \+: means that extra workspace has been allocated in after K has been computed in \hyperlink{group__CORE__double_ga6a307ebecf8a76fa174e00a626ac5f2b_ga6a307ebecf8a76fa174e00a626ac5f2b}{C\+O\+R\+E\+\_\+dlaed2\+\_\+compute\+K()}. Allows to apply both updates in parallel as previously.\\
\hline
\mbox{\tt in}  & {\em n} & n specifies the dimension of the symmetric tridiagonal matrix\\
\hline
\mbox{\tt in}  & {\em n1} & n1 specifies the location of the last eigenvalue of the first subproblem min(1, n) $<$= n1 $<$= n/2\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of non-\/deflated eigenvalues\\
\hline
\mbox{\tt in}  & {\em il\+\_\+nondef} & The first eigenvector index when computing only a subset of all eigenpairs\\
\hline
\mbox{\tt in}  & {\em iu\+\_\+nondef} & The last eigenvector index when computing only a subset of all eigenpairs\\
\hline
\mbox{\tt out}  & {\em Q} & The current eigenvectors\\
\hline
\mbox{\tt in}  & {\em ldq} & L\+D\+Q specifies the leading direction of Q\\
\hline
\mbox{\tt in,out}  & {\em Q2} & The updated eigenvectors\\
\hline
\mbox{\tt in}  & {\em ctot} & ctot indicates the number of vectors of each type in the Q matrix. 0-\/ non-\/zero in the upper half only 1-\/ dense 2-\/ non-\/zero in the lower half only 3-\/ deflated\\
\hline
\mbox{\tt in}  & {\em W} & W is the place were will be stored the updated eigenvectors\\
\hline
\mbox{\tt in}  & {\em start} & start specifies the first column index to be considered by this kernel\\
\hline
\mbox{\tt in}  & {\em end} & end specifies the last column index to be considered by this kernel \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gab7b88d94f96333ae870c7fdafe41c194_gab7b88d94f96333ae870c7fdafe41c194}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaed4@{C\+O\+R\+E\+\_\+dlaed4}}
\index{C\+O\+R\+E\+\_\+dlaed4@{C\+O\+R\+E\+\_\+dlaed4}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaed4}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dlaed4 (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{int}]{K, }
\item[{double $\ast$}]{D, }
\item[{double}]{beta, }
\item[{double $\ast$}]{Q, }
\item[{int}]{L\+D\+Q, }
\item[{const double $\ast$}]{D0, }
\item[{const double $\ast$}]{Z, }
\item[{const int $\ast$}]{I\+N\+D\+X, }
\item[{int}]{start, }
\item[{int}]{end}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gab7b88d94f96333ae870c7fdafe41c194_gab7b88d94f96333ae870c7fdafe41c194}
C\+O\+R\+E\+\_\+dlaed4 -\/ solve the secular equation for indexes between start and end


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & n specifies the dimension of the symmetric tridiagonal matrix\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of non-\/deflated eigenvalues\\
\hline
\mbox{\tt in,out}  & {\em D} & On entry, D contains the eigenvalues of the two submatrices to be merged. On exit, D contains the updated eigenvalues sorted into increasing order.\\
\hline
\mbox{\tt in}  & {\em beta} & beta\+\_\+bis\mbox{[}0\mbox{]} specifies the rank-\/1 approximation that was used for splitting the problem into two subproblems.\\
\hline
\mbox{\tt in,out}  & {\em Q} & On exit, Q contains the updated eigenvectors\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & L\+D\+Q specifies the leading direction of Q\\
\hline
\mbox{\tt in}  & {\em D0} & On entry, D0 conatins the original sorted eigenvalues.\\
\hline
\mbox{\tt in}  & {\em Z} & Z contains the components of the updating vectors.\\
\hline
\mbox{\tt out}  & {\em I\+N\+D\+X} & The permutation used to sort the contents of D\+L\+A\+M\+B\+D\+A into ascending order\\
\hline
\mbox{\tt in}  & {\em start} & start specifies the first column index to be considered by this kernel 0 $<$= start $<$= end\\
\hline
\mbox{\tt in}  & {\em end} & end specifies the last column index to be considered by this kernel start $<$= end $<$= n\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gad314c3ce1d85697c2edccd6763300e93_gad314c3ce1d85697c2edccd6763300e93}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlag2s@{C\+O\+R\+E\+\_\+dlag2s}}
\index{C\+O\+R\+E\+\_\+dlag2s@{C\+O\+R\+E\+\_\+dlag2s}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlag2s}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlag2s (
\begin{DoxyParamCaption}
\item[{int}]{m, }
\item[{int}]{n, }
\item[{const double $\ast$}]{A, }
\item[{int}]{lda, }
\item[{float $\ast$}]{B, }
\item[{int}]{ldb, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gad314c3ce1d85697c2edccd6763300e93_gad314c3ce1d85697c2edccd6763300e93}
C\+O\+R\+E\+\_\+dlag2s converts a double matrix, A, to a float matrix, B.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & The number of rows of the matrices A and B. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the matrices A and B. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & The double m-\/by-\/n matrix to convert.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. lda $>$= max(1,m).\\
\hline
\mbox{\tt out}  & {\em B} & The float m-\/by-\/n matrix to convert.\\
\hline
\mbox{\tt in}  & {\em ldb} & The leading dimension of the array B. ldb $>$= max(1,m).\\
\hline
\mbox{\tt out}  & {\em info} & 
\begin{DoxyItemize}
\item 0 on successful exit.
\item 1 if an entry of the matrix A is greater than the S\+I\+N\+G\+L\+E P\+R\+E\+C\+I\+S\+I\+O\+N overflow threshold, in this case, the content of B in exit is unspecified. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga1ecb4af5d609ccaca3c438134f1e6452_ga1ecb4af5d609ccaca3c438134f1e6452}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlange@{C\+O\+R\+E\+\_\+dlange}}
\index{C\+O\+R\+E\+\_\+dlange@{C\+O\+R\+E\+\_\+dlange}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlange}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlange (
\begin{DoxyParamCaption}
\item[{int}]{norm, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{work, }
\item[{double $\ast$}]{norm\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga1ecb4af5d609ccaca3c438134f1e6452_ga1ecb4af5d609ccaca3c438134f1e6452}
C\+O\+R\+E\+\_\+dlange returns the value

dlange = ( max(abs(\+A(i,j))), N\+O\+R\+M = Plasma\+Max\+Norm ( ( norm1(\+A), N\+O\+R\+M = Plasma\+One\+Norm ( ( norm\+I(\+A), N\+O\+R\+M = Plasma\+Inf\+Norm ( ( norm\+F(\+A), N\+O\+R\+M = Plasma\+Frobenius\+Norm

where norm1 denotes the one norm of a matrix (maximum column sum), norm\+I denotes the infinity norm of a matrix (maximum row sum) and norm\+F denotes the Frobenius norm of a matrix (square root of sum of squares). Note that max(abs(\+A(i,j))) is not a consistent matrix norm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em norm} & = Plasma\+Max\+Norm\+: Max norm = Plasma\+One\+Norm\+: One norm = Plasma\+Inf\+Norm\+: Infinity norm = Plasma\+Frobenius\+Norm\+: Frobenius norm\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & The M-\/by-\/\+N matrix A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em work} & Array of dimension (M\+A\+X(1,\+L\+W\+O\+R\+K)), where L\+W\+O\+R\+K $>$= M when N\+O\+R\+M = Plasma\+Inf\+Norm; otherwise, W\+O\+R\+K is not referenced.\\
\hline
\mbox{\tt out}  & {\em norm\+A} & On exit, norm\+A is the norm of matrix A. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga8b19aabbaa27e74346193ce1cda858b9_ga8b19aabbaa27e74346193ce1cda858b9}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlansy@{C\+O\+R\+E\+\_\+dlansy}}
\index{C\+O\+R\+E\+\_\+dlansy@{C\+O\+R\+E\+\_\+dlansy}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlansy}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlansy (
\begin{DoxyParamCaption}
\item[{int}]{norm, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{work, }
\item[{double $\ast$}]{norm\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga8b19aabbaa27e74346193ce1cda858b9_ga8b19aabbaa27e74346193ce1cda858b9}
C\+O\+R\+E\+\_\+dlansy returns the value

dlansy = ( max(abs(\+A(i,j))), N\+O\+R\+M = Plasma\+Max\+Norm ( ( norm1(\+A), N\+O\+R\+M = Plasma\+One\+Norm ( ( norm\+I(\+A), N\+O\+R\+M = Plasma\+Inf\+Norm ( ( norm\+F(\+A), N\+O\+R\+M = Plasma\+Frobenius\+Norm

where norm1 denotes the one norm of a matrix (maximum column sum), norm\+I denotes the infinity norm of a matrix (maximum row sum) and norm\+F denotes the Frobenius norm of a matrix (square root of sum of squares). Note that max(abs(\+A(i,j))) is not a consistent matrix norm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em norm} & = Plasma\+Max\+Norm\+: Max norm = Plasma\+One\+Norm\+: One norm = Plasma\+Inf\+Norm\+: Infinity norm = Plasma\+Frobenius\+Norm\+: Frobenius norm\\
\hline
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns/rows of the matrix A. N $>$= 0. When N = 0, the returned value is set to zero.\\
\hline
\mbox{\tt in}  & {\em A} & The N-\/by-\/\+N matrix A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt in,out}  & {\em work} & Array of dimension (M\+A\+X(1,\+L\+W\+O\+R\+K)), where L\+W\+O\+R\+K $>$= N when norm = Plasma\+Inf\+Norm or Plasma\+One\+Norm; otherwise, work is not referenced.\\
\hline
\mbox{\tt out}  & {\em norm\+A} & On exit, norm\+A is the norm of matrix A. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gad604d5c2ee20d5e2c9f4e669e540bab2_gad604d5c2ee20d5e2c9f4e669e540bab2}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlantr@{C\+O\+R\+E\+\_\+dlantr}}
\index{C\+O\+R\+E\+\_\+dlantr@{C\+O\+R\+E\+\_\+dlantr}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlantr}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlantr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{norm, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{diag, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{work, }
\item[{double $\ast$}]{norm\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gad604d5c2ee20d5e2c9f4e669e540bab2_gad604d5c2ee20d5e2c9f4e669e540bab2}
C\+O\+R\+E\+\_\+dlantr returns the value

dlantr = ( max(abs(\+A(i,j))), N\+O\+R\+M = Plasma\+Max\+Norm ( ( norm1(\+A), N\+O\+R\+M = Plasma\+One\+Norm ( ( norm\+I(\+A), N\+O\+R\+M = Plasma\+Inf\+Norm ( ( norm\+F(\+A), N\+O\+R\+M = Plasma\+Frobenius\+Norm

where norm1 denotes the one norm of a matrix (maximum column sum), norm\+I denotes the infinity norm of a matrix (maximum row sum) and norm\+F denotes the Frobenius norm of a matrix (square root of sum of squares). Note that max(abs(\+A(i,j))) is not a consistent matrix norm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em norm} & = Plasma\+Max\+Norm\+: Max norm = Plasma\+One\+Norm\+: One norm = Plasma\+Inf\+Norm\+: Infinity norm = Plasma\+Frobenius\+Norm\+: Frobenius norm\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular\+: = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em diag} & Specifies whether or not A is unit triangular\+: = Plasma\+Non\+Unit\+: A is non unit; = Plasma\+Unit\+: A us unit.\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0. If uplo == Plasma\+Upper, M $<$= N. When M = 0, C\+O\+R\+E\+\_\+dlantr returns 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0. If uplo == Plasma\+Lower, N $<$= M. When N = 0, C\+O\+R\+E\+\_\+dlantr returns 0.\\
\hline
\mbox{\tt in}  & {\em A} & The L\+D\+A-\/by-\/\+N matrix A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em work} & Array of dimension (M\+A\+X(1,\+L\+W\+O\+R\+K)), where L\+W\+O\+R\+K $>$= M when norm = Plasma\+Inf\+Norm, or L\+W\+O\+R\+K $>$= N when norm = Plasma\+One\+Norm; otherwise, work is not referenced.\\
\hline
\mbox{\tt out}  & {\em norm\+A} & On exit, norm\+A is the norm of matrix A. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gabd19ac0084a19fd2763defa6d3e94e94_gabd19ac0084a19fd2763defa6d3e94e94}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlarfb\+\_\+gemm@{C\+O\+R\+E\+\_\+dlarfb\+\_\+gemm}}
\index{C\+O\+R\+E\+\_\+dlarfb\+\_\+gemm@{C\+O\+R\+E\+\_\+dlarfb\+\_\+gemm}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlarfb\+\_\+gemm}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dlarfb\+\_\+gemm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{direct, }
\item[{int}]{storev, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{const double $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{C, }
\item[{int}]{L\+D\+C, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gabd19ac0084a19fd2763defa6d3e94e94_gabd19ac0084a19fd2763defa6d3e94e94}
C\+O\+R\+E\+\_\+dlarfb\+\_\+gemm applies a complex block reflector H or its transpose H\textquotesingle{} to a complex M-\/by-\/\+N matrix C, from either the left or the right. this kernel is similar to the lapack dlarfb but it do a full gemm on the triangular Vs assuming that the upper part of Vs is zero and ones are on the diagonal. It is also based on the fact that a gemm on a small block of k reflectors is faster than a trmm on the triangular (k,k) + gemm below.

N\+O\+T\+E T\+H\+A\+T\+: Only Columnwise/\+Forward cases are treated here.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+T from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+T from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+T.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em direct} & Indicates how H is formed from a product of elementary reflectors \begin{DoxyItemize}
\item Plasma\+Forward \+: H = H(1) H(2) . . . H(k) (Forward) \item Plasma\+Backward \+: H = H(k) . . . H(2) H(1) (Backward)\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em storev} & Indicates how the vectors which define the elementary reflectors are stored\+: \begin{DoxyItemize}
\item Plasma\+Columnwise \item Plasma\+Rowwise\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix C.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix C.\\
\hline
\mbox{\tt in}  & {\em K} & The order of the matrix T (= the number of elementary reflectors whose product defines the block reflector).\\
\hline
\mbox{\tt in}  & {\em V} & D\+O\+U\+B\+L\+E P\+R\+E\+C\+I\+S\+I\+O\+N array, dimension (L\+D\+V,K) if storev = \textquotesingle{}C\textquotesingle{} (L\+D\+V,M) if storev = \textquotesingle{}R\textquotesingle{} and side = \textquotesingle{}L\textquotesingle{} (L\+D\+V,N) if storev = \textquotesingle{}R\textquotesingle{} and side = \textquotesingle{}R\textquotesingle{} The matrix V. See further details.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. If storev = \textquotesingle{}C\textquotesingle{} and side = \textquotesingle{}L\textquotesingle{}, L\+D\+V $>$= max(1,\+M); if storev = \textquotesingle{}C\textquotesingle{} and side = \textquotesingle{}R\textquotesingle{}, L\+D\+V $>$= max(1,\+N); if storev = \textquotesingle{}R\textquotesingle{}, L\+D\+V $>$= K.\\
\hline
\mbox{\tt in}  & {\em T} & The triangular K-\/by-\/\+K matrix T in the representation of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= K.\\
\hline
\mbox{\tt in,out}  & {\em C} & D\+O\+U\+B\+L\+E P\+R\+E\+C\+I\+S\+I\+O\+N array, dimension (L\+D\+C,N) On entry, the M-\/by-\/\+N matrix C. On exit, C is overwritten by H$\ast$\+C or H\textquotesingle{}$\ast$\+C or C$\ast$\+H or C$\ast$\+H\textquotesingle{}.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & (workspace) D\+O\+U\+B\+L\+E P\+R\+E\+C\+I\+S\+I\+O\+N array, dimension (L\+D\+W\+O\+R\+K,K).\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K. If side = Plasma\+Left, L\+D\+W\+O\+R\+K $>$= max(1,\+N); if side = Plasma\+Right, L\+D\+W\+O\+R\+K $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga80d7223148dcbf874885d5bb0707f231_ga80d7223148dcbf874885d5bb0707f231}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlarfx2@{C\+O\+R\+E\+\_\+dlarfx2}}
\index{C\+O\+R\+E\+\_\+dlarfx2@{C\+O\+R\+E\+\_\+dlarfx2}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlarfx2}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dlarfx2 (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{int}]{N, }
\item[{double}]{V, }
\item[{double}]{T\+A\+U, }
\item[{double $\ast$}]{C1, }
\item[{int}]{L\+D\+C1, }
\item[{double $\ast$}]{C2, }
\item[{int}]{L\+D\+C2}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga80d7223148dcbf874885d5bb0707f231_ga80d7223148dcbf874885d5bb0707f231}
C\+O\+R\+E\+\_\+dlarfx2 applies a complex elementary reflector H to a complex m by n matrix C, from either the left or the right. H is represented in the form \begin{DoxyVerb}  H = I - tau * v * v'
\end{DoxyVerb}


where tau is a complex scalar and v is a complex vector.

If tau = 0, then H is taken to be the unit matrix

This version uses inline code if H has order $<$ 11.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: form H $\ast$ C \item Plasma\+Right\+: form C $\ast$ H\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of C1 and C2 if side = Plasma\+Left. The number of rows of C1 and C2 if side = Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em V} & The double complex V in the representation of H.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & The value tau in the representation of H.\\
\hline
\mbox{\tt in,out}  & {\em C1} & dimension (L\+D\+C1,N), if side = Plasma\+Left dimension (L\+D\+C1,1), if side = Plasma\+Right On entry, the m by n matrix C1. On exit, C1 is overwritten by the matrix H $\ast$ C1 if S\+I\+D\+E = Plasma\+Left, or C1 $\ast$ H if S\+I\+D\+E = Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C1} & The leading dimension of the array C1. L\+D\+C1 $>$= max(1,\+N), if side == Plasma\+Right. L\+D\+C1 $>$= 1, otherwise.\\
\hline
\mbox{\tt in,out}  & {\em C2} & dimension (L\+D\+C2,N), if side = Plasma\+Left dimension (L\+D\+C2,1), if side = Plasma\+Right On entry, the m by n matrix C2. On exit, C2 is overwritten by the matrix H $\ast$ C2 if S\+I\+D\+E = Plasma\+Left, or C2 $\ast$ H if S\+I\+D\+E = Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C2} & The leading dimension of the array C2. L\+D\+C2 $>$= max(1,\+N), if side == Plasma\+Right. L\+D\+C2 $>$= 1, otherwise.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga49acb5eb786b9f9dedf219519700a4ee_ga49acb5eb786b9f9dedf219519700a4ee}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlarfx2c@{C\+O\+R\+E\+\_\+dlarfx2c}}
\index{C\+O\+R\+E\+\_\+dlarfx2c@{C\+O\+R\+E\+\_\+dlarfx2c}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlarfx2c}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dlarfx2c (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{double}]{V, }
\item[{double}]{T\+A\+U, }
\item[{double $\ast$}]{C1, }
\item[{double $\ast$}]{C2, }
\item[{double $\ast$}]{C3}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga49acb5eb786b9f9dedf219519700a4ee_ga49acb5eb786b9f9dedf219519700a4ee}
C\+O\+R\+E\+\_\+dlarfx2c applies a complex elementary reflector H to a diagonal corner C=\mbox{[}C1, C2, C3\mbox{]}, from both the left and the right side. C = H $\ast$ C $\ast$ H. It is used in the case of Hermetian. If Plasma\+Lower, a left apply is followed by a right apply. If Plasma\+Upper, a right apply is followed by a left apply. H is represented in the form

This routine is a special code for a corner C diagonal block C1 C2 C3

\begin{DoxyVerb}   H = I - tau * v * v'
\end{DoxyVerb}


where tau is a complex scalar and v is a complex vector.

If tau = 0, then H is taken to be the unit matrix

This version uses inline code if H has order $<$ 11.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em V} & The double complex V in the representation of H.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & The value tau in the representation of H.\\
\hline
\mbox{\tt in,out}  & {\em C1} & On entry, the element C1. On exit, C1 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\mbox{\tt in,out}  & {\em C2} & On entry, the element C2. On exit, C2 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\mbox{\tt in,out}  & {\em C3} & On entry, the element C3. On exit, C3 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga202fe50b16b0e3d62660d8095892c60a_ga202fe50b16b0e3d62660d8095892c60a}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlarfx2ce@{C\+O\+R\+E\+\_\+dlarfx2ce}}
\index{C\+O\+R\+E\+\_\+dlarfx2ce@{C\+O\+R\+E\+\_\+dlarfx2ce}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlarfx2ce}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dlarfx2ce (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{double $\ast$}]{V, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{double $\ast$}]{C1, }
\item[{double $\ast$}]{C2, }
\item[{double $\ast$}]{C3}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga202fe50b16b0e3d62660d8095892c60a_ga202fe50b16b0e3d62660d8095892c60a}
C\+O\+R\+E\+\_\+dlarfx2c applies a complex elementary reflector H to a diagonal corner C=\mbox{[}C1, C2, C3\mbox{]}, from both the left and the right side. C = H $\ast$ C $\ast$ H. It is used in the case of general matrices, where it create a nnz at the N\+E\+W\+\_\+\+N\+N\+Z position, then it eliminate it and update the reflector V and T\+A\+U. If Plasma\+Lower, a left apply is followed by a right apply. If Plasma\+Upper, a right apply is followed by a left apply. H is represented in the form

This routine is a special code for a corner C diagonal block C1 N\+E\+W\+\_\+\+N\+N\+Z C2 C3

\begin{DoxyVerb}   H = I - tau * v * v'
\end{DoxyVerb}


where tau is a complex scalar and v is a complex vector.

If tau = 0, then H is taken to be the unit matrix

This version uses inline code if H has order $<$ 11.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in,out}  & {\em V} & On entry, the double complex V in the representation of H. On exit, the double complex V in the representation of H, updated by the elimination of the N\+E\+W\+\_\+\+N\+N\+Z created by the left apply in case of Plasma\+Lower or the right apply in case of Plasma\+Upper.\\
\hline
\mbox{\tt in,out}  & {\em T\+A\+U} & On entry, the value tau in the representation of H. On exit, the value tau in the representation of H, updated by the elimination of the N\+E\+W\+\_\+\+N\+N\+Z created by the left apply in case of Plasma\+Lower or the right apply in case of Plasma\+Upper.\\
\hline
\mbox{\tt in,out}  & {\em C1} & On entry, the element C1. On exit, C1 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\mbox{\tt in,out}  & {\em C2} & On entry, the element C2. On exit, C2 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\mbox{\tt in,out}  & {\em C3} & On entry, the element C3. On exit, C3 is overwritten by the result H $\ast$ C $\ast$ H.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gae4b0750d5458f4e789c2c2e46f7803db_gae4b0750d5458f4e789c2c2e46f7803db}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlarfy@{C\+O\+R\+E\+\_\+dlarfy}}
\index{C\+O\+R\+E\+\_\+dlarfy@{C\+O\+R\+E\+\_\+dlarfy}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlarfy}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlarfy (
\begin{DoxyParamCaption}
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const double $\ast$}]{V, }
\item[{const double $\ast$}]{T\+A\+U, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gae4b0750d5458f4e789c2c2e46f7803db_gae4b0750d5458f4e789c2c2e46f7803db}
C\+O\+R\+E\+\_\+dlarfy applies an elementary reflector, or Householder matrix, H, to a N-\/by-\/\+N hermitian matrix C, from both the left and the right.

H is represented in the form

H = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a scalar and v is a vector.

If tau is zero, then H is taken to be the unit matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & The number of rows and columns of the matrix C. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & D\+O\+U\+B\+L\+E P\+R\+E\+C\+I\+S\+I\+O\+N array, dimension (L\+D\+A, N) On entry, the Hermetian matrix A. On exit, A is overwritten by H $\ast$ A $\ast$ H\textquotesingle{}.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt in}  & {\em V} & The vector V that contains the Householder reflectors.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & The value tau.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga2aaae67cd886ae1519b6b275399224fb_ga2aaae67cd886ae1519b6b275399224fb}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlascal@{C\+O\+R\+E\+\_\+dlascal}}
\index{C\+O\+R\+E\+\_\+dlascal@{C\+O\+R\+E\+\_\+dlascal}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlascal}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dlascal (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{double}]{alpha, }
\item[{double $\ast$}]{A, }
\item[{int}]{lda}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga2aaae67cd886ae1519b6b275399224fb_ga2aaae67cd886ae1519b6b275399224fb}
C\+O\+R\+E\+\_\+dlascal scales a two-\/dimensional matrix A. As opposite to \hyperlink{group__CORE__double_ga36b17d504981a34d6d99186da82e2a28_ga36b17d504981a34d6d99186da82e2a28}{C\+O\+R\+E\+\_\+dlascl()}, no checks is performed to prevent under/overflow. This should have been done at higher level.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies the shape of A\+: = Plasma\+Upper\+Lower\+: A is a general matrix. = Plasma\+Upper\+: A is an upper trapezoidal matrix. = Plasma\+Lower\+: A is a lower trapezoidal matrix.\\
\hline
\mbox{\tt in}  & {\em m} & is the number of rows of the matrix A. m $>$= 0\\
\hline
\mbox{\tt in}  & {\em n} & is the number of columns of the matrix A. n $>$= 0\\
\hline
\mbox{\tt in}  & {\em alpha} & The scalar factor.\\
\hline
\mbox{\tt in,out}  & {\em A} & is the matrix to be multiplied by alpha\\
\hline
\mbox{\tt in}  & {\em lda} & is the leading dimension of the array A. lda $>$= max(1,m).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga36b17d504981a34d6d99186da82e2a28_ga36b17d504981a34d6d99186da82e2a28}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlascl@{C\+O\+R\+E\+\_\+dlascl}}
\index{C\+O\+R\+E\+\_\+dlascl@{C\+O\+R\+E\+\_\+dlascl}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlascl}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dlascl (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{type, }
\item[{int}]{kl, }
\item[{int}]{ku, }
\item[{double}]{cfrom, }
\item[{double}]{cto, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{double $\ast$}]{A, }
\item[{int}]{lda}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga36b17d504981a34d6d99186da82e2a28_ga36b17d504981a34d6d99186da82e2a28}
C\+O\+R\+E\+\_\+dlascl scales all or part of a two-\/dimensional matrix A.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em type} & Specifies the type of the matrix A. = Plasma\+General \+: A is a general matrix = Plasma\+Lower\+Triangular \+: A is a lower triangular matrix = Plasma\+Upper\+Triangular \+: A is an upper triangular matrix = Plasma\+Upper\+Hessenberg \+: A is an upper Hessenberg matrix = Plasma\+Symetric\+Band\+Lower\+Stored \+: A is a symmetric band matrix with lower bandwidth K\+L and upper bandwidth K\+U and with the only the lower half stored = Plasma\+Symetric\+Band\+Upper\+Stored \+: A is a symmetric band matrix with lower bandwidth K\+L and upper bandwidth K\+U and with the only the upper half stored = Plasma\+Band \+: A is a band matrix with lower bandwidth K\+L and upper bandwidth K\+U. See Z\+G\+B\+T\+R\+F for storage details.\\
\hline
\mbox{\tt in}  & {\em kl} & is the lower bandwidth of A. Referenced only if type = Plasma\+Symetric\+Band\+Lower\+Stored, Plasma\+Symetric\+Band\+Upper\+Stored or Plasma\+Band.\\
\hline
\mbox{\tt in}  & {\em ku} & is the upper bandwidth of A. Referenced only if type = Plasma\+Symetric\+Band\+Lower\+Stored, Plasma\+Symetric\+Band\+Upper\+Stored or Plasma\+Band.\\
\hline
\mbox{\tt in}  & {\em cfrom} & is double precision\\
\hline
\mbox{\tt in}  & {\em cto} & is double precision The matrix A is multiplied bt cto/cfrom. cfrom must be nonzero. The final result ctot$\ast$\+A(i,j)/cfrom is computed without over/underflow\\
\hline
\mbox{\tt in}  & {\em m} & is the number of rows of the matrix A. m $>$= 0\\
\hline
\mbox{\tt in}  & {\em n} & is the number of columns of the matrix A. n $>$= 0\\
\hline
\mbox{\tt in,out}  & {\em A} & is the matrix to be multiplied by cto/cfrom\\
\hline
\mbox{\tt in}  & {\em lda} & is the leading dimension of the array A. lda $>$= max(1,m).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga1c669131b52830b6553434ea23afa985_ga1c669131b52830b6553434ea23afa985}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaset@{C\+O\+R\+E\+\_\+dlaset}}
\index{C\+O\+R\+E\+\_\+dlaset@{C\+O\+R\+E\+\_\+dlaset}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaset}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaset (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double}]{alpha, }
\item[{double}]{beta, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga1c669131b52830b6553434ea23afa985_ga1c669131b52830b6553434ea23afa985}
C\+O\+R\+E\+\_\+dlaset -\/ Sets the elements of the matrix A on the diagonal to beta and on the off-\/diagonals to alpha


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies which elements of the matrix are to be set = Plasma\+Upper\+: Upper part of A is set; = Plasma\+Lower\+: Lower part of A is set; = Plasma\+Upper\+Lower\+: A\+L\+L elements of A are set.\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & The constant to which the off-\/diagonal elements are to be set.\\
\hline
\mbox{\tt in}  & {\em beta} & The constant to which the diagonal elements are to be set.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile A. On exit, A has been set accordingly.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga4642e2b653e27425594106afd89c4859_ga4642e2b653e27425594106afd89c4859}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaset2@{C\+O\+R\+E\+\_\+dlaset2}}
\index{C\+O\+R\+E\+\_\+dlaset2@{C\+O\+R\+E\+\_\+dlaset2}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaset2}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaset2 (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double}]{alpha, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga4642e2b653e27425594106afd89c4859_ga4642e2b653e27425594106afd89c4859}
C\+O\+R\+E\+\_\+dlaset2 -\/ Sets the elements of the matrix A to alpha. Not L\+A\+P\+A\+C\+K compliant! Read below.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies which elements of the matrix are to be set = Plasma\+Upper\+: S\+T\+R\+I\+C\+T Upper part of A is set to alpha; = Plasma\+Lower\+: S\+T\+R\+I\+C\+T Lower part of A is set to alpha; = Plasma\+Upper\+Lower\+: A\+L\+L elements of A are set to alpha. Not L\+A\+P\+A\+C\+K Compliant.\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & The constant to which the elements are to be set.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile A. On exit, A has been set to alpha accordingly.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga106b201ef777b959b2233bd7d4b40305_ga106b201ef777b959b2233bd7d4b40305}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaswp@{C\+O\+R\+E\+\_\+dlaswp}}
\index{C\+O\+R\+E\+\_\+dlaswp@{C\+O\+R\+E\+\_\+dlaswp}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaswp}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlaswp (
\begin{DoxyParamCaption}
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int}]{I1, }
\item[{int}]{I2, }
\item[{const int $\ast$}]{I\+P\+I\+V, }
\item[{int}]{I\+N\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga106b201ef777b959b2233bd7d4b40305_ga106b201ef777b959b2233bd7d4b40305}
C\+O\+R\+E\+\_\+dlaswp performs a series of row interchanges on the matrix A. One row interchange is initiated for each of rows I1 through I2 of A.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & The number of columns in the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the matrix of column dimension N to which the row interchanges will be applied. On exit, the permuted matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,max(I\+P\+I\+V\mbox{[}I1..I2\mbox{]})).\\
\hline
\mbox{\tt in}  & {\em I1} & The first element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em I2} & The last element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em I\+P\+I\+V} & The pivot indices; Only the element in position i1 to i2 are accessed. The pivot are offset by A.\+i.\\
\hline
\mbox{\tt in}  & {\em I\+N\+C} & The increment between successive values of I\+P\+I\+V. If I\+P\+I\+V is negative, the pivots are applied in reverse order. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gadb50a1cf5c2191046cfa1055414bcc89_gadb50a1cf5c2191046cfa1055414bcc89}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaswp\+\_\+ontile@{C\+O\+R\+E\+\_\+dlaswp\+\_\+ontile}}
\index{C\+O\+R\+E\+\_\+dlaswp\+\_\+ontile@{C\+O\+R\+E\+\_\+dlaswp\+\_\+ontile}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaswp\+\_\+ontile}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dlaswp\+\_\+ontile (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{desc\+A, }
\item[{int}]{i1, }
\item[{int}]{i2, }
\item[{const int $\ast$}]{ipiv, }
\item[{int}]{inc}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gadb50a1cf5c2191046cfa1055414bcc89_gadb50a1cf5c2191046cfa1055414bcc89}
C\+O\+R\+E\+\_\+dlaswp\+\_\+ontile apply the dlaswp function on a matrix stored in tile layout


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em desc\+A} & The descriptor of the matrix A to permute.\\
\hline
\mbox{\tt in}  & {\em i1} & The first element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em i2} & The last element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em ipiv} & The pivot indices; Only the element in position i1 to i2 are accessed. The pivot are offset by A.\+i.\\
\hline
\mbox{\tt in}  & {\em inc} & The increment between successive values of I\+P\+I\+V. If I\+P\+I\+V is negative, the pivots are applied in reverse order.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gab49a7c8c5a269b2358ee568c559cc948_gab49a7c8c5a269b2358ee568c559cc948}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlaswpc\+\_\+ontile@{C\+O\+R\+E\+\_\+dlaswpc\+\_\+ontile}}
\index{C\+O\+R\+E\+\_\+dlaswpc\+\_\+ontile@{C\+O\+R\+E\+\_\+dlaswpc\+\_\+ontile}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlaswpc\+\_\+ontile}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dlaswpc\+\_\+ontile (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{desc\+A, }
\item[{int}]{i1, }
\item[{int}]{i2, }
\item[{const int $\ast$}]{ipiv, }
\item[{int}]{inc}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gab49a7c8c5a269b2358ee568c559cc948_gab49a7c8c5a269b2358ee568c559cc948}
C\+O\+R\+E\+\_\+dlaswpc\+\_\+ontile apply the dlaswp function on a matrix stored in tile layout


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em desc\+A} & The descriptor of the matrix A to permute.\\
\hline
\mbox{\tt in}  & {\em i1} & The first element of I\+P\+I\+V for which a column interchange will be done.\\
\hline
\mbox{\tt in}  & {\em i2} & The last element of I\+P\+I\+V for which a column interchange will be done.\\
\hline
\mbox{\tt in}  & {\em ipiv} & The pivot indices; Only the element in position i1 to i2 are accessed. The pivot are offset by A.\+i.\\
\hline
\mbox{\tt in}  & {\em inc} & The increment between successive values of I\+P\+I\+V. If I\+P\+I\+V is negative, the pivots are applied in reverse order.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga164bb987707f2c51fafe19b1c630d5d3_ga164bb987707f2c51fafe19b1c630d5d3}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlatro@{C\+O\+R\+E\+\_\+dlatro}}
\index{C\+O\+R\+E\+\_\+dlatro@{C\+O\+R\+E\+\_\+dlatro}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlatro}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dlatro (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga164bb987707f2c51fafe19b1c630d5d3_ga164bb987707f2c51fafe19b1c630d5d3}
C\+O\+R\+E\+\_\+dlatro transposes a m-\/by-\/n matrix out of place.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular\+: = Plasma\+Upper\+: the upper triangle of A and the lower triangle of B are referenced. = Plasma\+Lower\+: the lower triangle of A and the upper triangle of B are referenced. = Plasma\+Upper\+Lower\+: All A and B are referenced.\\
\hline
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is transposed, not transposed or ugate transposed\+: = Plasma\+No\+Trans\+: B is a copy of A (equivalent to dlacpy); = Plasma\+Trans\+: B is the transpose of A; = Plasma\+Trans\+: B is the ugate transpose of A.\\
\hline
\mbox{\tt in}  & {\em M} & Number of rows of the matrix A and number of columns of the matrix B, if trans == Pasma\mbox{[}Conj\mbox{]}Trans. Number of rows of the matrix A and the matrix B, if trans == Pasma\+No\+Trans.\\
\hline
\mbox{\tt in}  & {\em N} & Number of columns of the matrix A and number of rows of the matrix B, if trans == Pasma\mbox{[}Conj\mbox{]}Trans. Number of columns of the matrix A and of the matrix B, if trans == Plasma\+No\+Trans.\\
\hline
\mbox{\tt in}  & {\em A} & Matrix of size L\+D\+A-\/by-\/\+N, if trans == Pasma\mbox{[}Conj\mbox{]}Trans. Matrix of size L\+D\+A-\/by-\/\+M, if trans == Pasma\+No\+Trans.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M), if trans == Pasma\mbox{[}Conj\mbox{]}Trans. L\+D\+A $>$= max(1,\+N), if trans == Pasma\+No\+Trans.\\
\hline
\mbox{\tt out}  & {\em B} & Matrix of size L\+D\+B-\/by-\/\+M, if trans == Pasma\mbox{[}Conj\mbox{]}Trans. Matrix of size L\+D\+B-\/by-\/\+N, if trans == Pasma\+No\+Trans.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+N), if trans == Pasma\mbox{[}Conj\mbox{]}Trans. L\+D\+B $>$= max(1,\+M), if trans == Pasma\+No\+Trans.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga7b1e511d379ee30b94e0b0baf0b66661_ga7b1e511d379ee30b94e0b0baf0b66661}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dlauum@{C\+O\+R\+E\+\_\+dlauum}}
\index{C\+O\+R\+E\+\_\+dlauum@{C\+O\+R\+E\+\_\+dlauum}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dlauum}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dlauum (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga7b1e511d379ee30b94e0b0baf0b66661_ga7b1e511d379ee30b94e0b0baf0b66661}
C\+O\+R\+E\+\_\+dlauum -\/ Computes the product U $\ast$ U\textquotesingle{} or L\textquotesingle{} $\ast$ L, where the triangular factor U or L is stored in the upper or lower triangular part of the array A.

If U\+P\+L\+O = \textquotesingle{}U\textquotesingle{} or \textquotesingle{}u\textquotesingle{} then the upper triangle of the result is stored, overwriting the factor U in A. If U\+P\+L\+O = \textquotesingle{}L\textquotesingle{} or \textquotesingle{}l\textquotesingle{} then the lower triangle of the result is stored, overwriting the factor L in A.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the triangular factor U or L. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the triangular factor U or L. On exit, if U\+P\+L\+O = \textquotesingle{}U\textquotesingle{}, the upper triangle of A is overwritten with the upper triangle of the product U $\ast$ U\textquotesingle{}; if U\+P\+L\+O = \textquotesingle{}L\textquotesingle{}, the lower triangle of A is overwritten with the lower triangle of the product L\textquotesingle{} $\ast$ L.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga041e33a314b8316c8ecfa37ed236d826_ga041e33a314b8316c8ecfa37ed236d826}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dormlq@{C\+O\+R\+E\+\_\+dormlq}}
\index{C\+O\+R\+E\+\_\+dormlq@{C\+O\+R\+E\+\_\+dormlq}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dormlq}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dormlq (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{C, }
\item[{int}]{L\+D\+C, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga041e33a314b8316c8ecfa37ed236d826_ga041e33a314b8316c8ecfa37ed236d826}
C\+O\+R\+E\+\_\+dormlq overwrites the general complex M-\/by-\/\+N tile C with \begin{DoxyVerb}              SIDE = 'L'     SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ C C $\ast$ Q T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+T $\ast$ C C $\ast$ Q$\ast$$\ast$\+T

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(k) . . . H(2) H(1)

as returned by C\+O\+R\+E\+\_\+dgelqt. Q is of order M if S\+I\+D\+E = \textquotesingle{}L\textquotesingle{} and of order N if S\+I\+D\+E = \textquotesingle{}R\textquotesingle{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+T from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+T from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Trans \+: Transpose, apply Q$\ast$$\ast$\+T.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the tile C. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile C. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q. If S\+I\+D\+E = Plasma\+Left, M $>$= K $>$= 0; if S\+I\+D\+E = Plasma\+Right, N $>$= K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & Dimension\+: (L\+D\+A,M) if S\+I\+D\+E = Plasma\+Left, (L\+D\+A,N) if S\+I\+D\+E = Plasma\+Right, The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+dgelqt in the first k rows of its array argument A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+K triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt in,out}  & {\em C} & On entry, the M-\/by-\/\+N tile C. On exit, C is overwritten by Q$\ast$\+C or Q$\ast$$\ast$\+T$\ast$\+C or C$\ast$\+Q$\ast$$\ast$\+T or C$\ast$\+Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & On exit, if I\+N\+F\+O = 0, W\+O\+R\+K(1) returns the optimal L\+D\+W\+O\+R\+K.\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K. If S\+I\+D\+E = Plasma\+Left, L\+D\+W\+O\+R\+K $>$= max(1,\+N); if S\+I\+D\+E = Plasma\+Right, L\+D\+W\+O\+R\+K $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga88f757c9197146e057b433613021da79_ga88f757c9197146e057b433613021da79}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dormqr@{C\+O\+R\+E\+\_\+dormqr}}
\index{C\+O\+R\+E\+\_\+dormqr@{C\+O\+R\+E\+\_\+dormqr}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dormqr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dormqr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{C, }
\item[{int}]{L\+D\+C, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga88f757c9197146e057b433613021da79_ga88f757c9197146e057b433613021da79}
C\+O\+R\+E\+\_\+dormqr overwrites the general complex M-\/by-\/\+N tile C with \begin{DoxyVerb}              SIDE = 'L'     SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ C C $\ast$ Q T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+T $\ast$ C C $\ast$ Q$\ast$$\ast$\+T

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(1) H(2) . . . H(k)

as returned by C\+O\+R\+E\+\_\+dgeqrt. Q is of order M if S\+I\+D\+E = \textquotesingle{}L\textquotesingle{} and of order N if S\+I\+D\+E = \textquotesingle{}R\textquotesingle{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+T from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+T from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Trans \+: Transpose, apply Q$\ast$$\ast$\+T.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the tile C. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile C. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q. If S\+I\+D\+E = Plasma\+Left, M $>$= K $>$= 0; if S\+I\+D\+E = Plasma\+Right, N $>$= K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & Dimension\+: (L\+D\+A,K) The i-\/th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+dgeqrt in the first k columns of its array argument A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. If S\+I\+D\+E = Plasma\+Left, L\+D\+A $>$= max(1,\+M); if S\+I\+D\+E = Plasma\+Right, L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+K triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt in,out}  & {\em C} & On entry, the M-\/by-\/\+N tile C. On exit, C is overwritten by Q$\ast$\+C or Q$\ast$$\ast$\+T$\ast$\+C or C$\ast$\+Q$\ast$$\ast$\+T or C$\ast$\+Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & On exit, if I\+N\+F\+O = 0, W\+O\+R\+K(1) returns the optimal L\+D\+W\+O\+R\+K.\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K. If S\+I\+D\+E = Plasma\+Left, L\+D\+W\+O\+R\+K $>$= max(1,\+N); if S\+I\+D\+E = Plasma\+Right, L\+D\+W\+O\+R\+K $>$= max(1,\+M).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga321879836e956b6c8420ebb49db208e5_ga321879836e956b6c8420ebb49db208e5}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dpamm@{C\+O\+R\+E\+\_\+dpamm}}
\index{C\+O\+R\+E\+\_\+dpamm@{C\+O\+R\+E\+\_\+dpamm}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dpamm}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dpamm (
\begin{DoxyParamCaption}
\item[{int}]{op, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{storev, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{int}]{L, }
\item[{const double $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const double $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{double $\ast$}]{W, }
\item[{int}]{L\+D\+W}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga321879836e956b6c8420ebb49db208e5_ga321879836e956b6c8420ebb49db208e5}
Z\+P\+A\+M\+M performs one of the matrix-\/matrix operations \begin{DoxyVerb}              LEFT                      RIGHT
\end{DoxyVerb}
 O\+P Plasma\+W \+: W = A1 + op(\+V) $\ast$ A2 or W = A1 + A2 $\ast$ op(\+V) O\+P Plasma\+A2 \+: A2 = A2 -\/ op(\+V) $\ast$ W or A2 = A2 -\/ W $\ast$ op(\+V)

where op( V ) is one of

op( V ) = V or op( V ) = V$\ast$$\ast$\+T or op( V ) = V$\ast$$\ast$\+T,

A1, A2 and W are general matrices, and V is\+: \begin{DoxyVerb}  l = k: rectangle + triangle
  l < k: rectangle + trapezoid
  l = 0: rectangle
\end{DoxyVerb}


Size of V, both rowwise and columnwise, is\+: 

 \subsubsection*{side trans size }

left N M x K T K x M right N K x N \subsubsection*{T N x K }

L\+E\+F\+T (columnwise and rowwise)\+: \begin{DoxyVerb}        |    K    |                 |         M         |
     _  __________   _              _______________        _
        |    |    |                 |             | \
\end{DoxyVerb}
 V\+: $\vert$ $\vert$ $\vert$ V\textquotesingle{}\+: $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$\+\_\+\+\_\+\+\_\+\textbackslash{} K $\vert$ $\vert$ $\vert$ M-\/\+L $\vert$ $\vert$ M $\vert$ $\vert$ $\vert$ $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+ $\vert$\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ $\vert$ \+\_\+ \textbackslash{} $\vert$ $\vert$ $\vert$ M -\/ L $\vert$ L $\vert$ \textbackslash{} $\vert$ $\vert$ L \+\_\+ $|$\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+

R\+I\+G\+H\+T (columnwise and rowwise)\+: \begin{DoxyVerb}    |         K         |                   |    N    |
    _______________        _             _  __________   _
    |             | \                       |    |    |
\end{DoxyVerb}
 V\textquotesingle{}\+: $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$\+\_\+\+\_\+\+\_\+\textbackslash{} N V\+: $\vert$ $\vert$ $\vert$ $\vert$ $\vert$ $\vert$ $\vert$ $\vert$ K-\/\+L $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+ K $\vert$ $\vert$ $\vert$ $\vert$\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ $\vert$ \+\_\+ $\vert$ K -\/ L $\vert$ L $\vert$ \textbackslash{} $\vert$ $\vert$ \textbackslash{} $\vert$ $\vert$ L \+\_\+ $|$\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+

\subsection*{Arguments }


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em op} & \begin{DoxyVerb}    OP specifies which operation to perform:

    @arg PlasmaW  : W  = A1 + op(V) * A2  or  W  = A1 + A2 * op(V)
    @arg PlasmaA2 : A2 = A2 - op(V) * W   or  A2 = A2 - W * op(V)
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em side} & \begin{DoxyVerb}    SIDE specifies whether  op( V ) multiplies A2
    or W from the left or right as follows:

    @arg PlasmaLeft  : multiply op( V ) from the left
                       OP PlasmaW  :  W  = A1 + op(V) * A2
                       OP PlasmaA2 :  A2 = A2 - op(V) * W

    @arg PlasmaRight : multiply op( V ) from the right
                       OP PlasmaW  :  W  = A1 + A2 * op(V)
                       OP PlasmaA2 :  A2 = A2 - W * op(V)
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em storev} & \begin{DoxyVerb}    Indicates how the vectors which define the elementary
    reflectors are stored in V:

    @arg PlasmaColumnwise
    @arg PlasmaRowwise
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the A1, A2 and W If S\+I\+D\+E is Plasma\+Left, the number of rows of op( V )\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the A1, A2 and W If S\+I\+D\+E is Plasma\+Right, the number of columns of op( V )\\
\hline
\mbox{\tt in}  & {\em K} & If S\+I\+D\+E is Plasma\+Left, the number of columns of op( V ) If S\+I\+D\+E is Plasma\+Right, the number of rows of op( V )\\
\hline
\mbox{\tt in}  & {\em L} & The size of the triangular part of V\\
\hline
\mbox{\tt in}  & {\em A1} & On entry, the M-\/by-\/\+N tile A1.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M-\/by-\/\+N tile A2. On exit, if O\+P is Plasma\+A2 A2 is overwritten\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em V} & The matrix V as described above. If S\+I\+D\+E is Plasma\+Left \+: op( V ) is M-\/by-\/\+K If S\+I\+D\+E is Plasma\+Right\+: op( V ) is K-\/by-\/\+N\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V.\\
\hline
\mbox{\tt in,out}  & {\em W} & On entry, the M-\/by-\/\+N matrix W. On exit, W is overwritten either if O\+P is Plasma\+A2 or Plasma\+W. If O\+P is Plasma\+A2, W is an input and is used as a workspace.\\
\hline
\mbox{\tt in}  & {\em L\+D\+W} & The leading dimension of array W\+O\+R\+K.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gab9f985d68d7efaf1bbd811598c6eb987_gab9f985d68d7efaf1bbd811598c6eb987}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dparfb@{C\+O\+R\+E\+\_\+dparfb}}
\index{C\+O\+R\+E\+\_\+dparfb@{C\+O\+R\+E\+\_\+dparfb}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dparfb}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dparfb (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{direct, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{storev, }
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{L, }
\item[{double $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const double $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gab9f985d68d7efaf1bbd811598c6eb987_gab9f985d68d7efaf1bbd811598c6eb987}
C\+O\+R\+E\+\_\+dparfb applies a complex upper triangular block reflector H or its transpose H\textquotesingle{} to a complex rectangular matrix formed by coupling two tiles A1 and A2. Matrix V is\+: \begin{DoxyVerb}    COLUMNWISE                    ROWWISE

   |     K     |                 |      N2-L     |   L  |
__ _____________ __           __ _________________        __
   |    |      |                 |               | \
   |    |      |                 |               |   \    L
\end{DoxyVerb}
 M2-\/\+L $\vert$ $\vert$ $\vert$ K $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\textbackslash{} \+\_\+\+\_\+ $\vert$ $\vert$ $\vert$ M2 $\vert$ $\vert$ \+\_\+\+\_\+ $\vert$\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ $\vert$ $\vert$ $\vert$ K-\/\+L \textbackslash{} $\vert$ $\vert$ \+\_\+\+\_\+ $\vert$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+\+\_\+ L \textbackslash{} $\vert$ $\vert$ \+\_\+\+\_\+ $|$\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+\+\_\+ $\vert$ N2 $\vert$

$\vert$ L $\vert$ K-\/\+L $\vert$


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+T from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+T from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+T.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em direct} & Indicates how H is formed from a product of elementary reflectors \begin{DoxyItemize}
\item Plasma\+Forward \+: H = H(1) H(2) . . . H(k) (Forward) \item Plasma\+Backward \+: H = H(k) . . . H(2) H(1) (Backward)\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em storev} & Indicates how the vectors which define the elementary reflectors are stored\+: \begin{DoxyItemize}
\item Plasma\+Columnwise \item Plasma\+Rowwise\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M1} & The number of columns of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of rows of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of columns of the tile A2. M2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of rows of the tile A2. N2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The order of the matrix T (= the number of elementary reflectors whose product defines the block reflector).\\
\hline
\mbox{\tt in}  & {\em L} & The size of the triangular part of V\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+N1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+N2).\\
\hline
\mbox{\tt in}  & {\em V} & (L\+D\+V,K) if S\+T\+O\+R\+E\+V = \textquotesingle{}C\textquotesingle{} (L\+D\+V,M2) if S\+T\+O\+R\+E\+V = \textquotesingle{}R\textquotesingle{} and S\+I\+D\+E = \textquotesingle{}L\textquotesingle{} (L\+D\+V,N2) if S\+T\+O\+R\+E\+V = \textquotesingle{}R\textquotesingle{} and S\+I\+D\+E = \textquotesingle{}R\textquotesingle{} Matrix V.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. If S\+T\+O\+R\+E\+V = \textquotesingle{}C\textquotesingle{} and S\+I\+D\+E = \textquotesingle{}L\textquotesingle{}, L\+D\+V $>$= max(1,\+M2); if S\+T\+O\+R\+E\+V = \textquotesingle{}C\textquotesingle{} and S\+I\+D\+E = \textquotesingle{}R\textquotesingle{}, L\+D\+V $>$= max(1,\+N2); if S\+T\+O\+R\+E\+V = \textquotesingle{}R\textquotesingle{}, L\+D\+V $>$= K.\\
\hline
\mbox{\tt out}  & {\em T} & The triangular K-\/by-\/\+K matrix T in the representation of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= K.\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & \\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga7e36702038ad3e238158fef1dc86eb61_ga7e36702038ad3e238158fef1dc86eb61}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dpemv@{C\+O\+R\+E\+\_\+dpemv}}
\index{C\+O\+R\+E\+\_\+dpemv@{C\+O\+R\+E\+\_\+dpemv}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dpemv}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dpemv (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{storev, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{L, }
\item[{double}]{A\+L\+P\+H\+A, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const double $\ast$}]{X, }
\item[{int}]{I\+N\+C\+X, }
\item[{double}]{B\+E\+T\+A, }
\item[{double $\ast$}]{Y, }
\item[{int}]{I\+N\+C\+Y, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga7e36702038ad3e238158fef1dc86eb61_ga7e36702038ad3e238158fef1dc86eb61}
C\+O\+R\+E\+\_\+dpemv performs one of the matrix-\/vector operations

y = alpha$\ast$op( A )$\ast$x + beta$\ast$y

where op( A ) is one of

op( A ) = A or op( A ) = A$\ast$$\ast$\+T or op( A ) = A$\ast$$\ast$\+T,

alpha and beta are scalars, x and y are vectors and A is a pentagonal matrix (see further details).

\subsection*{Arguments }


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em storev} & \begin{DoxyVerb}    @arg PlasmaColumnwise :  array A stored columwise
    @arg PlasmaRowwise    :  array A stored rowwise
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyVerb}    @arg PlasmaNoTrans   :  y := alpha*A*x    + beta*y.
    @arg PlasmaTrans     :  y := alpha*A**T*x + beta*y.
    @arg PlasmaTrans :  y := alpha*A**T*x + beta*y.
\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & Number of rows of the matrix A. M must be at least zero.\\
\hline
\mbox{\tt in}  & {\em N} & Number of columns of the matrix A. N must be at least zero.\\
\hline
\mbox{\tt in}  & {\em L} & Order of triangle within the matrix A (L specifies the shape of the matrix A; see further details).\\
\hline
\mbox{\tt in}  & {\em A\+L\+P\+H\+A} & Scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & Array of size L\+D\+A-\/by-\/\+N. On entry, the leading M by N part of the array A must contain the matrix of coefficients.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & Leading dimension of array A.\\
\hline
\mbox{\tt in}  & {\em X} & On entry, the incremented array X must contain the vector x.\\
\hline
\mbox{\tt in}  & {\em I\+N\+C\+X} & Increment for the elements of X. I\+N\+C\+X must not be zero.\\
\hline
\mbox{\tt in}  & {\em B\+E\+T\+A} & Scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em Y} & On entry, the incremented array Y must contain the vector y.\\
\hline
\mbox{\tt out}  & {\em I\+N\+C\+Y} & Increment for the elements of Y. I\+N\+C\+Y must not be zero.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size at least L.\\
\hline
\end{DoxyParams}
\subsection*{Further Details }

\begin{DoxyVerb}         |     N    |
      _   ___________   _
         |          |
\end{DoxyVerb}
 A\+: $\vert$ $\vert$ M-\/\+L $\vert$ $\vert$ $\vert$ $\vert$ M \+\_\+ $\vert$..... $\vert$ \textbackslash{} \+: $\vert$ L \textbackslash{} \+: $\vert$ \+\_\+ \textbackslash{}\+:\+\_\+\+\_\+\+\_\+\+\_\+\+\_\+$\vert$ \+\_\+

$\vert$ L $\vert$ N-\/\+L $\vert$

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gae5ff912cce66f5666d5b76fb7da5e9e2_gae5ff912cce66f5666d5b76fb7da5e9e2}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dplgsy@{C\+O\+R\+E\+\_\+dplgsy}}
\index{C\+O\+R\+E\+\_\+dplgsy@{C\+O\+R\+E\+\_\+dplgsy}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dplgsy}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dplgsy (
\begin{DoxyParamCaption}
\item[{double}]{bump, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{double $\ast$}]{A, }
\item[{int}]{lda, }
\item[{int}]{g\+M, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{unsigned long long int}]{seed}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gae5ff912cce66f5666d5b76fb7da5e9e2_gae5ff912cce66f5666d5b76fb7da5e9e2}
C\+O\+R\+E\+\_\+dplgsy generates a symmetric matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em bump} & Scalar added to the diagonal of the full Matrix A to make it diagonal dominant.\\
\hline
\mbox{\tt in}  & {\em m} & The number of rows of the tile A. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the tile A. n $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the m-\/by-\/n tile to be initialized. On exit, the tile initialized in the mtxtype format.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the tile A. lda $>$= max(1,m).\\
\hline
\mbox{\tt in}  & {\em g\+M} & The global number of rows of the full matrix, A is belonging to. g\+M $>$= (m0+\+M).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em seed} & The seed used for random generation. Must be the same for all tiles initialized with this routine. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gaf3c013847f99f3d28eb16c98ae5c4e11_gaf3c013847f99f3d28eb16c98ae5c4e11}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dplrnt@{C\+O\+R\+E\+\_\+dplrnt}}
\index{C\+O\+R\+E\+\_\+dplrnt@{C\+O\+R\+E\+\_\+dplrnt}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dplrnt}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dplrnt (
\begin{DoxyParamCaption}
\item[{int}]{m, }
\item[{int}]{n, }
\item[{double $\ast$}]{A, }
\item[{int}]{lda, }
\item[{int}]{g\+M, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{unsigned long long int}]{seed}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaf3c013847f99f3d28eb16c98ae5c4e11_gaf3c013847f99f3d28eb16c98ae5c4e11}
C\+O\+R\+E\+\_\+dplrnt generates a random tile.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & The number of rows of the tile A. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the tile A. n $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the m-\/by-\/n tile to be initialized. On exit, the tile initialized in the mtxtype format.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the tile A. lda $>$= max(1,m).\\
\hline
\mbox{\tt in}  & {\em g\+M} & The global number of rows of the full matrix, A is belonging to. g\+M $>$= (m0+\+M).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em seed} & The seed used for random generation. Must be the same for all tiles initialized with this routine. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga676f991618b7d88938f1d6d19d4eabc8_ga676f991618b7d88938f1d6d19d4eabc8}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dpltmg@{C\+O\+R\+E\+\_\+dpltmg}}
\index{C\+O\+R\+E\+\_\+dpltmg@{C\+O\+R\+E\+\_\+dpltmg}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dpltmg}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dpltmg (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{mtxtype, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int}]{g\+M, }
\item[{int}]{g\+N, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{unsigned long long int}]{seed}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga676f991618b7d88938f1d6d19d4eabc8_ga676f991618b7d88938f1d6d19d4eabc8}
C\+O\+R\+E\+\_\+dpltmg initialize a tile of a random matrix from the Mat\+Lab gallery configured with the default parameters, and a few other specific matrices.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em mtxtype} & Possible types are\+: Plasma\+Matrix\+Random, Plasma\+Matrix\+Hadamard, Plasma\+Matrix\+Parter, Plasma\+Matrix\+Ris, Plasma\+Matrix\+Kms, Plasma\+Matrix\+Moler, Plasma\+Matrix\+Compan, Plasma\+Matrix\+Riemann, Plasma\+Matrix\+Lehmer, Plasma\+Matrix\+Minij, Plasma\+Matrix\+Dorr, Plasma\+Matrix\+Demmel, Plasma\+Matrix\+Invhess, Plasma\+Matrix\+Cauchy, Plasma\+Matrix\+Hilb, Plasma\+Matrix\+Lotkin, Plasma\+Matrix\+Orthog, Plasma\+Matrix\+Wilkinson, Plasma\+Matrix\+Foster, Plasma\+Matrix\+Wright, Plasma\+Matrix\+Langou (See further in the code for more details)\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized. On exit, the tile initialized in the mtxtype format.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em g\+M} & The global number of rows of the full matrix, A is belonging to. g\+M $>$= (m0+\+M).\\
\hline
\mbox{\tt in}  & {\em g\+N} & The global number of columns of the full matrix, A is belonging to. g\+N $>$= (n0+g\+N).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em seed} & The seed used for random generation. Must be the same for all tiles initialized with this routine.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gab0f1d5c66afbf4770932b2a61a32b837_gab0f1d5c66afbf4770932b2a61a32b837}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dpltmg\+\_\+chebvand@{C\+O\+R\+E\+\_\+dpltmg\+\_\+chebvand}}
\index{C\+O\+R\+E\+\_\+dpltmg\+\_\+chebvand@{C\+O\+R\+E\+\_\+dpltmg\+\_\+chebvand}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dpltmg\+\_\+chebvand}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dpltmg\+\_\+chebvand (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int}]{g\+N, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{double $\ast$}]{W}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gab0f1d5c66afbf4770932b2a61a32b837_gab0f1d5c66afbf4770932b2a61a32b837}
C\+O\+R\+E\+\_\+dpltmg\+\_\+chebvand is a kernel used in Vandermonde-\/like matrix generation

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-999859}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/999859}

Vandermonde-\/like matrix for the Chebyshev polynomials

Produces the (primal) Chebyshev Vandermonde matrix based on the vector of points p, which define where the Chebyshev polynomial is calculated.

If seed != 0, C(i,j) = Ti  1(p(j)) where Ti  1 is the Chebyshev polynomial of degree i  1, and p is a vector of N equally spaced points on the interval \mbox{[}0,1\mbox{]}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A to initialize. M $>$= 2.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A to initialize. N $>$= 0.\\
\hline
\mbox{\tt out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized. On exit, each element of A is defined by\+: A(i,j) = Ti  1(p(j)) where Ti  1 is the Chebyshev polynomial of degree i  1\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em g\+N} & The global number of columns of the full matrix, A is belonging to. g\+N $>$= (n0+g\+N).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em g\+N} & The global number of columns of the full matrix, A is belonging to. g\+N $>$= (n0+g\+N).\\
\hline
\mbox{\tt in,out}  & {\em W} & Workspace of size 2-\/by-\/\+N, that contains the N triplets\+: ( A( m0-\/2, j), A(m0-\/1, j) ) On entry, if m == 0, W is uinitialized, otherwise contains the data described above. On exit, contains the triplets ( A(m0+\+M-\/2, j), A(m0+\+M-\/1, j) )\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga548433b2a88abe28bcf0dafdb7777833_ga548433b2a88abe28bcf0dafdb7777833}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dpltmg\+\_\+circul@{C\+O\+R\+E\+\_\+dpltmg\+\_\+circul}}
\index{C\+O\+R\+E\+\_\+dpltmg\+\_\+circul@{C\+O\+R\+E\+\_\+dpltmg\+\_\+circul}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dpltmg\+\_\+circul}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dpltmg\+\_\+circul (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int}]{g\+M, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{const double $\ast$}]{V}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga548433b2a88abe28bcf0dafdb7777833_ga548433b2a88abe28bcf0dafdb7777833}
C\+O\+R\+E\+\_\+dpltmg\+\_\+circul is a kernel used in circulant matrix generation

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-999880}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/999880}

Circulant matrix

A circulant matrix has the property that each row is obtained from the previous one by cyclically permuting the entries one step forward. It is a special Toeplitz matrix in which the diagonals \char`\"{}wrap around.\char`\"{}

The eigensystem of C (n-\/by-\/n) is known explicitly\+: If t is an nth root of unity, then the inner product of v and w = \mbox{[}1 t t2 ... t(n  1)\mbox{]} is an eigenvalue of C and w(n\+:-\/1\+:1) is an eigenvector, where v is the first column of C.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A to initialize. M $>$= 2.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A to initialize. N $>$= 0.\\
\hline
\mbox{\tt out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em g\+M} & The global number of rows of the full matrix, A is belonging to. g\+M $>$= (m0+g\+M).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em V} & Workspace of size g\+M, that contains the first clumn of the full matrix\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga230f3c575fe0c38f1e59a7671ab111a1_ga230f3c575fe0c38f1e59a7671ab111a1}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dpltmg\+\_\+condexq@{C\+O\+R\+E\+\_\+dpltmg\+\_\+condexq}}
\index{C\+O\+R\+E\+\_\+dpltmg\+\_\+condexq@{C\+O\+R\+E\+\_\+dpltmg\+\_\+condexq}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dpltmg\+\_\+condexq}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dpltmg\+\_\+condexq (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double $\ast$}]{Q, }
\item[{int}]{L\+D\+Q}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga230f3c575fe0c38f1e59a7671ab111a1_ga230f3c575fe0c38f1e59a7671ab111a1}
C\+O\+R\+E\+\_\+dpltmg\+\_\+condexq generates the Q used in condex matrix generation

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-999898}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/999898} gallery(\textquotesingle{}condex\textquotesingle{},n,4,100)

Returns a \char`\"{}counter-\/example\char`\"{} matrix to a condition estimator. It has order n and scalar parameter theta (default 100).

L\+A\+P\+A\+C\+K (R\+C\+O\+N\+D)\+: It is the inverse of this matrix that is a counter-\/example.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the matrix Q used in condex generation. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the matrix A to be generated. N $>$= 0.\\
\hline
\mbox{\tt out}  & {\em Q} & On entry, the M-\/by-\/3 matrix to be initialized. On exit, the housholder reflectors required for condex generation.\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & The leading dimension of the matrix Q. L\+D\+Q $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gae0a46d5ef37e8689c3ace89dac0d7d46_gae0a46d5ef37e8689c3ace89dac0d7d46}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dpltmg\+\_\+fiedler@{C\+O\+R\+E\+\_\+dpltmg\+\_\+fiedler}}
\index{C\+O\+R\+E\+\_\+dpltmg\+\_\+fiedler@{C\+O\+R\+E\+\_\+dpltmg\+\_\+fiedler}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dpltmg\+\_\+fiedler}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dpltmg\+\_\+fiedler (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const double $\ast$}]{X, }
\item[{int}]{inc\+X, }
\item[{const double $\ast$}]{Y, }
\item[{int}]{inc\+Y, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gae0a46d5ef37e8689c3ace89dac0d7d46_gae0a46d5ef37e8689c3ace89dac0d7d46}
C\+O\+R\+E\+\_\+dpltmg\+\_\+fiedler is a kernel used in fiedler matrix generation

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-999960}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/999960}

Fiedler matrix of size n-\/by-\/n is defined throug a random vector c of size n, such that each element is equal to abs(n(i)-\/n(j)).

Matrix A has a dominant positive eigenvalue and all the other eigenvalues are negative.

Explicit formulas for inv(\+A) and det(\+A) are given in \mbox{[}Todd, J., Basic Numerical Mathematics, Vol. 2\+: Numerical Algebra, Birkhauser, Basel, and Academic Press, New York, 1977, p. 159\mbox{]} and attributed to Fiedler. These indicate that inv(\+A) is tridiagonal except for nonzero (1,n) and (n,1) elements.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A to initialize. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A to initialize. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em X} & X is a vector of dimension at least\+: ( 1 + ( M -\/ 1 )$\ast$abs( inc\+X ) ) On entry, the vector used to initialize A.\\
\hline
\mbox{\tt in}  & {\em inc\+X} & On entry, inc\+X specifies the increment for the elements of X. inc\+X != 0.\\
\hline
\mbox{\tt in}  & {\em Y} & Y is a vector of dimension at least\+: ( 1 + ( N -\/ 1 )$\ast$abs( inc\+Y ) ) On entry, the vector used to initialize A.\\
\hline
\mbox{\tt in}  & {\em inc\+Y} & On entry, inc\+Y specifies the increment for the elements of Y. inc\+Y != 0.\\
\hline
\mbox{\tt out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized. On exit, each element of A is defined by\+: A(i,j) = abs( X(i) -\/ Y(j) )\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gade5dc2c549c2f807eb633058637786fb_gade5dc2c549c2f807eb633058637786fb}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dpltmg\+\_\+hankel@{C\+O\+R\+E\+\_\+dpltmg\+\_\+hankel}}
\index{C\+O\+R\+E\+\_\+dpltmg\+\_\+hankel@{C\+O\+R\+E\+\_\+dpltmg\+\_\+hankel}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dpltmg\+\_\+hankel}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dpltmg\+\_\+hankel (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{int}]{nb, }
\item[{const double $\ast$}]{V1, }
\item[{const double $\ast$}]{V2}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gade5dc2c549c2f807eb633058637786fb_gade5dc2c549c2f807eb633058637786fb}
C\+O\+R\+E\+\_\+dpltmg\+\_\+hankel is a kernel used in Hankel matrix generation

See \href{http://en.wikipedia.org/wiki/Hankel_matrix}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Hankel\+\_\+matrix}

Hankel matrix

In linear algebra, a Hankel matrix (or catalecticant matrix), named after Hermann Hankel, is a square matrix with constant skew-\/diagonals (positive sloping diagonals), e.\+g.\+:

\[ \begin{bmatrix} a & b & c & d & e \\ b & c & d & e & f \\ c & d & e & f & g \\ d & e & f & g & h \\ e & f & g & h & i \\ \end{bmatrix} \].

A(i,j) = A(i-\/1,j+1)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies the part of the matrix A to be initialized. = Plasma\+Upper\+Lower\+: All the matrix A = Plasma\+Upper\+: Upper triangular part = Plasma\+Lower\+: Lower triangular part\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the tile A to initialize. M $>$= 2.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A to initialize. N $>$= 0.\\
\hline
\mbox{\tt out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The size of the V1 and V2 vectors\\
\hline
\mbox{\tt in}  & {\em V1} & Workspace of size nb, that contains the first column of the tile\\
\hline
\mbox{\tt in}  & {\em V2} & Workspace of size nb), that contains the last column of the tile\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gae47778b25933f0e1b13d1bce66d9f0c9_gae47778b25933f0e1b13d1bce66d9f0c9}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd1@{C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd1}}
\index{C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd1@{C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd1}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd1}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd1 (
\begin{DoxyParamCaption}
\item[{int}]{g\+M, }
\item[{int}]{m0, }
\item[{int}]{M, }
\item[{double $\ast$}]{W, }
\item[{unsigned long long int}]{seed}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gae47778b25933f0e1b13d1bce66d9f0c9_gae47778b25933f0e1b13d1bce66d9f0c9}
C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd1 is the first kernel used in toeppd matrix generation.

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-1000272}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/1000272}

A toeppd matrix is an n-\/by-\/n symmetric, positive semi-\/definite (S\+P\+D) Toeplitz matrix composed of the sum of m rank 2 (or, for certain theta, rank 1) S\+P\+D Toeplitz matrices. Specifically,

T = w(1)$\ast$\+T(theta(1)) + ... + w(m)$\ast$\+T(theta(m))

where T(theta(k)) has (i,j) element cos(2$\ast$pi$\ast$theta(k)$\ast$(i-\/j)).

In this matrix generation\+: w = rand(m,1), and theta = rand(m,1).

This kernel generates a portion of size 2-\/by-\/m of the full W and theta vectors.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em g\+M} & The size of the full vectors W and theta. g\+M $>$= M+m0.\\
\hline
\mbox{\tt in}  & {\em m0} & Index of the first element of W, in the full vector. m0 $>$= 0\\
\hline
\mbox{\tt in}  & {\em M} & The number of elements to generate for w and theta vector. M $>$= 0.\\
\hline
\mbox{\tt out}  & {\em W} & An 2-\/by-\/\+M matrix. On exit, the first row contains the walue of w\mbox{[}m0;m0+\+M\mbox{]} The second row contains the vector 2$\ast$pi$\ast$theta\mbox{[}m0;m0+\+M\mbox{]}\\
\hline
\mbox{\tt in}  & {\em seed} & The seed used for random generation. Must be the same for all call to this routines generating the w and theta vectors. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga58e55cc51125622f0a4f8135fe1c9d81_ga58e55cc51125622f0a4f8135fe1c9d81}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd2@{C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd2}}
\index{C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd2@{C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd2}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd2}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd2 (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{int}]{m0, }
\item[{int}]{n0, }
\item[{const double $\ast$}]{W, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga58e55cc51125622f0a4f8135fe1c9d81_ga58e55cc51125622f0a4f8135fe1c9d81}
C\+O\+R\+E\+\_\+dpltmg\+\_\+toeppd2 is the first kernel used in toeppd matrix generation.

See \href{http://www.mathworks.fr/fr/help/matlab/ref/gallery.html#f84-1000272}{\tt http\+://www.\+mathworks.\+fr/fr/help/matlab/ref/gallery.\+html\#f84-\/1000272}

A toeppd matrix is an n-\/by-\/n symmetric, positive semi-\/definite (S\+P\+D) Toeplitz matrix composed of the sum of m rank 2 (or, for certain theta, rank 1) S\+P\+D Toeplitz matrices. Specifically,

T = w(1)$\ast$\+T(theta(1)) + ... + w(m)$\ast$\+T(theta(m))

where T(theta(k)) has (i,j) element cos(2$\ast$pi$\ast$theta(k)$\ast$(i-\/j)).

In this matrix generation\+: w = rand(m,1), and theta = rand(m,1).

This kernel adds to the tile A the local sum of\+: w(1)$\ast$\+T(theta(1)) + ... + w(\+K) $\ast$ T(theta(\+K))


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of matrices W() $\ast$ T(theta()) to apply.\\
\hline
\mbox{\tt in}  & {\em m0} & The index of the first row of tile A in the full matrix. m0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n0} & The index of the first column of tile A in the full matrix. n0 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em W} & The 2-\/by-\/\+K array that stores the values of W and 2$\ast$pi$\ast$\+Theta. W being stored on the first row, 2$\ast$pi$\ast$theta on the second.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be initialized with a partial sum of the Toeppliz matrices. On exit, the M-\/by-\/\+N tile update with the sum of K extra Toepplitz matrices\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the tile A. L\+D\+A $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga0971d5ea439913fdb900931d6c7a0ad1_ga0971d5ea439913fdb900931d6c7a0ad1}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dpotrf@{C\+O\+R\+E\+\_\+dpotrf}}
\index{C\+O\+R\+E\+\_\+dpotrf@{C\+O\+R\+E\+\_\+dpotrf}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dpotrf}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dpotrf (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga0971d5ea439913fdb900931d6c7a0ad1_ga0971d5ea439913fdb900931d6c7a0ad1}
C\+O\+R\+E\+\_\+dpotrf -\/ Computes the Cholesky factorization of a symmetric positive definite (or Hermitian positive definite in the complex case) matrix A. The factorization has the form

\[ A = \{_{L\times L^H, if uplo = PlasmaLower}^{U^H\times U, if uplo = PlasmaUpper} \]

where U is an upper triangular matrix and L is a lower triangular matrix.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the symmetric positive definite (or Hermitian) matrix A. If uplo = Plasma\+Upper, the leading N-\/by-\/\+N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If U\+P\+L\+O = \textquotesingle{}L\textquotesingle{}, the leading N-\/by-\/\+N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, if return value = 0, the factor U or L from the Cholesky factorization A = U$\ast$$\ast$\+T$\ast$\+U or A = L$\ast$\+L$\ast$$\ast$\+T.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt out}  & {\em info} & 
\begin{DoxyItemize}
\item 0 on successful exit
\item $<$0 if -\/i, the i-\/th argument had an illegal value
\item $>$0 if i, the leading minor of order i of A is not positive definite, so the factorization could not be completed, and the solution has not been computed. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga13d61f05b9ffab57ab8dc28a7d2f04ac_ga13d61f05b9ffab57ab8dc28a7d2f04ac}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dsbtype1cb@{C\+O\+R\+E\+\_\+dsbtype1cb}}
\index{C\+O\+R\+E\+\_\+dsbtype1cb@{C\+O\+R\+E\+\_\+dsbtype1cb}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dsbtype1cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dsbtype1cb (
\begin{DoxyParamCaption}
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{V, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga13d61f05b9ffab57ab8dc28a7d2f04ac_ga13d61f05b9ffab57ab8dc28a7d2f04ac}
C\+O\+R\+E\+\_\+dsbtype1cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel eliminate a column by an column-\/wise annihiliation, then it apply a left+right update on the hermitian triangle. Note that the column to be eliminated is located at st-\/1.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (2$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,2$\ast$\+N\+B+1)\\
\hline
\mbox{\tt out}  & {\em V} & double array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & double array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gabd46a4aa466ef8c4e71f4d05b952f652_gabd46a4aa466ef8c4e71f4d05b952f652}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dsbtype2cb@{C\+O\+R\+E\+\_\+dsbtype2cb}}
\index{C\+O\+R\+E\+\_\+dsbtype2cb@{C\+O\+R\+E\+\_\+dsbtype2cb}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dsbtype2cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dsbtype2cb (
\begin{DoxyParamCaption}
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{V, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gabd46a4aa466ef8c4e71f4d05b952f652_gabd46a4aa466ef8c4e71f4d05b952f652}
C\+O\+R\+E\+\_\+dsbtype2cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply the right update remaining from the type1 and this later will create a bulge so it eliminate the first column of the created bulge and do the corresponding Left update.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (2$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,2$\ast$\+N\+B+1)\\
\hline
\mbox{\tt in,out}  & {\em V} & double array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in,out}  & {\em T\+A\+U} & double array, dimension (N). The scalar factors of the Householder reflectors of the previous type 1 are used here to continue update then new one are generated to eliminate the bulge and stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga740babd14602b6a1bac2235bd34fff33_ga740babd14602b6a1bac2235bd34fff33}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dsbtype3cb@{C\+O\+R\+E\+\_\+dsbtype3cb}}
\index{C\+O\+R\+E\+\_\+dsbtype3cb@{C\+O\+R\+E\+\_\+dsbtype3cb}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dsbtype3cb}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dsbtype3cb (
\begin{DoxyParamCaption}
\item[{int}]{N, }
\item[{int}]{N\+B, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const double $\ast$}]{V, }
\item[{const double $\ast$}]{T\+A\+U, }
\item[{int}]{st, }
\item[{int}]{ed, }
\item[{int}]{sweep, }
\item[{int}]{Vblksiz, }
\item[{int}]{W\+A\+N\+T\+Z, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga740babd14602b6a1bac2235bd34fff33_ga740babd14602b6a1bac2235bd34fff33}
C\+O\+R\+E\+\_\+dsbtype3cb is a kernel that will operate on a region (triangle) of data bounded by st and ed. This kernel apply a left+right update on the hermitian triangle. Note that this kernel is very similar to type1 but does not do an elimination.

All detail are available on technical report or S\+C11 paper. Azzam Haidar, Hatem Ltaief, and Jack Dongarra. 2011. Parallel reduction to condensed forms for symmetric eigenvalue problems using aggregated fine-\/grained and memory-\/aware kernels. In Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (S\+C \textquotesingle{}11). A\+C\+M, New York, N\+Y, U\+S\+A, , Article 8 , 11 pages. \href{http://doi.acm.org/10.1145/2063384.2063394}{\tt http\+://doi.\+acm.\+org/10.\+1145/2063384.\+2063394}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & The order of the matrix A.\\
\hline
\mbox{\tt in}  & {\em N\+B} & The size of the band.\\
\hline
\mbox{\tt in,out}  & {\em A} & A pointer to the matrix A of size (2$\ast$\+N\+B+1)-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the matrix A. L\+D\+A $>$= max(1,2$\ast$\+N\+B+1)\\
\hline
\mbox{\tt in}  & {\em V} & double array, dimension N if eigenvalue only requested or (L\+D\+V$\ast$blkcnt$\ast$\+Vblksiz) if Eigenvectors requested The Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & double array, dimension (N). The scalar factors of the Householder reflectors are stored in this array.\\
\hline
\mbox{\tt in}  & {\em st} & A pointer to the start index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em ed} & A pointer to the end index where this kernel will operate.\\
\hline
\mbox{\tt in}  & {\em sweep} & The sweep number that is eliminated. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & constant which correspond to the blocking used when applying the Vs. it serve to calculate the pointer to the position where to store the Vs and Ts.\\
\hline
\mbox{\tt in}  & {\em W\+A\+N\+T\+Z} & constant which indicate if Eigenvalue are requested or both Eigenvalue/\+Eigenvectors.\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & Workspace of size nb.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value T\+Y\+P\+E 3-\/\+B\+A\+N\+D Lower-\/columnwise-\/\+Householder \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga470a57a47ccf26158cb24e925c850aca_ga470a57a47ccf26158cb24e925c850aca}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dsetvar@{C\+O\+R\+E\+\_\+dsetvar}}
\index{C\+O\+R\+E\+\_\+dsetvar@{C\+O\+R\+E\+\_\+dsetvar}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dsetvar}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dsetvar (
\begin{DoxyParamCaption}
\item[{const double $\ast$}]{alpha, }
\item[{double $\ast$}]{x}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga470a57a47ccf26158cb24e925c850aca_ga470a57a47ccf26158cb24e925c850aca}
C\+O\+R\+E\+\_\+dsetvar sets a single variable, x \+:= alpha.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em alpha} & Scalar to set x to, passed by pointer so it can depend on runtime value.\\
\hline
\mbox{\tt out}  & {\em x} & On exit, x = alpha. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gaa5faaea7077323e921ad2c92e12a15c1_gaa5faaea7077323e921ad2c92e12a15c1}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dshiftw@{C\+O\+R\+E\+\_\+dshiftw}}
\index{C\+O\+R\+E\+\_\+dshiftw@{C\+O\+R\+E\+\_\+dshiftw}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dshiftw}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dshiftw (
\begin{DoxyParamCaption}
\item[{int}]{s, }
\item[{int}]{cl, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{int}]{L, }
\item[{double $\ast$}]{A, }
\item[{double $\ast$}]{W}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaa5faaea7077323e921ad2c92e12a15c1_gaa5faaea7077323e921ad2c92e12a15c1}




C\+O\+R\+E\+\_\+dshiftw Shift a linear chain of block using a supplied workspace by following the cycle defined by\+: k\+\_\+(i+1) = (k\+\_\+i $\ast$ m) \% q;


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em s} & Start value in the cycle\\
\hline
\mbox{\tt in}  & {\em cl} & Cycle length if cl == 0, all the permutations from the cycle are done else the cycle is split onto several threads and the number of permutation to do has to be specified to not get overlap\\
\hline
\mbox{\tt in}  & {\em m} & Number of lines of tile A\\
\hline
\mbox{\tt in}  & {\em n} & Number of columns of tile A\\
\hline
\mbox{\tt in}  & {\em L} & Length of each block of data to move\\
\hline
\mbox{\tt in,out}  & {\em A} & Matrix of size m-\/by-\/n with each element of size L. On exit, A = A\textquotesingle{}, where A\textquotesingle{} contains the permutations\\
\hline
\mbox{\tt in}  & {\em W} & Array of size L. On entry, must contain\+: W(\+:) = A(s$\ast$\+L\+:s$\ast$\+L+\+L-\/1) \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga307f80b43bbc184b00aeac63931c28b2_ga307f80b43bbc184b00aeac63931c28b2}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dssssm@{C\+O\+R\+E\+\_\+dssssm}}
\index{C\+O\+R\+E\+\_\+dssssm@{C\+O\+R\+E\+\_\+dssssm}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dssssm}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dssssm (
\begin{DoxyParamCaption}
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const double $\ast$}]{L1, }
\item[{int}]{L\+D\+L1, }
\item[{const double $\ast$}]{L2, }
\item[{int}]{L\+D\+L2, }
\item[{const int $\ast$}]{I\+P\+I\+V}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga307f80b43bbc184b00aeac63931c28b2_ga307f80b43bbc184b00aeac63931c28b2}
C\+O\+R\+E\+\_\+dssssm applies the L\+U factorization update from a complex matrix formed by a lower triangular I\+B-\/by-\/\+K tile L1 on top of a M2-\/by-\/\+K tile L2 to a second complex matrix formed by a M1-\/by-\/\+N1 tile A1 on top of a M2-\/by-\/\+N2 tile A2 (N1 == N2).

This is the right-\/looking Level 2.\+5 B\+L\+A\+S version of the algorithm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of rows of the tile A2 and of the tile L2. M2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of columns of the tile A2. N2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of columns of the tiles L1 and L2. K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is updated by the application of L (L1 L2).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is updated by the application of L (L1 L2).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the array A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em L1} & The I\+B-\/by-\/\+K lower triangular tile as returned by C\+O\+R\+E\+\_\+dtstrf.\\
\hline
\mbox{\tt in}  & {\em L\+D\+L1} & The leading dimension of the array L1. L\+D\+L1 $>$= max(1,\+I\+B).\\
\hline
\mbox{\tt in}  & {\em L2} & The M2-\/by-\/\+K tile as returned by C\+O\+R\+E\+\_\+dtstrf.\\
\hline
\mbox{\tt in}  & {\em L\+D\+L2} & The leading dimension of the array L2. L\+D\+L2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em I\+P\+I\+V} & The pivot indices array of size K as returned by C\+O\+R\+E\+\_\+dtstrf.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gab985a11c7b456c6d198d57a7b2f16769_gab985a11c7b456c6d198d57a7b2f16769}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dstedc@{C\+O\+R\+E\+\_\+dstedc}}
\index{C\+O\+R\+E\+\_\+dstedc@{C\+O\+R\+E\+\_\+dstedc}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dstedc}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dstedc (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{compz, }
\item[{int}]{n, }
\item[{double $\ast$}]{D, }
\item[{double $\ast$}]{E, }
\item[{double $\ast$}]{Z, }
\item[{int}]{L\+D\+Z, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+W\+O\+R\+K, }
\item[{int $\ast$}]{I\+W\+O\+R\+K, }
\item[{int}]{L\+I\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gab985a11c7b456c6d198d57a7b2f16769_gab985a11c7b456c6d198d57a7b2f16769}
C\+O\+R\+E\+\_\+dstedc -\/ solves the symmetric tridiagonal eigensystem using Divide \& Conquer


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em compz} & = Plasma\+No\+Vec\+: computes eigenvalues only. = Plasma\+Vec\+: computes eigenpairs of the original symmetric matrix. On entry, Z must contain the orthogonal matrix used to reduce the original matrix to tridiagonal form. = Plasma\+I\+Vec\+: computes eigenpairs of the tridiagonal matrix. Z is initialized to the Identity Matrix.\\
\hline
\mbox{\tt in}  & {\em n} & n specifies the order of the matrix. N $>$= 0\\
\hline
\mbox{\tt in,out}  & {\em D} & On entry, D contains the diagonal elements of the tridiagonal matrix. On exit, D contains the eigenvalues sorted into increasing order.\\
\hline
\mbox{\tt in}  & {\em E} & On entry, E contains the extra-\/diagonal elements of the tridiagonal matrix. On exit, E is destroyed.\\
\hline
\mbox{\tt in,out}  & {\em Z} & On entry, Z has to be set to the Identity matrix. On exit, Z contains the eigenvectors.\\
\hline
\mbox{\tt in}  & {\em L\+D\+Z} & L\+D\+Z specifies the leading direction of Z\\
\hline
\mbox{\tt in}  & {\em W\+O\+R\+K} & plasma\+\_\+complex64\+\_\+t workspace\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & Size of plasma\+\_\+complex64\+\_\+t workspace\\
\hline
\mbox{\tt in}  & {\em R\+W\+O\+R\+K} & workspace\\
\hline
\mbox{\tt in}  & {\em L\+R\+W\+O\+R\+K} & Size of double workspace\\
\hline
\mbox{\tt in}  & {\em I\+W\+O\+R\+K} & Integer workspace\\
\hline
\mbox{\tt in}  & {\em L\+I\+W\+O\+R\+K} & Size of integer workspace\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gafc01ee65617fee823278fb6ad75dc6ea_gafc01ee65617fee823278fb6ad75dc6ea}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dsteqr@{C\+O\+R\+E\+\_\+dsteqr}}
\index{C\+O\+R\+E\+\_\+dsteqr@{C\+O\+R\+E\+\_\+dsteqr}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dsteqr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dsteqr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{compz, }
\item[{int}]{n, }
\item[{double $\ast$}]{D, }
\item[{double $\ast$}]{E, }
\item[{double $\ast$}]{Z, }
\item[{int}]{L\+D\+Z, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gafc01ee65617fee823278fb6ad75dc6ea_gafc01ee65617fee823278fb6ad75dc6ea}
C\+O\+R\+E\+\_\+dsteqr -\/ solves the symmetric tridiagonal eigensystem using Q\+R


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em compz} & = Plasma\+No\+Vec\+: computes eigenvalues only. = Plasma\+Vec\+: computes eigenpairs of the original symmetric matrix. On entry, Z must contain the orthogonal matrix used to reduce the original matrix to tridiagonal form. = Plasma\+I\+Vec\+: computes eigenpairs of the tridiagonal matrix. Z is initialized to the Identity Matrix.\\
\hline
\mbox{\tt in}  & {\em n} & n specifies the order of the matrix. N $>$= 0\\
\hline
\mbox{\tt in,out}  & {\em D} & On entry, D contains the diagonal elements of the tridiagonal matrix. On exit, D contains the eigenvalues sorted into increasing order.\\
\hline
\mbox{\tt in}  & {\em E} & On entry, E contains the extra-\/diagonal elements of the tridiagonal matrix. On exit, E is destroyed.\\
\hline
\mbox{\tt in,out}  & {\em Z} & On entry, Z has to be set to the Identity matrix. On exit, Z contains the eigenvectors.\\
\hline
\mbox{\tt in}  & {\em L\+D\+Z} & L\+D\+Z specifies the leading direction of Z\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & Workspace.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga2a3bd8a49ed2aa43c45e142531c0b18f_ga2a3bd8a49ed2aa43c45e142531c0b18f}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dswap@{C\+O\+R\+E\+\_\+dswap}}
\index{C\+O\+R\+E\+\_\+dswap@{C\+O\+R\+E\+\_\+dswap}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dswap}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dswap (
\begin{DoxyParamCaption}
\item[{int}]{m, }
\item[{int}]{n, }
\item[{double $\ast$}]{Q, }
\item[{int}]{ldq, }
\item[{const double $\ast$}]{work, }
\item[{const int $\ast$}]{perm, }
\item[{int}]{start, }
\item[{int}]{end}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga2a3bd8a49ed2aa43c45e142531c0b18f_ga2a3bd8a49ed2aa43c45e142531c0b18f}
C\+O\+R\+E\+\_\+dswap -\/ Extract the eigenvectors in the range \mbox{[}start,end-\/1\mbox{]} from work and copy them in order into the Q matrix thanks to the given permutation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & m specifies the number of entries in each eigenvector, i.\+e. the number of rows of the matrices Q and Work.\\
\hline
\mbox{\tt in}  & {\em n} & n specifies the number of eigenvectors to copy from work to Q, i.\+e. the number of columns of the matrices W and work.\\
\hline
\mbox{\tt out}  & {\em Q} & On entry, matrix of size L\+D\+Q -\/by-\/ n. On exit, Q will contain the n sorted eigenvectors.\\
\hline
\mbox{\tt in}  & {\em ldq} & ldq specifies the leading dimension of Q. ldq $>$= max(1,m)\\
\hline
\mbox{\tt in}  & {\em work} & On entry work contains the non-\/sorted eigenvectors and is of dimension m-\/by-\/n.\\
\hline
\mbox{\tt in}  & {\em perm} & The permutation array used to copy work into Q. On entry, the i-\/th eigenvector is stored in the column perm\mbox{[}i\mbox{]} of work, and is copied to the i-\/th column of Q.\\
\hline
\mbox{\tt in}  & {\em start} & start specifies the first column index to be considered by this kernel.\\
\hline
\mbox{\tt in}  & {\em end} & end specifies the last column index to be considered by this kernel \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga3983570062ad523e1ad59613e1fdc9eb_ga3983570062ad523e1ad59613e1fdc9eb}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dswpab@{C\+O\+R\+E\+\_\+dswpab}}
\index{C\+O\+R\+E\+\_\+dswpab@{C\+O\+R\+E\+\_\+dswpab}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dswpab}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dswpab (
\begin{DoxyParamCaption}
\item[{int}]{i, }
\item[{int}]{n1, }
\item[{int}]{n2, }
\item[{double $\ast$}]{A, }
\item[{double $\ast$}]{work}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga3983570062ad523e1ad59613e1fdc9eb_ga3983570062ad523e1ad59613e1fdc9eb}




C\+O\+R\+E\+\_\+dswpab swaps two adjacent contiguous blocks of data. \begin{DoxyVerb}n1                     n2
\end{DoxyVerb}
 +-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+

become \+: n2 n1 +-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---+


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em A} & Array of size i+n1+n2. On entry, a block of size n1 followed by a block of size n2. On exit, the block of size n1 follows the block of size n2.\\
\hline
\mbox{\tt in}  & {\em i} & First block starts at A\mbox{[}i\mbox{]}.\\
\hline
\mbox{\tt in}  & {\em n1} & Size of the first block to swap.\\
\hline
\mbox{\tt in}  & {\em n2} & Size of the second block to swap.\\
\hline
\mbox{\tt out}  & {\em work} & Workspace array of size min(n1, n2). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gaead98c5d81d7747aef84af1883b4bac1_gaead98c5d81d7747aef84af1883b4bac1}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dswptr\+\_\+ontile@{C\+O\+R\+E\+\_\+dswptr\+\_\+ontile}}
\index{C\+O\+R\+E\+\_\+dswptr\+\_\+ontile@{C\+O\+R\+E\+\_\+dswptr\+\_\+ontile}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dswptr\+\_\+ontile}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dswptr\+\_\+ontile (
\begin{DoxyParamCaption}
\item[{{\bf P\+L\+A\+S\+M\+A\+\_\+desc}}]{desc\+A, }
\item[{int}]{i1, }
\item[{int}]{i2, }
\item[{const int $\ast$}]{ipiv, }
\item[{int}]{inc, }
\item[{const double $\ast$}]{Akk, }
\item[{int}]{ldak}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaead98c5d81d7747aef84af1883b4bac1_gaead98c5d81d7747aef84af1883b4bac1}
C\+O\+R\+E\+\_\+dswptr\+\_\+ontile apply the dlaswp function on a matrix stored in tile layout, followed by a dtrsm on the first tile of the panel.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em desc\+A} & The descriptor of the matrix A to permute.\\
\hline
\mbox{\tt in}  & {\em i1} & The first element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em i2} & The last element of I\+P\+I\+V for which a row interchange will be done.\\
\hline
\mbox{\tt in}  & {\em ipiv} & The pivot indices; Only the element in position i1 to i2 are accessed. The pivot are offset by A.\+i.\\
\hline
\mbox{\tt in}  & {\em inc} & The increment between successive values of I\+P\+I\+V. If I\+P\+I\+V is negative, the pivots are applied in reverse order.\\
\hline
\mbox{\tt in}  & {\em Akk} & The triangular matrix Akk. The leading desc\+A.\+nb-\/by-\/desc\+A.\+nb lower triangular part of the array Akk contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. The diagonal elements of A are also not referenced and are assumed to be 1.\\
\hline
\mbox{\tt in}  & {\em ldak} & The leading dimension of the array Akk. ldak $>$= max(1,desc\+A.\+nb).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga6e726df73c21c70ca2a790d2f54d6852_ga6e726df73c21c70ca2a790d2f54d6852}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dsygst@{C\+O\+R\+E\+\_\+dsygst}}
\index{C\+O\+R\+E\+\_\+dsygst@{C\+O\+R\+E\+\_\+dsygst}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dsygst}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dsygst (
\begin{DoxyParamCaption}
\item[{int}]{itype, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{B, }
\item[{int}]{L\+D\+B, }
\item[{int $\ast$}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga6e726df73c21c70ca2a790d2f54d6852_ga6e726df73c21c70ca2a790d2f54d6852}
C\+O\+R\+E\+\_\+dsygst -\/ reduces a complex Hermitian-\/definite generalized eigenproblem to standard form. If Plasma\+Itype == 1, the problem is A$\ast$x = lambda$\ast$\+B$\ast$x, and A is overwritten by inv(\+U$\ast$$\ast$\+T)$\ast$\+A$\ast$inv(U) or inv(\+L)$\ast$\+A$\ast$inv(L$\ast$$\ast$\+T) If Plasma\+Itype == 2 or 3, the problem is A$\ast$\+B$\ast$x = lambda$\ast$x or B$\ast$\+A$\ast$x = lambda$\ast$x, and A is overwritten by U$\ast$\+A$\ast$\+U$\ast$$\ast$\+T or L$\ast$$\ast$\+T$\ast$\+A$\ast$\+L. B must have been previously factorized as U$\ast$$\ast$\+T$\ast$\+U or L$\ast$\+L$\ast$$\ast$\+T by C\+O\+R\+E\+\_\+dpotrf.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em itype} & Intended usage\+: = 1\+: A$\ast$x=(lambda)$\ast$\+B$\ast$x = 2\+: A$\ast$\+Bx=(lambda)$\ast$x = 3\+: B$\ast$\+A$\ast$x=(lambda)$\ast$x\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular\+: = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrices A and B. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the symmetric (or Hermitian) matrix A. If uplo = Plasma\+Upper, the leading N-\/by-\/\+N upper triangular part of A contains the upper triangular part of the matrix A, and the strictly lower triangular part of A is not referenced. If uplo = Plasma\+Lower, the leading N-\/by-\/\+N lower triangular part of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not referenced. On exit, if return value == 0, the transformed matrix, stored in the same format as A.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt in,out}  & {\em B} & On entry, the triangular factor from the Cholesky factorization of B, as returned by P\+L\+A\+S\+M\+A\+\_\+\+D\+P\+O\+T\+R\+F.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+N).\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & 
\begin{DoxyItemize}
\item 0 on successful exit
\item $<$0 if -\/i, the i-\/th argument had an illegal value 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga8da8500bfcaab1c2d482e16cd3774587_ga8da8500bfcaab1c2d482e16cd3774587}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dsymm@{C\+O\+R\+E\+\_\+dsymm}}
\index{C\+O\+R\+E\+\_\+dsymm@{C\+O\+R\+E\+\_\+dsymm}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dsymm}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dsymm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double}]{alpha, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const double $\ast$}]{B, }
\item[{int}]{L\+D\+B, }
\item[{double}]{beta, }
\item[{double $\ast$}]{C, }
\item[{int}]{L\+D\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga8da8500bfcaab1c2d482e16cd3774587_ga8da8500bfcaab1c2d482e16cd3774587}
C\+O\+R\+E\+\_\+dsymm -\/ Performs one of the matrix-\/matrix operations

\[ C = \alpha \times A \times B + \beta \times C \]

or

\[ C = \alpha \times B \times A + \beta \times C \]

where alpha and beta are scalars, A is an symmetric matrix and B and C are m by n matrices.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & Specifies whether the symmetric matrix A appears on the left or right in the operation as follows\+: = Plasma\+Left\+: \[ C = \alpha \times A \times B + \beta \times C \] = Plasma\+Right\+: \[ C = \alpha \times B \times A + \beta \times C \]\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the upper or lower triangular part of the symmetric matrix A is to be referenced as follows\+: = Plasma\+Lower\+: Only the lower triangular part of the symmetric matrix A is to be referenced. = Plasma\+Upper\+: Only the upper triangular part of the symmetric matrix A is to be referenced.\\
\hline
\mbox{\tt in}  & {\em M} & Specifies the number of rows of the matrix C. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & Specifies the number of columns of the matrix C. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & Specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is a L\+D\+A-\/by-\/ka matrix, where ka is M when side = Plasma\+Left, and is N otherwise. Only the uplo triangular part is referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,ka).\\
\hline
\mbox{\tt in}  & {\em B} & B is a L\+D\+B-\/by-\/\+N matrix, where the leading M-\/by-\/\+N part of the array B must contain the matrix B.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+M).\\
\hline
\mbox{\tt in}  & {\em beta} & Specifies the scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is a L\+D\+C-\/by-\/\+N matrix. On exit, the array is overwritten by the M by N updated matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga55ae098bde1db27aa5e48217fde7161c_ga55ae098bde1db27aa5e48217fde7161c}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dsyr2k@{C\+O\+R\+E\+\_\+dsyr2k}}
\index{C\+O\+R\+E\+\_\+dsyr2k@{C\+O\+R\+E\+\_\+dsyr2k}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dsyr2k}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dsyr2k (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{double}]{alpha, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{const double $\ast$}]{B, }
\item[{int}]{L\+D\+B, }
\item[{double}]{beta, }
\item[{double $\ast$}]{C, }
\item[{int}]{L\+D\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga55ae098bde1db27aa5e48217fde7161c_ga55ae098bde1db27aa5e48217fde7161c}
C\+O\+R\+E\+\_\+dsyr2k -\/ Performs one of the symmetric rank 2k operations

\[ C = \alpha [ op( A ) \times g( op( B )' )] + \alpha [ op( B ) \times g( op( A )' )] + \beta C \], or \[ C = \alpha [ g( op( A )' ) \times op( B ) ] + \alpha [ g( op( B )' ) \times op( A ) ] + \beta C \],

where op( X ) is one of

op( X ) = X or op( X ) = g( X\textquotesingle{} )

where alpha and beta are real scalars, C is an n-\/by-\/n symmetric matrix and A and B are an n-\/by-\/k matrices the first case and k-\/by-\/n matrices in the second case.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of C is stored; = Plasma\+Lower\+: Lower triangle of C is stored.\\
\hline
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is transposed or ugate transposed\+: = Plasma\+No\+Trans\+: \[ C = \alpha [ op( A ) \times g( op( B )' )] + \alpha [ op( B ) \times g( op( A )' )] + \beta C \] = Plasma\+Trans\+: \[ C = \alpha [ g( op( A )' ) \times op( B ) ] + \alpha [ g( op( B )' ) \times op( A ) ] + \beta C \]\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the order of the matrix C. N must be at least zero.\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of columns of the A and B matrices with trans = Plasma\+No\+Trans. K specifies the number of rows of the A and B matrices with trans = Plasma\+Trans.\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is a L\+D\+A-\/by-\/ka matrix, where ka is K when trans = Plasma\+No\+Trans, and is N otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A must be at least max( 1, N ), otherwise L\+D\+A must be at least max( 1, K ).\\
\hline
\mbox{\tt in}  & {\em B} & B is a L\+D\+B-\/by-\/kb matrix, where kb is K when trans = Plasma\+No\+Trans, and is N otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B must be at least max( 1, N ), otherwise L\+D\+B must be at least max( 1, K ).\\
\hline
\mbox{\tt in}  & {\em beta} & beta specifies the scalar beta.\\
\hline
\mbox{\tt in,out}  & {\em C} & C is a L\+D\+C-\/by-\/\+N matrix. On exit, the array uplo part of the matrix is overwritten by the uplo part of the updated matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max( 1, N ). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga48b7ed94f1b65f6a0f070fcd1375348a_ga48b7ed94f1b65f6a0f070fcd1375348a}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dsyrfb@{C\+O\+R\+E\+\_\+dsyrfb}}
\index{C\+O\+R\+E\+\_\+dsyrfb@{C\+O\+R\+E\+\_\+dsyrfb}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dsyrfb}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dsyrfb (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{int}]{n, }
\item[{int}]{k, }
\item[{int}]{ib, }
\item[{int}]{nb, }
\item[{const double $\ast$}]{A, }
\item[{int}]{lda, }
\item[{const double $\ast$}]{T, }
\item[{int}]{ldt, }
\item[{double $\ast$}]{C, }
\item[{int}]{ldc, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{ldwork}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga48b7ed94f1b65f6a0f070fcd1375348a_ga48b7ed94f1b65f6a0f070fcd1375348a}
C\+O\+R\+E\+\_\+dsyrfb overwrites the symmetric complex N-\/by-\/\+N tile C with

Q$\ast$$\ast$\+T$\ast$\+C$\ast$\+Q

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(1) H(2) . . . H(k)

as returned by C\+O\+R\+E\+\_\+dgeqrt. Only Plasma\+Lower supported!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & \begin{DoxyItemize}
\item Plasma\+Lower \+: the upper part of the symmetric matrix C is not referenced. \item Plasma\+Upper \+: the lower part of the symmetric matrix C is not referenced (not supported).\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em n} & The number of rows/columns of the tile C. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & The number of elementary reflectors whose product defines the matrix Q. K $>$= 0.\\
\hline
\mbox{\tt in}  & {\em ib} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The blocking size. N\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & The i-\/th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+dgeqrt in the first k columns of its array argument A.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+K triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em ldt} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt in,out}  & {\em C} & On entry, the symmetric N-\/by-\/\+N tile C. On exit, C is overwritten by Q$\ast$$\ast$\+T$\ast$\+C$\ast$\+Q.\\
\hline
\mbox{\tt in}  & {\em ldc} & The leading dimension of the array C. L\+D\+C $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & On exit, if I\+N\+F\+O = 0, W\+O\+R\+K(1) returns the optimal L\+D\+W\+O\+R\+K.\\
\hline
\mbox{\tt in}  & {\em ldwork} & The dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+N);\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gae955397a1509aade89dd6c33cbd46d88_gae955397a1509aade89dd6c33cbd46d88}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dsyrk@{C\+O\+R\+E\+\_\+dsyrk}}
\index{C\+O\+R\+E\+\_\+dsyrk@{C\+O\+R\+E\+\_\+dsyrk}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dsyrk}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dsyrk (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{N, }
\item[{int}]{K, }
\item[{double}]{alpha, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double}]{beta, }
\item[{double $\ast$}]{C, }
\item[{int}]{L\+D\+C}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gae955397a1509aade89dd6c33cbd46d88_gae955397a1509aade89dd6c33cbd46d88}
C\+O\+R\+E\+\_\+dsyrk -\/ Performs one of the hermitian rank k operations

\[ C = \alpha [ op( A ) \times g( op( A )' )] + \beta C \],

where op( X ) is one of

op( X ) = X or op( X ) = g( X\textquotesingle{} )

where alpha and beta are real scalars, C is an n-\/by-\/n hermitian matrix and A is an n-\/by-\/k matrix in the first case and a k-\/by-\/n matrix in the second case.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of C is stored; = Plasma\+Lower\+: Lower triangle of C is stored.\\
\hline
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is transposed or ugate transposed\+: = Plasma\+No\+Trans\+: A is not transposed; = Plasma\+Trans \+: A is transposed.\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the order of the matrix C. N must be at least zero.\\
\hline
\mbox{\tt in}  & {\em K} & K specifies the number of columns of the matrix op( A ).\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is a L\+D\+A-\/by-\/ka matrix, where ka is K when trans = Plasma\+No\+Trans, and is N otherwise.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A must be at least max( 1, N ) if trans == Plasma\+No\+Trans, otherwise L\+D\+A must be at least max( 1, K ).\\
\hline
\mbox{\tt in}  & {\em beta} & beta specifies the scalar beta\\
\hline
\mbox{\tt in,out}  & {\em C} & C is a L\+D\+C-\/by-\/\+N matrix. On exit, the array uplo part of the matrix is overwritten by the uplo part of the updated matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & The leading dimension of the array C. L\+D\+C $>$= max( 1, N ). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga36e584eda1f30774893edc6f205705ee_ga36e584eda1f30774893edc6f205705ee}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtradd@{C\+O\+R\+E\+\_\+dtradd}}
\index{C\+O\+R\+E\+\_\+dtradd@{C\+O\+R\+E\+\_\+dtradd}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtradd}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dtradd (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double}]{alpha, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double}]{beta, }
\item[{double $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga36e584eda1f30774893edc6f205705ee_ga36e584eda1f30774893edc6f205705ee}
C\+O\+R\+E\+\_\+dtradd adds two matrices together as in P\+B\+L\+A\+S pdtradd. \begin{DoxyVerb} B <- alpha * op(A)  + beta * B,
\end{DoxyVerb}


where op(\+X) = X, X\textquotesingle{}, or (X\textquotesingle{})


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & Specifies the shape of A and B matrices\+: = Plasma\+Upper\+Lower\+: A and B are general matrices. = Plasma\+Upper\+: op(\+A) and B are upper trapezoidal matrices. = Plasma\+Lower\+: op(\+A) and B are lower trapezoidal matrices.\\
\hline
\mbox{\tt in}  & {\em trans} & Specifies whether the matrix A is non-\/transposed, transposed, or ugate transposed = Plasma\+No\+Trans\+: op(\+A) = A = Plasma\+Trans\+: op(\+A) = A\textquotesingle{} = Plasma\+Trans\+: op(\+A) = (A\textquotesingle{})\\
\hline
\mbox{\tt in}  & {\em M} & Number of rows of the matrices A and B.\\
\hline
\mbox{\tt in}  & {\em N} & Number of columns of the matrices A and B.\\
\hline
\mbox{\tt in}  & {\em alpha} & Scalar factor of A.\\
\hline
\mbox{\tt in}  & {\em A} & Matrix of size L\+D\+A-\/by-\/\+N.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & Leading dimension of the array A. L\+D\+A $>$= max(1,\+M)\\
\hline
\mbox{\tt in}  & {\em beta} & Scalar factor of B.\\
\hline
\mbox{\tt in,out}  & {\em B} & Matrix of size L\+D\+B-\/by-\/\+N. On exit, B = alpha $\ast$ op(\+A) + beta $\ast$ B\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & Leading dimension of the array B. L\+D\+B $>$= max(1,\+M)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
Plasma\+Lower

Plasma\+Upper\hypertarget{group__CORE__double_gaeda54b92bd167ce4b3b2e9b84e588fd7_gaeda54b92bd167ce4b3b2e9b84e588fd7}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtrasm@{C\+O\+R\+E\+\_\+dtrasm}}
\index{C\+O\+R\+E\+\_\+dtrasm@{C\+O\+R\+E\+\_\+dtrasm}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtrasm}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dtrasm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{storev, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{diag, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{const double $\ast$}]{A, }
\item[{int}]{lda, }
\item[{double $\ast$}]{work}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaeda54b92bd167ce4b3b2e9b84e588fd7_gaeda54b92bd167ce4b3b2e9b84e588fd7}
C\+O\+R\+E\+\_\+dtrasm -\/ Computes the sums of the absolute values of elements in a same row or column in a triangular matrix. This function is an auxiliary function to triangular matrix norm computations.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em storev} & Specifies whether the sums are made per column or row. = Plasma\+Columnwise\+: Computes the sum on each column = Plasma\+Rowwise\+: Computes the sum on each row\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular = Plasma\+Upper\+: Upper triangle of A is referenced; = Plasma\+Lower\+: Lower triangle of A is referenced.\\
\hline
\mbox{\tt in}  & {\em diag} & Specifies whether or not A is unit triangular\+: = Plasma\+Non\+Unit\+: A is non unit; = Plasma\+Unit\+: A us unit.\\
\hline
\mbox{\tt in}  & {\em M} & M specifies the number of rows of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & N specifies the number of columns of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & A is a M-\/by-\/\+N matrix.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. lda $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em work} & Array of dimension M if storev = Plasma\+Rowwise; N otherwise. On exit, contains the sums of the absolute values per column or row added to the input values. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga5b86142ed209d6ff1ae914d3d2198fe4_ga5b86142ed209d6ff1ae914d3d2198fe4}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtrdalg1@{C\+O\+R\+E\+\_\+dtrdalg1}}
\index{C\+O\+R\+E\+\_\+dtrdalg1@{C\+O\+R\+E\+\_\+dtrdalg1}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtrdalg1}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dtrdalg1 (
\begin{DoxyParamCaption}
\item[{int}]{n, }
\item[{int}]{nb, }
\item[{double $\ast$}]{A, }
\item[{int}]{lda, }
\item[{double $\ast$}]{V, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{int}]{Vblksiz, }
\item[{int}]{wantz, }
\item[{int}]{i, }
\item[{int}]{sweepid, }
\item[{int}]{m, }
\item[{int}]{grsiz, }
\item[{double $\ast$}]{work}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga5b86142ed209d6ff1ae914d3d2198fe4_ga5b86142ed209d6ff1ae914d3d2198fe4}
C\+O\+R\+E\+\_\+dtrdalg1 is a part of the tridiagonal reduction algorithm (bulgechasing) It correspond to a local driver of the kernels that should be executed on a single core.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & The order of the matrix A. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The size of the Bandwidth of the matrix A, which correspond to the tile size. nb $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & double array, dimension (lda,n) On entry, the (nb+1)-\/by-\/n band lower hermetian matrix to be reduced to tridiagonal. On exit, the diagonal and first subdiagonal of A are over-\/ written by the corresponding elements of the tridiagonal.\\
\hline
\mbox{\tt in}  & {\em lda} & (input) I\+N\+T\+E\+G\+E\+R The leading dimension of the array A. L\+D\+A $>$= max(1,nb+1).\\
\hline
\mbox{\tt out}  & {\em V} & double array, dimension (n) if wantz=0 or ldv$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar elementary reflectors are written in this array.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & double array, dimension (n) if wantz=0 or Vblksiz$\ast$\+Vblksiz$\ast$blkcnt if wantz$>$0. The scalar factors of the elementary reflectors are written in this array.\\
\hline
\mbox{\tt in}  & {\em Vblksiz} & Local parameter to Plasma. It correspond to the local bloccking of the apply\+Q2 used to apply the orthogonal matrix Q2.\\
\hline
\mbox{\tt in}  & {\em wantz} & integer tobe 0 or 1. if wantz=0 the V and T\+A\+U are not stored on only they are kept for next step then overwritten.\\
\hline
\mbox{\tt in}  & {\em i} & Integer that refer to the current sweep. (outer loop).\\
\hline
\mbox{\tt in}  & {\em sweepid} & Integer that refer to the sweep to chase.(inner loop).\\
\hline
\mbox{\tt in}  & {\em m} & Integer that refer to a sweep step, to ensure order dependencies.\\
\hline
\mbox{\tt in}  & {\em grsiz} & Integer that refer to the size of a group. group mean the number of kernel that should be executed sequentially on the same core. group size is a trade-\/off between locality (cache reuse) and parallelism. a small group size increase parallelism while a large group size increase cache reuse.\\
\hline
\mbox{\tt in}  & {\em work} & Workspace of size nb. Used by the core\+\_\+dsbtype\mbox{[}123\mbox{]}cb. \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gaac031425cb643fc8dd2ca59ae14aa299_gaac031425cb643fc8dd2ca59ae14aa299}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtrmm@{C\+O\+R\+E\+\_\+dtrmm}}
\index{C\+O\+R\+E\+\_\+dtrmm@{C\+O\+R\+E\+\_\+dtrmm}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtrmm}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dtrmm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{diag, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double}]{alpha, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaac031425cb643fc8dd2ca59ae14aa299_gaac031425cb643fc8dd2ca59ae14aa299}
C\+O\+R\+E\+\_\+dtrmm -\/ Computes B = alpha$\ast$op( A )$\ast$\+B or B = alpha$\ast$\+B$\ast$op( A ).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & Specifies whether A appears on the left or on the right of X\+: = Plasma\+Left\+: B = alpha$\ast$op( A )$\ast$\+B. = Plasma\+Right\+: B = alpha$\ast$\+B$\ast$op( A ).\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular\+: = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em trans\+A} & Specifies whether the matrix A is transposed, not transposed or ugate transposed\+: = Plasma\+No\+Trans\+: A is transposed; = Plasma\+Trans\+: A is not transposed; = Plasma\+Trans\+: A is ugate transposed.\\
\hline
\mbox{\tt in}  & {\em diag} & Specifies whether or not A is unit triangular\+: = Plasma\+Non\+Unit\+: A is non unit; = Plasma\+Unit\+: A us unit.\\
\hline
\mbox{\tt in}  & {\em M} & The number of rows of the matrix B. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns pf the matrix B. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & A is an array of dimansion L\+D\+A-\/by-\/k, where k = M if side = Plasma\+Left and k =N when side = Plasma\+Right. The triangular matrix A. If uplo = Plasma\+Upper, the leading k-\/by-\/k upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If uplo = Plasma\+Lower, the leading k-\/by-\/k lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If diag = Plasma\+Unit, the diagonal elements of A are also not referenced and are assumed to be 1.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,k). Where k = M if side = Plasma\+Left and k =N when side = Plasma\+Right.\\
\hline
\mbox{\tt in,out}  & {\em B} & On entry, the L\+D\+B-\/by-\/\+N matrix B. On exit, if return value = 0, the M-\/by-\/\+N matrix is overwritten by the transformed matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga01d4724a8dc091661b4fc3049ec04cdd_ga01d4724a8dc091661b4fc3049ec04cdd}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtrsm@{C\+O\+R\+E\+\_\+dtrsm}}
\index{C\+O\+R\+E\+\_\+dtrsm@{C\+O\+R\+E\+\_\+dtrsm}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtrsm}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dtrsm (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans\+A, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{diag, }
\item[{int}]{M, }
\item[{int}]{N, }
\item[{double}]{alpha, }
\item[{const double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{B, }
\item[{int}]{L\+D\+B}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga01d4724a8dc091661b4fc3049ec04cdd_ga01d4724a8dc091661b4fc3049ec04cdd}
C\+O\+R\+E\+\_\+dtrsm -\/ Computes triangular solve A$\ast$\+X = B or X$\ast$\+A = B.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & Specifies whether A appears on the left or on the right of X\+: = Plasma\+Left\+: A$\ast$\+X = B = Plasma\+Right\+: X$\ast$\+A = B\\
\hline
\mbox{\tt in}  & {\em uplo} & Specifies whether the matrix A is upper triangular or lower triangular\+: = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em trans\+A} & Specifies whether the matrix A is transposed, not transposed or ugate transposed\+: = Plasma\+No\+Trans\+: A is transposed; = Plasma\+Trans\+: A is not transposed; = Plasma\+Trans\+: A is ugate transposed.\\
\hline
\mbox{\tt in}  & {\em diag} & Specifies whether or not A is unit triangular\+: = Plasma\+Non\+Unit\+: A is non unit; = Plasma\+Unit\+: A us unit.\\
\hline
\mbox{\tt in}  & {\em M} & The order of the matrix A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of right hand sides, i.\+e., the number of columns of the matrix B. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em alpha} & alpha specifies the scalar alpha.\\
\hline
\mbox{\tt in}  & {\em A} & The triangular matrix A. If uplo = Plasma\+Upper, the leading M-\/by-\/\+M upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If uplo = Plasma\+Lower, the leading M-\/by-\/\+M lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If diag = Plasma\+Unit, the diagonal elements of A are also not referenced and are assumed to be 1.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em B} & On entry, the M-\/by-\/\+N right hand side matrix B. On exit, if return value = 0, the M-\/by-\/\+N solution matrix X.\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & The leading dimension of the array B. L\+D\+B $>$= max(1,\+M). \\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_gae38b32f77aa0a15b60c7a4130ca39615_gae38b32f77aa0a15b60c7a4130ca39615}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtrtri@{C\+O\+R\+E\+\_\+dtrtri}}
\index{C\+O\+R\+E\+\_\+dtrtri@{C\+O\+R\+E\+\_\+dtrtri}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtrtri}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+dtrtri (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{uplo, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{diag, }
\item[{int}]{N, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{int $\ast$}]{info}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gae38b32f77aa0a15b60c7a4130ca39615_gae38b32f77aa0a15b60c7a4130ca39615}
C\+O\+R\+E\+\_\+dtrtri -\/ Computes the inverse of a complex upper or lower triangular matrix A.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em uplo} & = Plasma\+Upper\+: Upper triangle of A is stored; = Plasma\+Lower\+: Lower triangle of A is stored.\\
\hline
\mbox{\tt in}  & {\em diag} & = Plasma\+Non\+Unit\+: A is non-\/unit triangular; = Plasma\+Unit\+: A is unit triangular.\\
\hline
\mbox{\tt in}  & {\em N} & The order of the matrix A. N $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the triangular matrix A. If U\+P\+L\+O = \textquotesingle{}U\textquotesingle{}, the leading N-\/by-\/\+N upper triangular part of the array A contains the upper triangular matrix, and the strictly lower triangular part of A is not referenced. If U\+P\+L\+O = \textquotesingle{}L\textquotesingle{}, the leading N-\/by-\/\+N lower triangular part of the array A contains the lower triangular matrix, and the strictly upper triangular part of A is not referenced. If D\+I\+A\+G = \textquotesingle{}U\textquotesingle{}, the diagonal elements of A are also not referenced and are assumed to be 1. On exit, the (triangular) inverse of the original matrix.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+N).\\
\hline
\mbox{\tt out}  & {\em info} & 
\begin{DoxyItemize}
\item 0 on successful exit
\item $<$0 if -\/i, the i-\/th argument had an illegal value
\item $>$0 if i, A(i,i) is exactly zero. The triangular matrix is singular and its inverse can not be computed. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\hypertarget{group__CORE__double_ga0cd12ddad904abd1a00df453bc5bb126_ga0cd12ddad904abd1a00df453bc5bb126}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtslqt@{C\+O\+R\+E\+\_\+dtslqt}}
\index{C\+O\+R\+E\+\_\+dtslqt@{C\+O\+R\+E\+\_\+dtslqt}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtslqt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dtslqt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga0cd12ddad904abd1a00df453bc5bb126_ga0cd12ddad904abd1a00df453bc5bb126}
C\+O\+R\+E\+\_\+dtslqt computes a L\+Q factorization of a rectangular matrix formed by coupling side-\/by-\/side a complex M-\/by-\/\+M lower triangular tile A1 and a complex M-\/by-\/\+N tile A2\+:

$\vert$ A1 A2 $\vert$ = L $\ast$ Q

The tile Q is represented as a product of elementary reflectors

Q = H(k)\textquotesingle{} . . . H(2)\textquotesingle{} H(1)\textquotesingle{}, where k = min(\+M,\+N).

Each H(i) has the form

H(i) = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a complex scalar, and v is a complex vector with v(1\+:i-\/1) = 0 and v(i) = 1; g(v(i+1\+:n)) is stored on exit in A2(i,1\+:n), and tau in T\+A\+U(i).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A1 and A2. M $>$= 0. The number of columns of the tile A1.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A2. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M-\/by-\/\+M tile A1. On exit, the elements on and below the diagonal of the array contain the M-\/by-\/\+M lower trapezoidal tile L; the elements above the diagonal are not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M-\/by-\/\+N tile A2. On exit, all the elements with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gafb81efeef8942dd4b3bd85d3e58d3c8c_gafb81efeef8942dd4b3bd85d3e58d3c8c}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtsmlq@{C\+O\+R\+E\+\_\+dtsmlq}}
\index{C\+O\+R\+E\+\_\+dtsmlq@{C\+O\+R\+E\+\_\+dtsmlq}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtsmlq}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dtsmlq (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const double $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gafb81efeef8942dd4b3bd85d3e58d3c8c_gafb81efeef8942dd4b3bd85d3e58d3c8c}
C\+O\+R\+E\+\_\+dtsmlq overwrites the general complex M1-\/by-\/\+N1 tile A1 and M2-\/by-\/\+N2 tile A2 with \begin{DoxyVerb}                  SIDE = 'L'        SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 A2 $\vert$ $\ast$ Q $\vert$ A2 $\vert$

T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+T $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 A2 $\vert$ $\ast$ Q$\ast$$\ast$\+T $\vert$ A2 $\vert$

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(k)\textquotesingle{} . . . H(2)\textquotesingle{} H(1)\textquotesingle{}

as returned by C\+O\+R\+E\+\_\+\+D\+T\+S\+L\+Q\+T.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+T from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+T from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+T.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of rows of the tile A2. M2 $>$= 0. M2 = M1 if side == Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of columns of the tile A2. N2 $>$= 0. N2 = N1 if side == Plasma\+Left.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+D\+T\+S\+L\+Q\+T in the first k rows of its array argument V.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. L\+D\+V $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+K triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+M1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,\+N1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gab75e15e330b097d4cb04e580b526c37d_gab75e15e330b097d4cb04e580b526c37d}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtsmlq\+\_\+corner@{C\+O\+R\+E\+\_\+dtsmlq\+\_\+corner}}
\index{C\+O\+R\+E\+\_\+dtsmlq\+\_\+corner@{C\+O\+R\+E\+\_\+dtsmlq\+\_\+corner}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtsmlq\+\_\+corner}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dtsmlq\+\_\+corner (
\begin{DoxyParamCaption}
\item[{int}]{m1, }
\item[{int}]{n1, }
\item[{int}]{m2, }
\item[{int}]{n2, }
\item[{int}]{m3, }
\item[{int}]{n3, }
\item[{int}]{k, }
\item[{int}]{ib, }
\item[{int}]{nb, }
\item[{double $\ast$}]{A1, }
\item[{int}]{lda1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{lda2, }
\item[{double $\ast$}]{A3, }
\item[{int}]{lda3, }
\item[{const double $\ast$}]{V, }
\item[{int}]{ldv, }
\item[{const double $\ast$}]{T, }
\item[{int}]{ldt, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{ldwork}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gab75e15e330b097d4cb04e580b526c37d_gab75e15e330b097d4cb04e580b526c37d}
C\+O\+R\+E\+\_\+dtsmlq\+\_\+corner\+: see C\+O\+R\+E\+\_\+dtsmlq

This kernel applies left and right transformations as depicted below\+: $\vert$\+I -\/\+V\+T\+V\textquotesingle{}$\vert$ $\ast$ $\vert$ A1 A2 $\vert$ $\ast$ $\vert$\+I -\/ V\+T\textquotesingle{}V\textquotesingle{}$\vert$ $\vert$ A2\textquotesingle{} A3 $\vert$ where A1 and A3 are symmetric matrices. Only the lower part is referenced. This is an adhoc implementation, can be further optimized...


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m1} & The number of rows of the tile A1. m1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n1} & The number of columns of the tile A1. n1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m2} & The number of rows of the tile A2. m2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n2} & The number of columns of the tile A2. n2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m3} & The number of rows of the tile A3. m3 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n3} & The number of columns of the tile A3. n3 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em ib} & The inner-\/blocking size. ib $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The blocking size. nb $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the m1-\/by-\/n1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda1} & The leading dimension of the array A1. lda1 $>$= max(1,m1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the m2-\/by-\/n2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda2} & The leading dimension of the tile A2. lda2 $>$= max(1,m2).\\
\hline
\mbox{\tt in,out}  & {\em A3} & On entry, the m3-\/by-\/n3 tile A3.\\
\hline
\mbox{\tt in}  & {\em lda3} & The leading dimension of the tile A3. lda3 $>$= max(1,m3).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+D\+T\+S\+L\+Q\+T in the first k rows of its array argument V.\\
\hline
\mbox{\tt in}  & {\em ldv} & The leading dimension of the array V. ldv $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/n1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em ldt} & The leading dimension of the array T. ldt $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/m1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em ldwork} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,n1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga4efacaf4c386e7c5cef9cd111d910ad9_ga4efacaf4c386e7c5cef9cd111d910ad9}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtsmlq\+\_\+sytra1@{C\+O\+R\+E\+\_\+dtsmlq\+\_\+sytra1}}
\index{C\+O\+R\+E\+\_\+dtsmlq\+\_\+sytra1@{C\+O\+R\+E\+\_\+dtsmlq\+\_\+sytra1}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtsmlq\+\_\+sytra1}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dtsmlq\+\_\+sytra1 (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{m1, }
\item[{int}]{n1, }
\item[{int}]{m2, }
\item[{int}]{n2, }
\item[{int}]{k, }
\item[{int}]{ib, }
\item[{double $\ast$}]{A1, }
\item[{int}]{lda1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{lda2, }
\item[{const double $\ast$}]{V, }
\item[{int}]{ldv, }
\item[{const double $\ast$}]{T, }
\item[{int}]{ldt, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{ldwork}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga4efacaf4c386e7c5cef9cd111d910ad9_ga4efacaf4c386e7c5cef9cd111d910ad9}
C\+O\+R\+E\+\_\+dtsmlq\+\_\+sytra1\+: see C\+O\+R\+E\+\_\+dtsmlq

This kernel applies a Right transformation on $\vert$ A1\textquotesingle{} A2 $\vert$ and does not handle the transpose of A1. Needs therefore to make the explicit transpose of A1 before and after the application of the block of reflectors Can be further optimized by changing accordingly the underneath kernel ztsrfb!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+T from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+T from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+T.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em m1} & The number of rows of the tile A1. m1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n1} & The number of columns of the tile A1. n1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m2} & The number of rows of the tile A2. m2 $>$= 0. m2 = m1 if side == Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em n2} & The number of columns of the tile A2. n2 $>$= 0. n2 = n1 if side == Plasma\+Left.\\
\hline
\mbox{\tt in}  & {\em k} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em ib} & The inner-\/blocking size. ib $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the m1-\/by-\/n1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda1} & The leading dimension of the array A1. lda1 $>$= max(1,m1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the m2-\/by-\/n2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda2} & The leading dimension of the tile A2. lda2 $>$= max(1,m2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+D\+T\+S\+L\+Q\+T in the first k rows of its array argument V. ! \\
\hline
\mbox{\tt in}  & {\em ldv} & The leading dimension of the array V. ldv $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/n1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em ldt} & The leading dimension of the array T. ldt $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/m1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em ldwork} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,n1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gae324a24ebf7b2b6009f63454134d5824_gae324a24ebf7b2b6009f63454134d5824}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtsmqr@{C\+O\+R\+E\+\_\+dtsmqr}}
\index{C\+O\+R\+E\+\_\+dtsmqr@{C\+O\+R\+E\+\_\+dtsmqr}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtsmqr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dtsmqr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const double $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gae324a24ebf7b2b6009f63454134d5824_gae324a24ebf7b2b6009f63454134d5824}
C\+O\+R\+E\+\_\+dtsmqr overwrites the general complex M1-\/by-\/\+N1 tile A1 and M2-\/by-\/\+N2 tile A2 with \begin{DoxyVerb}                  SIDE = 'L'        SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 A2 $\vert$ $\ast$ Q $\vert$ A2 $\vert$

T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+T $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 A2 $\vert$ $\ast$ Q$\ast$$\ast$\+T $\vert$ A2 $\vert$

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(1) H(2) . . . H(k)

as returned by C\+O\+R\+E\+\_\+\+D\+T\+S\+Q\+R\+T.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+T from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+T from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+T.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of rows of the tile A2. M2 $>$= 0. M2 = M1 if side == Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of columns of the tile A2. N2 $>$= 0. N2 = N1 if side == Plasma\+Left.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+D\+T\+S\+Q\+R\+T in the first k columns of its array argument V.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. L\+D\+V $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+K triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+N1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,\+M1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga502c8674867dfe112ce5fc9ac8ca1be7_ga502c8674867dfe112ce5fc9ac8ca1be7}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtsmqr\+\_\+corner@{C\+O\+R\+E\+\_\+dtsmqr\+\_\+corner}}
\index{C\+O\+R\+E\+\_\+dtsmqr\+\_\+corner@{C\+O\+R\+E\+\_\+dtsmqr\+\_\+corner}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtsmqr\+\_\+corner}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dtsmqr\+\_\+corner (
\begin{DoxyParamCaption}
\item[{int}]{m1, }
\item[{int}]{n1, }
\item[{int}]{m2, }
\item[{int}]{n2, }
\item[{int}]{m3, }
\item[{int}]{n3, }
\item[{int}]{k, }
\item[{int}]{ib, }
\item[{int}]{nb, }
\item[{double $\ast$}]{A1, }
\item[{int}]{lda1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{lda2, }
\item[{double $\ast$}]{A3, }
\item[{int}]{lda3, }
\item[{const double $\ast$}]{V, }
\item[{int}]{ldv, }
\item[{const double $\ast$}]{T, }
\item[{int}]{ldt, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{ldwork}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga502c8674867dfe112ce5fc9ac8ca1be7_ga502c8674867dfe112ce5fc9ac8ca1be7}
C\+O\+R\+E\+\_\+dtsmqr\+\_\+corner\+: see C\+O\+R\+E\+\_\+dtsmqr

This kernel applies left and right transformations as depicted below\+: $\vert$\+I -\/\+V\+T\textquotesingle{}V\textquotesingle{}$\vert$ $\ast$ $\vert$ A1 A2\textquotesingle{}$\vert$ $\ast$ $\vert$\+I -\/ V\+T\+V\textquotesingle{}$\vert$ $\vert$ A2 A3 $\vert$ where A1 and A3 are symmetric matrices. Only the lower part is referenced. This is an adhoc implementation, can be further optimized...


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m1} & The number of rows of the tile A1. m1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n1} & The number of columns of the tile A1. n1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m2} & The number of rows of the tile A2. m2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n2} & The number of columns of the tile A2. n2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m3} & The number of rows of the tile A3. m3 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n3} & The number of columns of the tile A3. n3 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em k} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em ib} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em nb} & The blocking size. N\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda1} & The leading dimension of the array A1. lda1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda2} & The leading dimension of the tile A2. lda2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in,out}  & {\em A3} & On entry, the m3-\/by-\/n3 tile A3.\\
\hline
\mbox{\tt in}  & {\em lda3} & The leading dimension of the tile A3. lda3 $>$= max(1,m3).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+D\+T\+S\+Q\+R\+T in the first k columns of its array argument V.\\
\hline
\mbox{\tt in}  & {\em ldv} & The leading dimension of the array V. ldv $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+N1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em ldt} & The leading dimension of the array T. ldt $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+N1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em ldwork} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,\+M1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga2a731f8fc79ae3f45e1d006a83c5dc6e_ga2a731f8fc79ae3f45e1d006a83c5dc6e}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtsmqr\+\_\+sytra1@{C\+O\+R\+E\+\_\+dtsmqr\+\_\+sytra1}}
\index{C\+O\+R\+E\+\_\+dtsmqr\+\_\+sytra1@{C\+O\+R\+E\+\_\+dtsmqr\+\_\+sytra1}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtsmqr\+\_\+sytra1}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dtsmqr\+\_\+sytra1 (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{m1, }
\item[{int}]{n1, }
\item[{int}]{m2, }
\item[{int}]{n2, }
\item[{int}]{k, }
\item[{int}]{ib, }
\item[{double $\ast$}]{A1, }
\item[{int}]{lda1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{lda2, }
\item[{const double $\ast$}]{V, }
\item[{int}]{ldv, }
\item[{const double $\ast$}]{T, }
\item[{int}]{ldt, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{ldwork}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga2a731f8fc79ae3f45e1d006a83c5dc6e_ga2a731f8fc79ae3f45e1d006a83c5dc6e}
C\+O\+R\+E\+\_\+dtsmqr\+\_\+sytra1\+: see C\+O\+R\+E\+\_\+dtsmqr

This kernel applies a left transformation on $\vert$ A1\textquotesingle{}$\vert$ $\vert$ A2 $\vert$

Needs therefore to make the explicit transpose of A1 before and after the application of the block of reflectors Can be further optimized by changing accordingly the underneath kernel ztsrfb!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+T from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+T from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+T.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em m1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em m2} & The number of rows of the tile A2. M2 $>$= 0. M2 = M1 if side == Plasma\+Right.\\
\hline
\mbox{\tt in}  & {\em n2} & The number of columns of the tile A2. N2 $>$= 0. N2 = N1 if side == Plasma\+Left.\\
\hline
\mbox{\tt in}  & {\em k} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em ib} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em lda2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+D\+T\+S\+Q\+R\+T in the first k columns of its array argument V.\\
\hline
\mbox{\tt in}  & {\em ldv} & The leading dimension of the array V. L\+D\+V $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+N1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em ldt} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+N1 if side == Plasma\+Left L\+D\+W\+O\+R\+K-\/by-\/\+I\+B if side == Plasma\+Right\\
\hline
\mbox{\tt in}  & {\em ldwork} & The leading dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B) if side == Plasma\+Left L\+D\+W\+O\+R\+K $>$= max(1,\+M1) if side == Plasma\+Right\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga6e39a0a7ef341418aa3cc2056f447b2c_ga6e39a0a7ef341418aa3cc2056f447b2c}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtsqrt@{C\+O\+R\+E\+\_\+dtsqrt}}
\index{C\+O\+R\+E\+\_\+dtsqrt@{C\+O\+R\+E\+\_\+dtsqrt}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtsqrt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dtsqrt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga6e39a0a7ef341418aa3cc2056f447b2c_ga6e39a0a7ef341418aa3cc2056f447b2c}
C\+O\+R\+E\+\_\+dtsqrt computes a Q\+R factorization of a rectangular matrix formed by coupling a complex N-\/by-\/\+N upper triangular tile A1 on top of a complex M-\/by-\/\+N tile A2\+:

$\vert$ A1 $\vert$ = Q $\ast$ R $\vert$ A2 $\vert$


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of columns of the tile A2. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of rows of the tile A1. The number of columns of the tiles A1 and A2. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the N-\/by-\/\+N tile A1. On exit, the elements on and above the diagonal of the array contain the N-\/by-\/\+N upper trapezoidal tile R; the elements below the diagonal are not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+N).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M-\/by-\/\+N tile A2. On exit, all the elements with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga19d4b2953d6e1f639990267b2b68fcc9_ga19d4b2953d6e1f639990267b2b68fcc9}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dtstrf@{C\+O\+R\+E\+\_\+dtstrf}}
\index{C\+O\+R\+E\+\_\+dtstrf@{C\+O\+R\+E\+\_\+dtstrf}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dtstrf}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dtstrf (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{int}]{N\+B, }
\item[{double $\ast$}]{U, }
\item[{int}]{L\+D\+U, }
\item[{double $\ast$}]{A, }
\item[{int}]{L\+D\+A, }
\item[{double $\ast$}]{L, }
\item[{int}]{L\+D\+L, }
\item[{int $\ast$}]{I\+P\+I\+V, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K, }
\item[{int $\ast$}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga19d4b2953d6e1f639990267b2b68fcc9_ga19d4b2953d6e1f639990267b2b68fcc9}
C\+O\+R\+E\+\_\+dtstrf computes an L\+U factorization of a complex matrix formed by an upper triangular N\+B-\/by-\/\+N tile U on top of a M-\/by-\/\+N tile A using partial pivoting with row interchanges.

This is the right-\/looking Level 2.\+5 B\+L\+A\+S version of the algorithm.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N\+B} & \\
\hline
\mbox{\tt in,out}  & {\em U} & On entry, the N\+B-\/by-\/\+N upper triangular tile. On exit, the new factor U from the factorization\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & The leading dimension of the array U. L\+D\+U $>$= max(1,\+N\+B).\\
\hline
\mbox{\tt in,out}  & {\em A} & On entry, the M-\/by-\/\+N tile to be factored. On exit, the factor L from the factorization\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & The leading dimension of the array A. L\+D\+A $>$= max(1,\+M).\\
\hline
\mbox{\tt in,out}  & {\em L} & On entry, the I\+B-\/by-\/\+N lower triangular tile. On exit, the interchanged rows form the tile A in case of pivoting.\\
\hline
\mbox{\tt in}  & {\em L\+D\+L} & The leading dimension of the array L. L\+D\+L $>$= max(1,\+I\+B).\\
\hline
\mbox{\tt out}  & {\em I\+P\+I\+V} & The pivot indices; for 1 $<$= i $<$= min(\+M,\+N), row i of the tile U was interchanged with row I\+P\+I\+V(i) of the tile A.\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & \\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The leading dimension of the array W\+O\+R\+K.\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if I\+N\+F\+O = -\/k, the k-\/th argument had an illegal value \\
\hline
{\em $>$0} & if I\+N\+F\+O = k, U(k,k) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga4016fab866fa44b3f0926b1a99e06348_ga4016fab866fa44b3f0926b1a99e06348}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dttlqt@{C\+O\+R\+E\+\_\+dttlqt}}
\index{C\+O\+R\+E\+\_\+dttlqt@{C\+O\+R\+E\+\_\+dttlqt}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dttlqt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dttlqt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga4016fab866fa44b3f0926b1a99e06348_ga4016fab866fa44b3f0926b1a99e06348}
C\+O\+R\+E\+\_\+dttlqt computes a L\+Q factorization of a rectangular matrix formed by coupling side-\/by-\/side a complex M-\/by-\/\+M lower triangular tile A1 and a complex M-\/by-\/\+N lower triangular tile A2\+:

$\vert$ A1 A2 $\vert$ = L $\ast$ Q

The tile Q is represented as a product of elementary reflectors

Q = H(k)\textquotesingle{} . . . H(2)\textquotesingle{} H(1)\textquotesingle{}, where k = min(\+M,\+N).

Each H(i) has the form

H(i) = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a complex scalar, and v is a complex vector with v(1\+:i-\/1) = 0 and v(i) = 1; g(v(i+1\+:n)) is stored on exit in A2(i,1\+:n), and tau in T\+A\+U(i).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A1 and A2. M $>$= 0. The number of columns of the tile A1.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A2. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M-\/by-\/\+M tile A1. On exit, the elements on and below the diagonal of the array contain the M-\/by-\/\+M lower trapezoidal tile L; the elements above the diagonal are not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+N).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M-\/by-\/\+N lower triangular tile A2. On exit, the elements on and below the diagonal of the array with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the array A2. L\+D\+A2 $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_gaa5facd81cc090e201d164e9802e5b5a3_gaa5facd81cc090e201d164e9802e5b5a3}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dttmlq@{C\+O\+R\+E\+\_\+dttmlq}}
\index{C\+O\+R\+E\+\_\+dttmlq@{C\+O\+R\+E\+\_\+dttmlq}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dttmlq}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dttmlq (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const double $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_gaa5facd81cc090e201d164e9802e5b5a3_gaa5facd81cc090e201d164e9802e5b5a3}
C\+O\+R\+E\+\_\+dttmlq overwrites the general complex M1-\/by-\/\+N1 tile A1 and M2-\/by-\/\+N2 tile A2 (N1 == N2) with \begin{DoxyVerb}                  SIDE = 'L'        SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 $\vert$ $\ast$ Q $\vert$ A2 $\vert$ $\vert$ A2 $\vert$

T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+T $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 $\vert$ $\ast$ Q$\ast$$\ast$\+T $\vert$ A2 $\vert$ $\vert$ A2 $\vert$

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(1) H(2) . . . H(k)

as returned by C\+O\+R\+E\+\_\+dttqrt.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+T from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+T from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+T.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of rows of the tile A2. M2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of columns of the tile A2. N2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+D\+T\+T\+Q\+R\+T in the first k rows of its array argument V.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. L\+D\+V $>$= max(1,\+K).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+N1.\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga5ff20296ac5424b6a431f514771bac87_ga5ff20296ac5424b6a431f514771bac87}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dttmqr@{C\+O\+R\+E\+\_\+dttmqr}}
\index{C\+O\+R\+E\+\_\+dttmqr@{C\+O\+R\+E\+\_\+dttmqr}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dttmqr}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dttmqr (
\begin{DoxyParamCaption}
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{side, }
\item[{P\+L\+A\+S\+M\+A\+\_\+enum}]{trans, }
\item[{int}]{M1, }
\item[{int}]{N1, }
\item[{int}]{M2, }
\item[{int}]{N2, }
\item[{int}]{K, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{const double $\ast$}]{V, }
\item[{int}]{L\+D\+V, }
\item[{const double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{W\+O\+R\+K, }
\item[{int}]{L\+D\+W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga5ff20296ac5424b6a431f514771bac87_ga5ff20296ac5424b6a431f514771bac87}
C\+O\+R\+E\+\_\+dttmqr overwrites the general complex M1-\/by-\/\+N1 tile A1 and M2-\/by-\/\+N2 tile A2 (N1 == N2) with \begin{DoxyVerb}                  SIDE = 'L'        SIDE = 'R'
\end{DoxyVerb}
 T\+R\+A\+N\+S = \textquotesingle{}N\textquotesingle{}\+: Q $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 $\vert$ $\ast$ Q $\vert$ A2 $\vert$ $\vert$ A2 $\vert$

T\+R\+A\+N\+S = \textquotesingle{}C\textquotesingle{}\+: Q$\ast$$\ast$\+T $\ast$ $\vert$ A1 $\vert$ $\vert$ A1 $\vert$ $\ast$ Q$\ast$$\ast$\+T $\vert$ A2 $\vert$ $\vert$ A2 $\vert$

where Q is a complex unitary matrix defined as the product of k elementary reflectors

Q = H(1) H(2) . . . H(k)

as returned by C\+O\+R\+E\+\_\+dttqrt.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em side} & \begin{DoxyItemize}
\item Plasma\+Left \+: apply Q or Q$\ast$$\ast$\+T from the Left; \item Plasma\+Right \+: apply Q or Q$\ast$$\ast$\+T from the Right.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em trans} & \begin{DoxyItemize}
\item Plasma\+No\+Trans \+: No transpose, apply Q; \item Plasma\+Trans \+: Conj\+Transpose, apply Q$\ast$$\ast$\+T.\end{DoxyItemize}
\\
\hline
\mbox{\tt in}  & {\em M1} & The number of rows of the tile A1. M1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N1} & The number of columns of the tile A1. N1 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em M2} & The number of rows of the tile A2. M2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N2} & The number of columns of the tile A2. N2 $>$= 0.\\
\hline
\mbox{\tt in}  & {\em K} & The number of elementary reflectors whose product defines the matrix Q.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the M1-\/by-\/\+N1 tile A1. On exit, A1 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+M1).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M2-\/by-\/\+N2 tile A2. On exit, A2 is overwritten by the application of Q.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the tile A2. L\+D\+A2 $>$= max(1,\+M2).\\
\hline
\mbox{\tt in}  & {\em V} & The i-\/th row must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by C\+O\+R\+E\+\_\+\+D\+T\+T\+Q\+R\+T in the first k rows of its array argument V.\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & The leading dimension of the array V. L\+D\+V $>$= max(1,\+K).\\
\hline
\mbox{\tt in}  & {\em T} & The I\+B-\/by-\/\+N1 triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & Workspace array of size L\+D\+W\+O\+R\+K-\/by-\/\+N1.\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & The dimension of the array W\+O\+R\+K. L\+D\+W\+O\+R\+K $>$= max(1,\+I\+B).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga28849d5bca87c3e7f82a32f838c32588_ga28849d5bca87c3e7f82a32f838c32588}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+dttqrt@{C\+O\+R\+E\+\_\+dttqrt}}
\index{C\+O\+R\+E\+\_\+dttqrt@{C\+O\+R\+E\+\_\+dttqrt}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+dttqrt}]{\setlength{\rightskip}{0pt plus 5cm}int C\+O\+R\+E\+\_\+dttqrt (
\begin{DoxyParamCaption}
\item[{int}]{M, }
\item[{int}]{N, }
\item[{int}]{I\+B, }
\item[{double $\ast$}]{A1, }
\item[{int}]{L\+D\+A1, }
\item[{double $\ast$}]{A2, }
\item[{int}]{L\+D\+A2, }
\item[{double $\ast$}]{T, }
\item[{int}]{L\+D\+T, }
\item[{double $\ast$}]{T\+A\+U, }
\item[{double $\ast$}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga28849d5bca87c3e7f82a32f838c32588_ga28849d5bca87c3e7f82a32f838c32588}
C\+O\+R\+E\+\_\+dttqrt computes a Q\+R factorization of a rectangular matrix formed by coupling a complex N-\/by-\/\+N upper triangular tile A1 on top of a complex M-\/by-\/\+N upper trapezoidal tile A2\+:

$\vert$ A1 $\vert$ = Q $\ast$ R $\vert$ A2 $\vert$

The tile Q is represented as a product of elementary reflectors

Q = H(1) H(2) . . . H(k), where k = min(\+M,\+N).

Each H(i) has the form

H(i) = I -\/ tau $\ast$ v $\ast$ v\textquotesingle{}

where tau is a complex scalar, and v is a complex vector with v(1\+:i-\/1) = 0 and v(i) = 1; v(i+1\+:m) is stored on exit in A2(1\+:m,i), and tau in T\+A\+U(i).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & The number of rows of the tile A2. M $>$= 0.\\
\hline
\mbox{\tt in}  & {\em N} & The number of columns of the tile A1 and A2. N $>$= 0.\\
\hline
\mbox{\tt in}  & {\em I\+B} & The inner-\/blocking size. I\+B $>$= 0.\\
\hline
\mbox{\tt in,out}  & {\em A1} & On entry, the N-\/by-\/\+N tile A1. On exit, the elements on and above the diagonal of the array contain the N-\/by-\/\+N upper trapezoidal tile R; the elements below the diagonal are not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+A1} & The leading dimension of the array A1. L\+D\+A1 $>$= max(1,\+N).\\
\hline
\mbox{\tt in,out}  & {\em A2} & On entry, the M-\/by-\/\+N upper triangular tile A2. On exit, the elements on and above the diagonal of the array with the array T\+A\+U, represent the unitary tile Q as a product of elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in}  & {\em L\+D\+A2} & The leading dimension of the array A2. L\+D\+A2 $>$= max(1,\+M).\\
\hline
\mbox{\tt out}  & {\em T} & The I\+B-\/by-\/\+N triangular factor T of the block reflector. T is upper triangular by block (economic storage); The rest of the array is not referenced.\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & The leading dimension of the array T. L\+D\+T $>$= I\+B.\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & The scalar factors of the elementary reflectors (see Further Details).\\
\hline
\mbox{\tt in,out}  & {\em W\+O\+R\+K} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em P\+L\+A\+S\+M\+A\+\_\+\+S\+U\+C\+C\+E\+S\+S} & successful exit \\
\hline
{\em $<$0} & if -\/i, the i-\/th argument had an illegal value \\
\hline
\end{DoxyRetVals}
\hypertarget{group__CORE__double_ga0e4b82b2033ca8c4a3bdbfa6327810ab_ga0e4b82b2033ca8c4a3bdbfa6327810ab}{}\index{Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}!C\+O\+R\+E\+\_\+slag2d@{C\+O\+R\+E\+\_\+slag2d}}
\index{C\+O\+R\+E\+\_\+slag2d@{C\+O\+R\+E\+\_\+slag2d}!Kernel Interface -\/ Double Real@{Kernel Interface -\/ Double Real}}
\subsubsection[{C\+O\+R\+E\+\_\+slag2d}]{\setlength{\rightskip}{0pt plus 5cm}void C\+O\+R\+E\+\_\+slag2d (
\begin{DoxyParamCaption}
\item[{int}]{m, }
\item[{int}]{n, }
\item[{const float $\ast$}]{A, }
\item[{int}]{lda, }
\item[{double $\ast$}]{B, }
\item[{int}]{ldb}
\end{DoxyParamCaption}
)}\label{group__CORE__double_ga0e4b82b2033ca8c4a3bdbfa6327810ab_ga0e4b82b2033ca8c4a3bdbfa6327810ab}
C\+O\+R\+E\+\_\+\+P\+L\+A\+S\+M\+A\+\_\+slag2d converts a float matrix, A, to a double matrix, B.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & The number of rows of the matrices A and B. m $>$= 0.\\
\hline
\mbox{\tt in}  & {\em n} & The number of columns of the matrices A and B. n $>$= 0.\\
\hline
\mbox{\tt in}  & {\em A} & The float m-\/by-\/n matrix to convert.\\
\hline
\mbox{\tt in}  & {\em lda} & The leading dimension of the array A. lda $>$= max(1,m).\\
\hline
\mbox{\tt out}  & {\em B} & The double m-\/by-\/n matrix to convert.\\
\hline
\mbox{\tt in}  & {\em ldb} & The leading dimension of the array B. ldb $>$= max(1,m). \\
\hline
\end{DoxyParams}
